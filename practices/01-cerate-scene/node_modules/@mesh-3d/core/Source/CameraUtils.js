import polyfill from "./polyfill.js";

/**
 * 相机工具，转换cesium和threejs相机，仅做参数映射，不考虑两个引擎的差异。也即是以cesium相机为主，换到threejs相机只是为了语法上的需要
 */
class CameraUtils {

    /**
     * 
     * @param {THREE.PerspectiveCamera|Cesium.Camera} camera
     * @param {THREE.Matrix4} mirrorMatrixWorld 
     * @param {THREE.PerspectiveCamera} [mirrorCamera] 
     */
    static getMirrorCamera(camera, mirrorMatrixWorld, mirrorCamera, up) {
        if (camera instanceof Cesium.Camera) {
            camera = this.toPerspectiveCamera3js(camera)
        }

        var { Vector3, Matrix4, PerspectiveCamera } = THREE;
        var mirrorWorldPosition = new Vector3();
        var cameraWorldPosition = new Vector3();
        var rotationMatrix = new Matrix4();
        var normal = new Vector3();
        var view = new Vector3();
        var lookAtPosition = new Vector3();
        var target = new Vector3();

        var scope = {
            matrixWorld: mirrorMatrixWorld
        }
        mirrorCamera = mirrorCamera || new PerspectiveCamera();
        // mirrorCamera.copy(camera);

        mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld)
        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
        rotationMatrix.extractRotation(scope.matrixWorld)

        normal.set(0, 0, 1);
        normal.applyMatrix4(rotationMatrix);

        view.subVectors(mirrorWorldPosition, cameraWorldPosition);

        // Avoid rendering when mirror is facing away

        // if (view.dot(normal) > 0) return;

        view.reflect(normal).negate();
        view.add(mirrorWorldPosition);

        rotationMatrix.extractRotation(camera.matrixWorld);

        lookAtPosition.set(0, 0, 1);
        lookAtPosition.applyMatrix4(rotationMatrix);
        lookAtPosition.add(cameraWorldPosition);

        target.subVectors(mirrorWorldPosition, lookAtPosition);
        target.reflect(normal).negate();
        target.add(mirrorWorldPosition);

        mirrorCamera.position.copy(view);
        mirrorCamera.up.set(0, 1, 0);
        mirrorCamera.up.applyMatrix4(rotationMatrix);
        mirrorCamera.up.reflect(normal);
        mirrorCamera.lookAt(target);

        mirrorCamera.updateMatrixWorld();
        mirrorCamera.far = camera.far;
        mirrorCamera.near = camera.near;
        mirrorCamera.fov = camera.fov;
        mirrorCamera.focus = camera.focus;
        mirrorCamera.updateProjectionMatrix()

        mirrorCamera.projectionMatrix.copy(camera.projectionMatrix);

        return mirrorCamera;
    }

    /**
     * 
     * @param {THREE.Camera} camera3js 
     * @return {Cesium.Camera}
     */
    static getCameraFromCache(camera3js) {
        return cameraMap.get(camera3js);
    }

    /**
     * 
     * @param {THREE.Camera} camera3js 
     * @return {THREE.Frustum}
     */
    static getFrustum3js(camera3js) {
        if (!camera3js.isCamera) camera3js = cameraMap.get(camera3js);
        return frustumMap.get(camera3js);
    }

    /**
     * cesium相机转threejs相机
     * @param {Cesium.Camera} camera  
     * @param {THREE.PerspectiveCamera} [camera3js] 
     * @param {{
     *  matrix:Cesium.Matrix4,
     *  inverseMatrix:Cesium.Matrix4
     * }} [referenceFrame] 
     * @returns {THREE.PerspectiveCamera} camera3js
     */
    static toPerspectiveCamera3js(camera, camera3js, referenceFrame) {

        referenceFrame = referenceFrame || camera._referenceFrame;
        var frustum = camera.frustum;
        if (!camera3js) {
            if (cameraMap.has(camera)) {
                camera3js = cameraMap.get(camera);
            }
            else {
                camera3js = new THREE.PerspectiveCamera();
                cameraMap.set(camera, camera3js);
            }
        }

        camera3js.aspect = frustum.aspectRatio;
        camera3js.near = frustum.near;
        camera3js.far = frustum.far;
        camera3js.fov = Cesium.Math.toDegrees(frustum.fovy);

        camera3js.updateProjectionMatrix();

        // var cvm =  camera.viewMatrix;
        // var civm = camera.inverseViewMatrix;
        // camera3js.matrixWorld.set(
        //   civm[0], civm[4], civm[8 ], civm[12],
        //   civm[1], civm[5], civm[9 ], civm[13],
        //   civm[2], civm[6], civm[10], civm[14],
        //   civm[3], civm[7], civm[11], civm[15]
        // );
        // camera3js.matrixWorldInverse.set(
        //   cvm[0], cvm[4], cvm[8 ], cvm[12],
        //   cvm[1], cvm[5], cvm[9 ], cvm[13],
        //   cvm[2], cvm[6], cvm[10], cvm[14],
        //   cvm[3], cvm[7], cvm[11], cvm[15]
        // );

        convertMatrixFromCameraCesium(camera, camera3js, referenceFrame);

        return camera3js;
    }

    /**
     * cesium相机转threejs相机
     * @param {Cesium.Camera} camera  
     * @param {THREE.OrthographicCamera} [camera3js] 
     * @param {{
        *  matrix:Cesium.Matrix4,
        *  inverseMatrix:Cesium.Matrix4
        * }} [referenceFrame] 
        * @returns {THREE.OrthographicCamera} camera3js
        */
    static toOrthographicCamera3js(camera, camera3js, referenceFrame) {

        referenceFrame = referenceFrame || camera._referenceFrame;
        var frustum = camera.frustum;
        if (!camera3js) {
            if (cameraMap.has(camera)) {
                camera3js = cameraMap.get(camera);
            }
            else {
                camera3js = new THREE.OrthographicCamera();
                cameraMap.set(camera, camera3js);
            }
        }

        var w = camera.frustum.width, h = w / frustum.aspectRatio;
        camera3js.right = w / 2;
        camera3js.left = -w / 2;
        camera3js.top = h / 2;
        camera3js.bottom = -h / 2;

        camera3js.near = frustum.near;
        camera3js.far = frustum.far;

        // let w = camera3js.right - camera3js.left,
        // h = camera3js.top - camera3js.bottom;

        // frustum.aspectRatio = w / h;
        // frustum.near = camera3js.near;
        // frustum.far = camera3js.far;
        // frustum.width = w;

        camera3js.updateProjectionMatrix();


        // var cvm =  camera.viewMatrix;
        // var civm = camera.inverseViewMatrix;
        // camera3js.matrixWorld.set(
        //   civm[0], civm[4], civm[8 ], civm[12],
        //   civm[1], civm[5], civm[9 ], civm[13],
        //   civm[2], civm[6], civm[10], civm[14],
        //   civm[3], civm[7], civm[11], civm[15]
        // );
        // camera3js.matrixWorldInverse.set(
        //   cvm[0], cvm[4], cvm[8 ], cvm[12],
        //   cvm[1], cvm[5], cvm[9 ], cvm[13],
        //   cvm[2], cvm[6], cvm[10], cvm[14],
        //   cvm[3], cvm[7], cvm[11], cvm[15]
        // );

        convertMatrixFromCameraCesium(camera, camera3js, referenceFrame);

        return camera3js;
    }


    /**
     * threejs's PerspectiveCamera=>cesium's camera
     * @param {THREE.PerspectiveCamera} camera3js 
      * @param {Cesium.Scene} scene
     * @param {{
     *  matrix:Cesium.Matrix4,
     *  inverseMatrix:Cesium.Matrix4
     * }} [referenceFrame] 
      * @param {Cesium.Camera} [camera]
     * @returns {Cesium.Camera} camera  
     */
    static fromPerspectiveCamera3js(camera3js, scene, referenceFrame, camera) {
        const _Cesium = Cesium;

        updateFrustum3js(camera3js);

        referenceFrame = referenceFrame || camera3js._referenceFrame;

        if (!camera) {
            if (cameraMap.has(camera3js)) {
                camera = cameraMap.get(camera3js);
            }
            else {
                camera = new _Cesium.Camera(scene);
                camera.frustum.xOffset = 0;
                camera.frustum.yOffset = 0;
                cameraMap.set(camera3js, camera);
            }
        }

        //frustum
        let frustum = camera.frustum;
        let fovy = _Cesium.Math.toRadians(camera3js.fov);

        frustum.aspectRatio = camera3js.aspect;
        frustum.near = camera3js.near;
        frustum.far = camera3js.far;
        frustum.fov = Math.atan(Math.tan(fovy * 0.5) * frustum.aspectRatio) * 2.0;

        //viewMatrix,inverseViewMatrix,position,direction

        convertMatrixFromCamera3js(camera3js, camera, referenceFrame);

        return camera;
    }

    /**
     * threejs's PerspectiveCamera=>cesium's camera
     * @param {THREE.OrthographicCamera} camera3js 
     * @param {Cesium.Scene} scene
     * @param {{
        *  matrix:Cesium.Matrix4,
        *  inverseMatrix:Cesium.Matrix4
        * }} [referenceFrame] 
      * @param {Cesium.Camera} [camera]
        * @returns {Cesium.Camera} camera  
        */
    static fromOrthographicCamera3js(camera3js, scene, referenceFrame, camera) {
        const { Camera, OrthographicFrustum } = Cesium;

        updateFrustum3js(camera3js);

        referenceFrame = referenceFrame || camera3js._referenceFrame;

        if (!camera) {
            if (cameraMap.has(camera3js)) {
                camera = cameraMap.get(camera3js);
            }
            else {
                camera = new Camera(scene);
                camera.frustum = new OrthographicFrustum()
                cameraMap.set(camera3js, camera);
            }
        }

        //frustum
        /**
         * @type {Cesium.OrthographicFrustum}
         * @private
         */
        let frustum = camera.frustum;
        let w = camera3js.right - camera3js.left,
            h = camera3js.top - camera3js.bottom;

        frustum.aspectRatio = w / h;
        frustum.near = camera3js.near || 1e-16;
        frustum.far = camera3js.far;
        frustum.width = w;

        //viewMatrix,inverseViewMatrix,position,direction

        convertMatrixFromCamera3js(camera3js, camera, referenceFrame);

        return camera;
    }
}


var cvm, civm, _cacheCameraTarget, _cacheCameraRotationMatrix, _cacheCameraRotationMatrix4;
var cameraMap = new WeakMap(), frustumMap = new WeakMap();
var _cacheCameraPosition, _cacheCameraDirection;
var _cacheDirInverse = {
    x: 0, y: 1, z: 0
};
var _cacheCameraProjScreenMatrix, _cacheCameraViewMatrix, _cacheCameraInverseViewMatrix;

function _getCacheCamera3jsProjScreenMatrix(camera) {

    if (!_cacheCameraProjScreenMatrix) _cacheCameraProjScreenMatrix = new THREE.Matrix4();
    _cacheCameraProjScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

    return _cacheCameraProjScreenMatrix;
}



/**
 * 
 * @param {THREE.PerspectiveCamera|THREE.OrthographicCamera} camera3js 
 * @param {Cesium.Camera} camera 
 * @param {*} referenceFrame 
 * @private
 */
function convertMatrixFromCamera3js(camera3js, camera, referenceFrame) {
    const { Matrix4, Cartesian3, Matrix3 } = Cesium;

    polyfill();

    //viewMatrix&inverseViewMatrix

    let matrixWorld = camera3js.matrixWorld.elements,
        matrixWorldInverse = camera3js.matrixWorldInverse.elements;

    //  setMatrix

    if (!_cacheCameraViewMatrix) {
        _cacheCameraViewMatrix = new Matrix4()
        _cacheCameraInverseViewMatrix = new Matrix4()
        _cacheCameraPosition = new Cartesian3();
        _cacheCameraDirection = new Cartesian3();
    }

    if (referenceFrame && referenceFrame.matrix) {
        camera3js.modelMatrix = Matrix4.multiply(referenceFrame.matrix, matrixWorld, camera3js.modelMatrix || new Matrix4());

        Matrix4.clone(camera3js.modelMatrix, _cacheCameraInverseViewMatrix);
        Matrix4.inverse(camera3js.modelMatrix, _cacheCameraViewMatrix);
    } else {
        Matrix4.clone(matrixWorldInverse, _cacheCameraViewMatrix);
        Matrix4.clone(matrixWorld, _cacheCameraInverseViewMatrix);
    }

    //position and direction
    // Matrix4.getTranslation(_cacheCameraInverseViewMatrix, camera.position);
    // var rotMat = new Matrix3();
    // Matrix4.getMatrix3(_cacheCameraInverseViewMatrix, rotMat);
    // Matrix3.getColumn(rotMat, 0, camera.direction);
    // Matrix3.getColumn(rotMat, 2, camera.up);
    // Cartesian3.cross(camera.direction, camera.up, camera.right);
    // camera._adjustOrthographicFrustum(true);

    Matrix4.getTranslation(_cacheCameraInverseViewMatrix, _cacheCameraPosition);
    if (camera3js.isOrthographicCamera || !Cartesian3.equals(Cartesian3.ZERO, _cacheCameraPosition)) {
        Matrix4.multiplyByPoint(_cacheCameraInverseViewMatrix, _cacheDirInverse, _cacheCameraDirection)
        Cartesian3.subtract(_cacheCameraDirection, _cacheCameraPosition, _cacheCameraDirection);
        _cacheCameraPosition.clone(camera.position);
        _cacheCameraDirection.clone(camera.direction);
    }

    // Cartesian3.cross(camera.direction, camera.up, camera.right);

    Matrix4.clone(_cacheCameraViewMatrix, camera.viewMatrix);
    Matrix4.clone(_cacheCameraInverseViewMatrix, camera.inverseViewMatrix);

    //custom projectionMatrix
    if (!Matrix4.equals(camera.frustum.projectionMatrix, camera3js.projectionMatrix.elements)) {
        let customCamera = camera.customCamera || {}
        customCamera.projectionMatrix = Matrix4.clone(
            camera3js.projectionMatrix.elements, customCamera.projectionMatrix
        );
        camera.customCamera = customCamera;
    } else {
        camera.customCamera = undefined
    }

}

/**
 * 
 * @param {*} camera 
 * @param {THREE.Camera} camera3js 
 * @param {*} referenceFrame
 * @private 
 */
function convertMatrixFromCameraCesium(camera, camera3js, referenceFrame) {
    const Matrix4 = Cesium.Matrix4;
    const matrixWorld = camera3js.matrixWorld;
    const inverseViewMatrix = camera.inverseViewMatrix;

    polyfill();

    if (Matrix4.equals(inverseViewMatrix, camera3js.modelMatrix)) {
        return;
    }

    if (referenceFrame) {
        if (!referenceFrame.inverseMatrix) {
            let inverseMatrix = new Matrix4()
            referenceFrame.inverseMatrix = Matrix4.inverse(referenceFrame.matrix, inverseMatrix);
        }
        matrixWorld.multiplyMatrices(referenceFrame.inverseMatrix, inverseViewMatrix)

    } else {
        matrixWorld.copy(inverseViewMatrix)
    }

    matrixWorld.decompose(camera3js.position, camera3js.quaternion, camera3js.scale);
    camera3js.updateMatrixWorld();

    camera3js.modelMatrix = Matrix4.clone(inverseViewMatrix, camera3js.modelMatrix)

    //custom projectionMatrix
    if (camera.customCamera) {
        var customCamera = camera.customCamera;
        if (customCamera.projectionMatrix) {
            camera3js.projectionMatrix.copy(customCamera.projectionMatrix);
            camera3js.projectionMatrixInverse.invert(camera3js.projectionMatrix)
        }
    }

    //update frustum 
    updateFrustum3js(camera3js);

}

function updateFrustum3js(camera3js) {
    var frustum3js = frustumMap.get(camera3js);
    if (!frustum3js) {
        frustum3js = new THREE.Frustum();
        frustumMap.set(camera3js, frustum3js);
    }

    var projScreenMatrix = _getCacheCamera3jsProjScreenMatrix(camera3js);
    frustum3js.setFromProjectionMatrix(projScreenMatrix);

}

export default CameraUtils;
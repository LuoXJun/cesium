import ConstantMap from './ConstantMap.js';
import DDSTexture from './DDSTexture.js';

/**
 * 纹理相关工具类，实现转换threejs纹理，重采样等功能
 * @class
 */
function TextureUtils() { }


TextureUtils.getPixelDataType = function (type3js) {

    return ConstantMap.typesMap[type3js];
}

TextureUtils.getPixelFormat = function (format3js) {

    return ConstantMap.formatsMap[format3js];
}

TextureUtils.createTexture = function (textureUniform, context, maximumTextureSize) {

    const { Texture, TextureMinificationFilter, TextureWrap, PixelFormat, WebGLConstants, ContextLimits } = Cesium;
    const _Math = Cesium.Math;

    let texture = textureUniform;
    var sampler = texture.sampler;

    var mipmap =
        (sampler.minificationFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST) ||
        (sampler.minificationFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR) ||
        (sampler.minificationFilter === TextureMinificationFilter.LINEAR_MIPMAP_NEAREST) ||
        (sampler.minificationFilter === TextureMinificationFilter.LINEAR_MIPMAP_LINEAR);

    var requiresNpot = mipmap ||
        (sampler.wrapS === TextureWrap.REPEAT) ||
        (sampler.wrapS === TextureWrap.MIRRORED_REPEAT) ||
        (sampler.wrapT === TextureWrap.REPEAT) ||
        (sampler.wrapT === TextureWrap.MIRRORED_REPEAT);

    var source = texture.source;
    let width = texture.width, height = texture.height;

    var npot = source && (!_Math.isPowerOfTwo(source.width) || !_Math.isPowerOfTwo(source.height));
    if (requiresNpot && npot) {
        // WebGL requires power-of-two texture dimensions for mipmapping and REPEAT/MIRRORED_REPEAT wrap modes.
        var canvas = document.createElement('canvas');
        canvas.width = _Math.nextPowerOfTwo(source.width);
        canvas.height = _Math.nextPowerOfTwo(source.height);
        var canvasContext = canvas.getContext('2d');
        canvasContext.drawImage(source, 0, 0, source.width, source.height, 0, 0, canvas.width, canvas.height);
        source = canvas;
        width = canvas.width;
        height = canvas.height;
    }

    var tx, pixelFormat = texture.internalFormat || texture.format;
    var isCompressed = PixelFormat.isCompressedFormat(pixelFormat);

    let textureCtor = isCompressed ? DDSTexture : Texture

    let needsResize = false;
    maximumTextureSize = maximumTextureSize || ContextLimits.maximumTextureSize;

    if (width > maximumTextureSize) {
        width = maximumTextureSize;
        needsResize = true;

        console.warn("Mesh3D.TextureUtils:Width should be less than or equal to the maximum texture size (" +
            maximumTextureSize +
            ").  Check maximumTextureSize.");
    }
    if (height > maximumTextureSize) {
        console.warn("Mesh3D.TextureUtils:Height should be less than or equal to the maximum texture size (" +
            maximumTextureSize +
            ").  Check maximumTextureSize.");
        height = maximumTextureSize;
        if (!needsResize) {
            width = maximumTextureSize * (width / height);
        }
        needsResize = true;
    } else if (needsResize) {
        height = maximumTextureSize * (height / width);
    }

    if (needsResize) {
        console.warn("Mesh3D.TextureUtils:Width and height must be less than or equal to the maximum texture size (" +
            maximumTextureSize +
            ").  Check maximumTextureSize.");

        // if (mipmap) {
        //     width = _Math.nextPowerOfTwo(width);
        //     height = _Math.nextPowerOfTwo(height);
        // }

        var canvas = TextureUtils._resampleImage(source, width, height, mipmap)
        // document.createElement('canvas');
        // canvas.width = width;
        // canvas.height = height;
        // var canvasContext = canvas.getContext('2d');
        // canvasContext.drawImage(source, 0, 0, source.width, source.height, 0, 0, canvas.width, canvas.height);
        source = canvas;
        width = canvas.width;
        height = canvas.height;
    }

    tx = new textureCtor({
        context: context,
        source: source,
        width: width,
        height: height,
        pixelFormat: pixelFormat,
        pixelDatatype: texture.type,
        sampler: sampler,
        flipY: texture.flipY,
        preMultiplyAlpha: texture.preMultiplyAlpha
    });

    if (mipmap && !isCompressed) {
        tx.generateMipmap();
    }

    return tx;
}

TextureUtils.createCubeTexture = function (textureUniform, context) {
    let images = textureUniform.value;
    let cubemap = new Cesium.CubeMap({
        context: context,
        source: {
            positiveX: images[0],
            negativeX: images[1],
            positiveY: images[2],
            negativeY: images[3],
            positiveZ: images[4],
            negativeZ: images[5]
        },
        pixelFormat: textureUniform.format,
        pixelDatatype: textureUniform.type,
        preMultiplyAlpha: textureUniform.preMultiplyAlpha,
        flipY: textureUniform.flipY//,
        // sampler: item.sampler ? new Cesium.Sampler(item.sampler) : undefined
    });
    return cubemap;
}
TextureUtils.fromTexure3js = function (val3js, valCesium) {

    if (val3js.isTexture) {
        var sampler = {};
        sampler.minificationFilter = ConstantMap.minFilterMap[val3js.minFilter];
        sampler.magnificationFilter = ConstantMap.magFilterMap[val3js.magFilter];
        sampler.wrapS = ConstantMap.textureWrapMap[val3js.wrapS];
        sampler.wrapT = ConstantMap.textureWrapMap[val3js.wrapT];
        sampler.maximumAnisotropy = val3js.anisotropy;

        if (!valCesium) {
            valCesium = {
                uuid: val3js.uuid
            };

            valCesium._disposeCallbacks = [];
            valCesium.onDispose = function (disposeCallback) {
                if (this._disposeCallbacks.indexOf(disposeCallback) == -1) {
                    this._disposeCallbacks.push(disposeCallback);
                }
            }
            valCesium.destroy = function () {
                for (var i = 0; i < this._disposeCallbacks.length; i++) {
                    var disposeCallback = this._disposeCallbacks[i];
                    disposeCallback.call(this);
                }

                this._disposeCallbacks.splice(0);
            }
        }

        if (!valCesium.getCacheKey) {
            var hasOffscreenCanvas = typeof OffscreenCanvas != 'undefined'
            valCesium.getCacheKey = function () {
                var item = this;
                var cacheKey = !item.uuid && typeof item.value == 'string' ? item.value : item.uuid;
                if (!cacheKey) {
                    if (item.value.uuid && (item._value instanceof HTMLImageElement
                        || item.value instanceof HTMLCanvasElement
                        || item.value instanceof HTMLVideoElement
                        || (hasOffscreenCanvas && item.value instanceof OffscreenCanvas))
                    ) {
                        cacheKey = item._value.uuid;
                    }
                }
                return cacheKey;
            }
        }

        valCesium.value = val3js.image;
        let needsUpdate = valCesium.version != val3js.version;
        var cacheKey = valCesium.getCacheKey();
        if (!needsUpdate && valCesium.cacheKey != cacheKey) needsUpdate = true;

        var isEmptyTextureUniform = false;
        if (val3js.isDataTexture) {
            valCesium.width = val3js.image.width;
            valCesium.height = val3js.image.height;

            valCesium.source = {
                arrayBufferView: val3js.image.data,
                width: val3js.image.width,
                height: val3js.image.height
            }
            valCesium.needsUpdate = !!val3js.image.data;
        }
        else if (val3js.isCompressedTexture) {

            if (!val3js.image.width || !val3js.image.height) {

                var images = val3js.image;
                if (Array.isArray(images) && images.length > 0 && images[0].width && images[0].width) {

                    if (needsUpdate) {

                        valCesium.value = images;
                        valCesium.source = [];

                        valCesium.width = images[0].width;
                        valCesium.height = images[0].height;

                        for (let i = 0; i < images.length; i++) {
                            const image = images[i];
                            let mipLevels = [];
                            for (let i = 1; i < image.mipmaps.length; i++) {
                                mipLevels.push(image.mipmaps[i].data)
                            }
                            var source = {
                                arrayBufferView: image.mipmaps[0].data,
                                width: image.width,
                                height: image.height,
                                mipLevels: mipLevels
                            }
                            valCesium.source.push(source);
                        }
                    }

                } else {
                    valCesium.value = null;
                    valCesium.source = null;
                    isEmptyTextureUniform = true;
                }
            } else {
                valCesium.width = val3js.image.width;
                valCesium.height = val3js.image.height;

                valCesium.value = {
                    width: val3js.image.width,
                    height: val3js.image.height,
                    arrayBufferView: val3js.image.data
                };

                if (needsUpdate && val3js.mipmaps && val3js.mipmaps.length > 0) {
                    let mipLevels = [];
                    for (let i = 1; i < val3js.mipmaps.length; i++) {
                        mipLevels.push(val3js.mipmaps[i].data)
                    }
                    valCesium.source = {
                        arrayBufferView: val3js.mipmaps[0].data,
                        width: val3js.image.width,
                        height: val3js.image.height,
                        mipLevels: mipLevels
                    }
                }
            }
        }
        else if (val3js.isCanvasTexture || val3js.image instanceof ImageData) {
            valCesium.width = val3js.image.width;
            valCesium.height = val3js.image.height;

            valCesium.source = val3js.image;
        }
        else if (Array.isArray(valCesium.value)) {//hdr CubeTexture

            let images = valCesium.value;
            var hasEmpty = false;
            images = images.map(image => {
                if (!image) hasEmpty = true;
                if (image.isDataTexture) {
                    let tex = image;
                    return {
                        width: tex.image.width,
                        height: tex.image.height,
                        arrayBufferView: tex.image.data
                    }
                }
                return image
            });

            isEmptyTextureUniform = !images.length && !hasEmpty;
        } else {
            isEmptyTextureUniform = true;
        }

        valCesium.type = ConstantMap.typesMap[val3js.type];
        valCesium.format = ConstantMap.formatsMap[val3js.format];
        valCesium.sampler = sampler;
        valCesium.flipY = val3js.flipY;
        valCesium.preMultiplyAlpha = val3js.premultiplyAlpha;
        valCesium.needsUpdate = true;
        valCesium.isEmptyTextureUniform = isEmptyTextureUniform || !valCesium.value && !valCesium.source;
        valCesium.version = val3js.version;
        valCesium.cacheKey = cacheKey;
        return valCesium;
    }
    else {
        return val3js;
    }
}
/**
* 初始化给定节点树中第一个没有初始化的纹理（map和lightMap），如果已经全部初始化，则返回true
* @param {Cesium.FrameState} frameState 
* @param {THREE.Group|THREE.Scene} content 
* @param {Object} textureCache 
* @param {string[]} textureCache 
* @param {string} [uuidPrefix] 
* @param {number} [maximumTextureSize]
* @param {boolean} [maxMipmapSize=1024]
* @returns {boolean} ready
*/
TextureUtils.initTexture = function (frameState, content, textureCache, textureIds, uuidPrefix, maximumTextureSize, maxMipmapSize) {
    const { WebGLConstants, Sampler } = Cesium;
    const LinearFilter = THREE.LinearFilter;
    let ready = true, textures = [];

    maxMipmapSize = maxMipmapSize || 1024;

    content.traverse(obj => {
        if (!obj.material) return
        let material = obj.material;
        let tex = material.map;

        if (tex) {
            var img = tex.image

            if (img.width >= maxMipmapSize || img.height >= maxMipmapSize) {
                tex.minFilter = LinearFilter;
            }
            if (uuidPrefix && !tex.uuid.startsWith(uuidPrefix)) {
                tex.uuid = uuidPrefix + tex.uuid;
            }

            if (!textureCache[tex.uuid]) textures.push(tex);
            else {
                let texCes = textureCache[tex.uuid]
                texCes.referenceCount = (texCes.referenceCount || 0) + 1;
                // if ((texCes.width > 2048 || texCes.height > 2048) && texCes.referenceCount > 5) {
                //     console.log(texCes.referenceCount);
                // }
            }
        }

        if (material.lightMap && !textureCache[material.lightMap.uuid]) {
            material.lightMap.minFilter = LinearFilter
            material.lightMap.__isLightMap = true;
            textures.push(material.lightMap);
        }

    });

    if (textures.length > 0) {
        let item = {}, tex = textures.shift();

        TextureUtils.fromTexure3js(tex, item);
        let image = item.value;
        let format = WebGLConstants.RGB;

        if (image instanceof HTMLCanvasElement
            || image instanceof HTMLVideoElement
            || (image.src && image.src.toLocaleLowerCase().indexOf(".png") >= 0)
        ) {
            format = WebGLConstants.RGBA;
        }

        var sampler = item.sampler;
        let texture = TextureUtils.createTexture({
            context: frameState.context,
            source: item.source || image,
            // target: WebGLConstants.TEXTURE_2D,
            width: item.width || image.width,
            height: item.height || image.height,
            format: item.format || format,
            flipY: item.flipY,
            type: item.type,
            sampler: new Sampler(sampler),
            preMultiplyAlpha: item.preMultiplyAlpha
        }, frameState.context, tex.__isLightMap ? undefined : maximumTextureSize);

        delete tex.__isLightMap;

        textureCache[tex.uuid] = texture;
        ready = textures.length == 0;

        tex.addEventListener('dispose', () => {
            if (!texture.referenceCount) {
                if (!texture.isDestroyed || !texture.isDestroyed()) texture.destroy()
                delete textureCache[tex.uuid];
            } else {
                texture.referenceCount--;
            }
        });
        if (textureIds) {
            textureIds.push(tex.uuid)
        }
    }

    return ready;
}

/**
 * 
 * @param {THREE.Mesh} mesh  
 * @param {boolean} [forcePowerOfTwo]  
 * @returns {undefined|THREE.Mesh} newMesh
 */
TextureUtils.clampToUV = function (mesh, forcePowerOfTwo) {
    let geometry = mesh.geometry,
        material = mesh.material,
        uv = geometry.getAttribute('uv');
    if (!uv || !material.map || !material.map.image) return;


    let minX = Number.MAX_VALUE, maxX = -Number.MAX_VALUE,
        minY = Number.MAX_VALUE, maxY = -Number.MAX_VALUE;
    for (let i = 0; i < uv.array.length; i += 2) {
        const x = uv.array[i], y = uv.array[i + 1];
        maxX = Math.max(maxX, x);
        minX = Math.min(minX, x);
        maxY = Math.max(maxY, y);
        minY = Math.min(minY, y);
    }

    let _Math = Cesium.Math;
    let deltX = maxX - minX, deltY = maxY - minY;

    if ((deltX < 1 || deltY <= 1)
        && minX >= 0 && _Math.lessThanOrEquals(maxX, 1, _Math.EPSILON2)
        && minY >= 0 && _Math.lessThanOrEquals(maxY, 1, _Math.EPSILON2)) {

        mesh = mesh.clone();
        geometry = geometry.clone();
        material = material.clone();
        mesh.material = material;
        mesh.geometry = geometry;
        uv = uv.clone();
        geometry.setAttribute('uv', uv);

        for (let i = 0; i < uv.array.length; i += 2) {
            let x = uv.array[i], y = uv.array[i + 1];
            x = (x - minX) / deltX;
            y = (y - minY) / deltY;
            uv.array[i] = x;
            uv.array[i + 1] = y;
        }

        let map = material.map.clone(),
            image = map.image;

        map.wrapT = map.wrapS = THREE.ClampToEdgeWrapping;

        map.uuid = THREE.Math.generateUUID();


        let width = Math.ceil(deltX * image.width),
            height = Math.ceil(deltY * image.height),
            x = -Math.floor(minX * image.width),
            y = -Math.floor(minY * image.height);

        if (forcePowerOfTwo
            && (
                !_Math.isPowerOfTwo(width)
                || !_Math.isPowerOfTwo(height)
            )) {
            width = _Math.nextPowerOfTwo(width);
            height = _Math.nextPowerOfTwo(height);
        }

        let cv = document.createElement('canvas');
        cv.width = width;
        cv.height = height;

        let ctx = cv.getContext('2d');
        ctx.drawImage(image, x, y);
        cv.src = image.src;

        map.image = cv;
        material.map = map;
        return mesh;
    }

}

/**
 * 
 * @param {THREE.Texture} texture 
 * @param {number} scaleFactor  0~1
 * @param {boolean} [forcePowerOfTwo]  
 * @returns {THREE.Texture} texture
 */
TextureUtils.resampleTexture = function (texture, scaleFactor, forcePowerOfTwo) {

    const source = texture.image;
    const minFilter = texture.minFilter, { LinearFilter, NearestFilter } = THREE;

    if (!forcePowerOfTwo) {
        forcePowerOfTwo = minFilter != LinearFilter && minFilter != NearestFilter;
    }
    const dstCanvas = this.resampleImage(source, scaleFactor, forcePowerOfTwo)

    texture.width = dstCanvas.width;
    texture.height = dstCanvas.height;
    texture.image = dstCanvas;

    return texture;

}

/**
 * 
 * @param {HTMLImageElement|HTMLCanvasElement} source 
 * @param {number} scaleFactor  0~1
 * @param {boolean} [forcePowerOfTwo]  
 * @returns {HTMLCanvasElement} result
 */
TextureUtils.resampleImage = function (source, scaleFactor, forcePowerOfTwo) {

    const _Math = Cesium.Math;
    const srcWidth = source.width, srcHeight = source.height;
    var width = parseInt(srcWidth * scaleFactor),
        height = parseInt(srcHeight * scaleFactor);

    var dstCanvas
    if (scaleFactor != 1) {
        dstCanvas = this._resampleImage(source, width, height, forcePowerOfTwo); //document.createElement('canvas');
    } else {
        if (forcePowerOfTwo) {
            width = _Math.nextPowerOfTwo(width);
            height = _Math.nextPowerOfTwo(height);
        }
        dstCanvas = document.createElement('canvas');
        dstCanvas.width = width;
        dstCanvas.height = height;
        const destContext = dstCanvas.getContext('2d');
        destContext.drawImage(source, 0, 0, srcWidth, srcHeight, 0, 0, width, height);
    }

    return dstCanvas;

}


/**
 * 
 * @param {HTMLImageElement|HTMLCanvasElement} source 
 * @param {number} dstWidth  
 * @param {number} dstHeight  
 * @param {boolean} [forcePowerOfTwo]  
 * @returns {HTMLCanvasElement} result
 */
TextureUtils._resampleImage = function (source, dstWidth, dstHeight, forcePowerOfTwo) {

    const _Math = Cesium.Math;
    const srcWidth = source.width, srcHeight = source.height;
    var width = dstWidth, height = dstHeight;

    const dstCanvas = document.createElement('canvas');
    if (forcePowerOfTwo) {
        width = _Math.nextPowerOfTwo(width);
        height = _Math.nextPowerOfTwo(height);
    }

    dstCanvas.width = width;
    dstCanvas.height = height;
    const dstContext = dstCanvas.getContext('2d');

    var srcCanvas = source, srcContext;
    if (!(source instanceof HTMLCanvasElement)) {
        srcCanvas = document.createElement('canvas');
        srcCanvas.width = srcWidth
        srcCanvas.height = srcHeight
        srcContext = srcCanvas.getContext('2d')
        srcContext.drawImage(source, 0, 0);

    } else {
        srcContext = srcCanvas.getContext('2d')
    }
    const srcImageData = srcContext.getImageData(0, 0, srcWidth, srcHeight)


    //nearset
    const dstImageData = dstContext.getImageData(0, 0, width, height);
    var dstPtr = 0, scaleX = srcWidth / width, scaleY = srcHeight / height, stride = 4, srcRrow = 0, srcCol = 0, srcPtr = 0;
    for (let i = 0; i < height; i++) {
        for (let j = 0; j < width; j++) {
            srcRrow = parseInt(i * scaleY);
            srcCol = parseInt(j * scaleX);
            srcPtr = stride * (srcRrow * srcWidth + srcCol);
            for (let j = 0; j < stride; j++) {
                dstImageData.data[dstPtr + j] = srcImageData.data[srcPtr + j]
            }
            dstPtr += stride;
        }
    }
    dstContext.putImageData(dstImageData, 0, 0);

    return dstCanvas;

}

/**
 * 
 * @param {Cesium.Texture|Cesium.CubeMapFace} destTexture 
 * @param {object} source
 */
TextureUtils.copyFromCompressData = function (destTexture, source) {

    var size = destTexture._size;
    var pixelFormat = destTexture._pixelFormat;
    var pixelDatatype = destTexture._pixelDatatype;

    var preMultiplyAlpha = destTexture._preMultiplyAlpha;
    var flipY = destTexture._flipY;

    /**
     * @type {WebGLRenderingContext}
     * @private
     */
    var gl = destTexture._gl || destTexture._context._gl;
    var textureTarget = destTexture._textureTarget;
    var texture = destTexture._texture;
    var targetFace = typeof destTexture._targetFace == 'number' ? destTexture._targetFace : textureTarget;

    var width = source.width;
    var height = source.height;
    var arrayBufferView = source.arrayBufferView;

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(textureTarget, texture);

    var unpackAlignment = 4;

    gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

    // Source: typed array
    var arrayBufferView = source.arrayBufferView;
    const { PixelFormat, defined } = Cesium;
    var isCompressed = PixelFormat.isCompressedFormat(pixelFormat);
    if (isCompressed) {
        gl.compressedTexImage2D(
            targetFace,
            0,//level
            pixelFormat,
            width,
            height,
            0,
            arrayBufferView
        );
    } else {
        gl.texImage2D(
            targetFace,
            0,
            pixelFormat,
            width,
            height,
            0,
            pixelFormat,
            pixelDatatype,
            arrayBufferView
        );
    }
    if (defined(source.mipLevels)) {
        var mipWidth = width;
        var mipHeight = height;
        for (var i = 0; i < source.mipLevels.length; ++i) {
            mipWidth = Math.floor(mipWidth / 2) | 0;
            if (mipWidth < 1) {
                mipWidth = 1;
            }
            mipHeight = Math.floor(mipHeight / 2) | 0;
            if (mipHeight < 1) {
                mipHeight = 1;
            }
            if (isCompressed) {
                gl.compressedTexImage2D(
                    targetFace,
                    i + 1,
                    pixelFormat,
                    mipWidth,
                    mipHeight,
                    0,
                    source.mipLevels[i]
                );
            } else {
                gl.texImage2D(
                    targetFace,
                    i + 1,
                    pixelFormat,
                    mipWidth,
                    mipHeight,
                    0,
                    pixelFormat,
                    pixelDatatype,
                    source.mipLevels[i]
                );
            }
        }
    }

    gl.bindTexture(textureTarget, null);
}

export default TextureUtils;

import MeshVisualizer from "../MeshVisualizer.js";

function findGroupOrder(object) {
    if (object.isGroup) {
        return object.renderOrder;
    } else if (!object.parent) {
        return object.renderOrder;
    }
    return findGroupOrder(object.parent);
}

/**
 * 
 * @param {Cesium.DrawCommand} drawCommand 
 * @param {THREE.Material} material 
 * @param {number} materialIndex 
 * @param {THREE.Mesh|THREE.Line|THREE.Points|THREE.Sprite} object
 * @param {THREE.BufferGeometry} geometry 
 * @param {MeshVisualizer}visualizer
 * @param {number} [groupIndex]
 */
function WebGLRenderItem(drawCommand, material, materialIndex, object, geometry, visualizer, groupIndex) {
    const { destroyObject, BoundingSphere, DrawCommand, RenderState } = Cesium;

    drawCommand.derivedProperties = {};

    this.id = object ? object.id : 0;
    this.drawCommand = drawCommand;

    this.material = material || null;
    this.geometry = geometry;
    this.materialIndex = materialIndex;
    this.groupIndex = groupIndex;
    this.object = object || null;
    this.groupOrder = object ? findGroupOrder(object) || 0 : 0;
    this.renderOrder = object ? object.renderOrder || 0 : 0;

    this.visualizer = visualizer;
    this.currentScene = null;
    this.currentCamera = null;

    //runtime state

    this.boundingSphere = new BoundingSphere();//local
    this.boundingVolume = new BoundingSphere();//world

    this.materialVersion = -1;
    this.renderVersion = -1;
    this.programCacheKey = null;
    this.wireframeIndices = null;
    this.frustumCulled = true;
    this.z = -1;
    this.distanceToCamera = -1;
    this.visible = undefined;
    this.loaded = false;
    this.initialized = false;


    function destroyDrawCommand(drawCommand, cesiumRenderStateCache) {

        var va = drawCommand.vertexArray, sp = drawCommand.shaderProgram;
        if (!va.isDestroyed()) va.destroy();
        if (!sp.isDestroyed || !sp.isDestroyed()) {
            sp.destroy();
        }
        drawCommand.isDestroyed = function returnTrue() {
            return true
        };
        drawCommand.uniformMap = undefined;
        drawCommand.renderState = RenderState.removeFromCache(drawCommand.renderState)
        //

        var derivedCommands = drawCommand.derivedCommands;
        if (!derivedCommands) {
            return cesiumRenderStateCache.delete(drawCommand);
        }
        for (const key in derivedCommands) {
            if (derivedCommands.hasOwnProperty(key)) {
                var derivedCommand = derivedCommands[key];
                derivedCommand = derivedCommand.drawCommand || derivedCommand;
                if (!derivedCommand.isDestroyed && derivedCommand instanceof DrawCommand) {
                    derivedCommand.uniformMap = undefined;
                    destroyDrawCommand(derivedCommand, cesiumRenderStateCache)
                }
                derivedCommands[key] = undefined;
            }
        }

        cesiumRenderStateCache.delete(drawCommand);

    }

    this.destroy = function () {

        const renderer = visualizer.renderer;
        renderer._cesiumRenderStateCache.delete(drawCommand);
        destroyDrawCommand(drawCommand, renderer._cesiumRenderStateCache)

        destroyObject(drawCommand);
        for (const key in this) {
            this[key] = null;
        }
    }
}

Object.defineProperties(WebGLRenderItem.prototype, {
    pass: {
        get() {
            return this.drawCommand._v_pass
        }
    },
    renderPass: {
        get() {
            return this.drawCommand.pass;
        }
    },
    modelMatrix: {
        get() {
            return this.drawCommand.modelMatrix
        }
    }
})

WebGLRenderItem.prototype.update = function (object, drawCommand, geometry, modelMatrixNeedsUpdate) {

    const _Cesium = Cesium;
    const renderItem = this;
    const boundingVolume = renderItem.boundingVolume;
    const { isInstancedMesh, frustumCulled, modelMatrix } = object;

    //instanceCount
    if (isInstancedMesh) {
        drawCommand.instanceCount = object.count;
    } else if (isFinite(geometry.instanceCount)) {
        drawCommand.instanceCount = geometry.instanceCount;
    }

    if (drawCommand.instanceCount) {
        renderItem.frustumCulled = false;
    } else {
        renderItem.frustumCulled = frustumCulled;
    }

    if (object.isCustomInstancedMesh) {

        drawCommand.instanceCount = object._availableInstances.length;

        if (frustumCulled) _Cesium.BoundingSphere.clone(object._boundingSphere, boundingVolume);

    }
    else if (modelMatrixNeedsUpdate || object.modelMatrixNeedsUpdate || !renderItem.initialized) {

        const boundingSphere = this.boundingSphere;
        const Matrix4 = _Cesium.Matrix4;

        Matrix4.multiplyByPoint(modelMatrix, boundingSphere.center, boundingVolume.center);
        boundingVolume.radius = boundingSphere.radius * Matrix4.getMaximumScale(modelMatrix)

        renderItem.initialized = true;

    }

    drawCommand.boundingVolume = frustumCulled ? boundingVolume : undefined;
    drawCommand.modelMatrix = modelMatrix;

}

export default WebGLRenderItem;
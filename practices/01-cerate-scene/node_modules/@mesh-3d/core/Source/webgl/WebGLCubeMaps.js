
function WebGLCubeMaps(renderer) {
	if (typeof THREE == 'undefined') {
		return {
			get(texture) {
				return texture;
			},
			dispose() { }
		}
	}

	let { CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping, WebGLCubeRenderTarget } = THREE;

	let cubemaps = new WeakMap();

	function mapTextureMapping(texture, mapping) {

		if (mapping === EquirectangularReflectionMapping) {

			texture.mapping = CubeReflectionMapping;

		} else if (mapping === EquirectangularRefractionMapping) {

			texture.mapping = CubeRefractionMapping;

		}

		return texture;

	}

	function get(texture) {

		if (texture && texture.isTexture) {

			const mapping = texture.mapping;

			if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {

				if (cubemaps.has(texture)) {

					const cubemap = cubemaps.get(texture).texture;
					return mapTextureMapping(cubemap, texture.mapping);

				} else {

					const image = texture.image;

					if (image && image.height > 0) {

						// const currentRenderList = renderer.getRenderList();
						const currentRenderTarget = renderer.getRenderTarget();
						const currentRenderState = renderer.renderState//getRenderState();
						const currentAutoConvertCamera = renderer.autoConvertCamera;

						const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
						renderer.autoConvertCamera = true;

						renderTarget.fromEquirectangularTexture(renderer, texture);
						cubemaps.set(texture, renderTarget);

						renderer.autoConvertCamera = currentAutoConvertCamera;
						renderer.setRenderTarget(currentRenderTarget);
						// renderer.setRenderList(currentRenderList); 
						renderer.renderState = currentRenderState;// renderer.setRenderState(currentRenderState);

						texture.addEventListener('dispose', onTextureDispose);

						return mapTextureMapping(renderTarget.texture, texture.mapping);

					} else {

						// image not yet ready. try the conversion next frame

						return null;

					}

				}

			}

		}

		return texture;

	}

	function onTextureDispose(event) {

		const texture = event.target;

		texture.removeEventListener('dispose', onTextureDispose);

		const cubemap = cubemaps.get(texture);

		if (cubemap !== undefined) {

			cubemaps.delete(texture);
			cubemap.dispose();

		}

	}

	function dispose() {

		cubemaps = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

export default WebGLCubeMaps;

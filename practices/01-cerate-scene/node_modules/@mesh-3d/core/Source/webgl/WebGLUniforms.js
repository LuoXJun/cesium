import MeshVisualizer from "../MeshVisualizer.js";
import WebGLLights from "./WebGLLights.js";
import WebGLRenderer from "./WebGLRenderer.js";

function getModifiedModelViewCallback(context, object) {
    var Matrix4 = Matrix4;
    return function () {
        if (!object._rtcTransform) {
            object._rtcTransform = new Matrix4()
        }
        if (!object._rtcModelView) {
            object._rtcModelView = new Matrix4()
        }
        Matrix4.multiplyByTranslation(object.modelMatrix, object._center, object._rtcTransform);

        return Matrix4.multiply(context.uniformState.view, object._rtcTransform, object._rtcModelView);
    }
}

/**
 * 
 * @param {WebGLRenderer} renderer 
 */
function WebGLUniforms(renderer) {

    const { OrthographicFrustum, Texture, Matrix4, Matrix3, Matrix2, Color, Cartesian2, Cartesian3, Cartesian4 } = Cesium;

    /**
     * @type {MeshVisualizer}
     * @private
     */
    const visualizer = renderer._visualizer;
    const textures = renderer._textures;
    const materials = renderer._materials;
    const properties = renderer._properties;

    var capabilities = renderer._capabilities;
    var extensions = renderer._extensions;

    const uniformCache = new WeakMap();

    Object.defineProperties(this, {
        uniforms: {
            get() {
                return uniformCache;
            }
        }
    });

    const _THREE = THREE, { DataTexture, UniformsLib,MathUtils } = _THREE;
    var rectAreaLTC1, rectAreaLTC2;

    //

    function getStructUniformCallback(valObj, name) {
        return function structPropertyUniformCallback() {
            return valObj[name];
        }
    }
    function setStructureUniform(name, val, uniformMap) {
        for (var key in val) {
            if (val.hasOwnProperty(key)) {
                var uniformName = name + "." + key;
                uniformMap[uniformName] = getStructUniformCallback(val, key);
            }
        }
    }
    function isPrimitiveTypeUniform(val) {
        var type = typeof val
        if (type == 'undefined' || val == null) return false;

        return (type == 'number'
            || type == 'boolean'
            || val instanceof Color
            || val instanceof Cartesian2
            || val instanceof Cartesian3
            || val instanceof Cartesian4
            || val instanceof Matrix2
            || val instanceof Matrix3
            || val instanceof Matrix4
            || val instanceof Texture
            || val.isColor
            || val.isVector2
            || val.isVector3
            || val.isVector4
            || val.isCartesian2
            || val.isCartesian3
            || val.isCartesian4
            || val.isMatrix2
            || val.isMatrix3
            || val.isMatrix4
        );
    }
    function isStructureArrayUniform(vals) {
        if (!Array.isArray(vals) || !vals.length) return false;

        var el0 = vals[0];
        if (isPrimitiveTypeUniform(el0)) {
            return false;
        }

        return true;
    }

    function setArrayUniform(name, vals, uniformMap) {

        if (!isStructureArrayUniform(vals)) {
            uniformMap[name] = function () {
                return vals;
            }
        }
        else {
            for (var i = 0; i < vals.length; i++) {
                var val = vals[i];
                var thisName = name + "[" + i + "]";
                if (isStructureArrayUniform(val)) {
                    setArrayUniform(thisName, val, uniformMap);
                } else {
                    setStructureUniform(thisName, val, uniformMap);
                }
            }
        }
    }

    /////

    //

    var cameraPositionLC = new Cartesian3();
    function setBuiltinUniforms(material, object, frameState, uniformMap) {

        var pickId = object.pickId, pickIds = object.pickIds;
        if (pickIds) {
            let objectMaterial = object.material;
            var materialIndex = Array.isArray(objectMaterial) ? objectMaterial.indexOf(material) : 0;
            if (materialIndex != -1) {
                pickId = pickIds[materialIndex] || pickId
            }
        }
        uniformMap.czm_pickColor = function () {
            return pickId.color;
        }

        uniformMap.cameraPosition = function () {
            var customCamera = frameState.camera.customCamera;
            if (customCamera && customCamera.cameraPosition) {
                return customCamera.cameraPosition;
            }
            return frameState.camera.position;
        }
        uniformMap.u_cameraPosition = uniformMap.cameraPosition;

        uniformMap.cameraPositionLC = function () {
            var camera = frameState.camera
            var customCamera = camera.customCamera;
            if (customCamera && customCamera.cameraPosition) {
                return customCamera.cameraPosition;
            }
            visualizer.worldCoordinatesToLocal(camera.position, cameraPositionLC, object.up);
            return cameraPositionLC;
        }
        uniformMap.u_cameraPositionLC = uniformMap.cameraPositionLC

        //base matrix
        uniformMap.normalMatrix = function () {
            var customCamera = frameState.camera.customCamera;
            if (customCamera && customCamera.normalMatrix) {
                return customCamera.normalMatrix;
            }
            return frameState.context.uniformState.normal;
        }
        uniformMap.u_normalMatrix = uniformMap.normalMatrix;
        uniformMap.projectionMatrix = function () {
            var customCamera = frameState.camera.customCamera;
            if (customCamera && customCamera.projectionMatrix) {
                return customCamera.projectionMatrix;
            }
            return frameState.context.uniformState.projection;
        }
        uniformMap.u_projectionMatrix = uniformMap.projectionMatrix;
        uniformMap.modelViewMatrix = function () {
            var customCamera = frameState.camera.customCamera;
            if (customCamera && customCamera.modelViewMatrix) {
                return customCamera.modelViewMatrix;
            }

            return frameState.context.uniformState.modelView;
        }
        uniformMap.u_modelViewMatrix = uniformMap.modelViewMatrix;

        var modelViewMatrixInverse = new Matrix4();
        uniformMap.modelViewMatrixInverse = function () {
            var mv = frameState.context.uniformState.modelView;
            return Matrix4.inverse(mv, modelViewMatrixInverse);
        }

        //
        uniformMap.modelMatrix = function () {
            var customCamera = frameState.camera.customCamera;
            if (customCamera && customCamera.modelMatrix) {
                return customCamera.modelMatrix;
            }

            return frameState.context.uniformState.model;
        }
        uniformMap.u_modelMatrix = uniformMap.modelMatrix;

        //
        var matrixWorld = new Matrix4()
        uniformMap.matrixWorld = function () {
            var cesiumModel2ThreeModel = uniformMap._CesiumModel2ThreeModel()
            return Matrix4.multiply(cesiumModel2ThreeModel, frameState.context.uniformState.model, matrixWorld)
        }
        //
        var normalMatrixWorld = new Matrix3()
        uniformMap.normalMatrixWorld = function () {
            var CesiumNormal2ThreeNormal = uniformMap._CesiumNormal2ThreeNormal()
            return Matrix3.multiply(CesiumNormal2ThreeNormal, frameState.context.uniformState.normal, normalMatrixWorld)
        }

        //
        var yup = object.up.y == 1;
        uniformMap._CesiumModel2ThreeModel = function () {

            if (yup) {
                return visualizer._actualModelMatrixYupInverse
            } else {
                return visualizer._actualModelMatrixInverse;
            }
        }
        uniformMap._ThreeModel2CesiumModel = function () {

            if (yup) {
                return visualizer._actualModelMatrixYup;

            } else {
                return visualizer._actualModelMatrix;
            }
        }

        var _CesiumNormal2ThreeNormal = new Matrix3();
        uniformMap._CesiumNormal2ThreeNormal = function () {

            if (yup) {
                return Matrix4.getMatrix3(visualizer._actualModelMatrixYupInverse, _CesiumNormal2ThreeNormal)

            } else {
                return Matrix4.getMatrix3(visualizer._actualModelMatrixInverse, _CesiumNormal2ThreeNormal)
            }
        }

        var _ThreeNormal2CesiumNormal = new Matrix3();
        uniformMap._ThreeNormal2CesiumNormal = function () {
            var up = object.up;
            if (up.y == 1) {
                return Matrix4.getMatrix3(that._actualModelMatrixYup, _ThreeNormal2CesiumNormal)

            } else {
                return Matrix4.getMatrix3(that._actualModelMatrix, _ThreeNormal2CesiumNormal)
            }
        }

        //

        uniformMap.viewMatrix = function () {
            return frameState.context.uniformState.view;
        }
        uniformMap.u_viewMatrix = uniformMap.viewMatrix
        uniformMap.logDepthBufFC = function () {
            return 2.0 / (Math.log(frameState.camera.frustum.far + 1.0) / Math.LN2)
        }

        //

        uniformMap.isOrthographic = function () {
            var camera = frameState.camera
            var isOrthographic = camera.isOrthographicCamera == true;
            return isOrthographic;
        }

        uniformMap.toneMappingExposure = function () {
            return renderer.toneMappingExposure
        }
        uniformMap.toneMappingWhitePoint = function () {
            return renderer.toneMappingWhitePoint
        }

        uniformMap.receiveShadow = function () {
            return object.receiveShadow == true
        }
        uniformMap.center = function () {
            return !!object.center;
        }

        if (material.uniformStateUsed && material.uniformStateUsed.length) {
            material.uniformStateUsed.forEach(function (item) {
                if (!uniformMap[item.glslVarName]) {
                    if (!frameState.context.uniformState[item.uniformStateName]) {
                        throw new Error(item.uniformStateName + "不是Cesium引擎的内置对象");
                    }
                    uniformMap[item.glslVarName] = function () {
                        return frameState.context.uniformState[item.uniformStateName];
                    }
                }
            });
        }
    }

    //

    function setLightsUniforms(material3js, object3js, frameState, uniformMap, uniforms, lights) {

        if (properties.get(material3js).needsLights) {

            var _lights = lights.state;

            var lightUniforms = {};
            lightUniforms.lightProbe = { value: _lights.probe };
            lightUniforms.directionalLights = { value: _lights.directional };
            lightUniforms.directionalLightShadows = { value: _lights.directionalShadow }
            lightUniforms.spotLights = { value: _lights.spot }
            lightUniforms.spotLightShadows = { value: _lights.spotShadow }
            lightUniforms.rectAreaLights = { value: _lights.rectArea }
            lightUniforms.pointLights = { value: _lights.point }
            lightUniforms.pointLightShadows = { value: _lights.pointShadow }
            lightUniforms.hemisphereLights = { value: _lights.hemi }

            function getShadowMapCallback(shadowMapName) {
                return function () {
                    let textureArr = _lights[shadowMapName].map(texture3js => {
                        if (texture3js) return textures.get(texture3js);
                        else return visualizer.defaultShadowMap;
                    });
                    return textureArr
                }
            }

            uniformMap.directionalShadowMap = getShadowMapCallback('directionalShadowMap');
            uniformMap.directionalShadowMatrix = function () { return _lights.directionalShadowMatrix }
            uniformMap.spotShadowMap = getShadowMapCallback('spotShadowMap');
            uniformMap.spotShadowMatrix = function () { return _lights.spotShadowMatrix }
            uniformMap.pointShadowMap = getShadowMapCallback('pointShadowMap');
            uniformMap.pointShadowMatrix = function () { return _lights.pointShadowMatrix }

            setCommonUniforms(lightUniforms, frameState, uniformMap);

            if (uniforms.ambientLightColor) {
                if (material3js.lightMap) {
                    uniformMap.ambientLightColor = function ambientLightColorCallback() {
                        return Color.BLACK
                    }
                }
                else {
                    uniformMap.ambientLightColor = function ambientLightColorCallback() {
                        return _lights.ambient;
                    }
                }
            }

            uniformMap.ltc_1 = function () {
                var texture = textures.get(rectAreaLTC1, frameState)
                return texture || visualizer.defaultTexture
            }
            uniformMap.ltc_2 = function () {
                var texture = textures.get(rectAreaLTC2, frameState)
                return texture || visualizer.defaultTexture
            }

            //extension:point lights

            var fixedWebGLLights = visualizer._fixedWebGLLights.extensionState;
            var partialWebGLLights = visualizer._partialWebGLLights.extensionState;

            // if (capabilities.floatFragmentTextures) {
            uniformMap.fixedPointLightMap = function () {
                return fixedWebGLLights.point.map
            }
            uniformMap.partialPointLightMap = function () {
                return partialWebGLLights.point.map
            }
            // } else {
            uniformMap.fixedPointLightPositions = function () {
                return fixedWebGLLights.point.positions;
            }
            uniformMap.fixedPointLightColors = function () {
                return fixedWebGLLights.point.colors;
            }
            uniformMap.fixedPointLightDecayDists = function () {
                return fixedWebGLLights.point.decalDists;
            }
            //
            uniformMap.partialPointLightPositions = function () {
                return partialWebGLLights.point.positions;
            }
            uniformMap.partialPointLightColors = function () {
                return partialWebGLLights.point.colors;
            }
            uniformMap.partialPointLightDecayDists = function () {
                return partialWebGLLights.point.decalDists;
            }
            uniformMap.partialPointLightDecayDists = function () {
                return partialWebGLLights.point.decalDists;
            }
            // }
            uniformMap.fixedPointLightVisibles = function () {
                return fixedWebGLLights.point.visibles
            }
            uniformMap.partialPointLightVisibles = function () {
                return partialWebGLLights.point.visibles
            }

        }

    }

    //

    function setClippingUniforms(material3js, object3js, frameState, uniformMap) {
        if ((!material3js.isShaderMaterial && !material3js.isRawShaderMaterial) || material3js.clipping === true) {

            // materialProperties.numClippingPlanes = clipping.numPlanes;
            // materialProperties.numIntersection = clipping.numIntersection;
            // material.uniforms.clippingPlanes = that.renderer._clipping.uniform;

            var clippingUniform = properties.get(material3js).clippingUniform;

            uniformMap.clippingPlanes = function () {
                if (clippingUniform) return clippingUniform.value
                else return [];

            }

        }
    }

    //

    /**
     * 
     * @param {*} material3js 
     * @param {THREE.SkinnedMesh|THREE.Mesh|THREE.Points|THREE.Line} object3js 
     * @param {*} frameState 
     * @param {*} uniformMap 
     */
    function setSkinningUniforms(material3js, object3js, frameState, uniformMap) {

        if (material3js && (material3js.skinning || object3js.isSkinnedMesh)) {

            // skinning uniforms must be set even if material didn't change
            // auto-setting of texture unit for bone texture must go before other textures
            // not sure why, but otherwise weird things happen

            var object = object3js;

            uniformMap.bindMatrix = function () {
                return object.bindMatrix.elements;
            }
            uniformMap.bindMatrixInverse = function () {
                return object.bindMatrixInverse.elements;
            }

            // p_uniforms.setOptional(_gl, object, 'bindMatrix');
            // p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');

            var skeleton = object.skeleton;

            if (skeleton) {

                var bones = skeleton.bones;

                if (capabilities.floatVertexTextures) {

                    var boneTextureCesium = skeleton.boneTextureCesium,
                        boneTexture = skeleton.boneTexture;

                    if (boneTexture === undefined//threejs<1.3
                        || boneTexture === null
                    ) {

                        if (skeleton.computeBoneTexture) {
                            skeleton.computeBoneTexture()
                            boneTexture = skeleton.boneTexture;
                        } else {
                            // layout (1 matrix = 4 pixels)
                            //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
                            //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
                            //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
                            //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
                            //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


                            var size = Math.sqrt(bones.length * 4); // 4 pixels needed for 1 matrix
                            size =  MathUtils.ceilPowerOfTwo(size);
                            size = Math.max(size, 4);

                            var boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
                            boneMatrices.set(skeleton.boneMatrices); // copy current values

                            boneTexture = new DataTexture(boneMatrices, size, size, _THREE.RGBAFormat, _THREE.FloatType);

                            skeleton.boneMatrices = boneMatrices;
                            skeleton.boneTexture = boneTexture;
                            skeleton.boneTextureSize = size;
                        }

                        boneTextureCesium = textures.get(skeleton.boneTexture, frameState);// TextureUtils.fromTexure3js(skeleton.boneTexture);
                        boneTextureCesium.name = 'boneTexture';
                        skeleton.boneTextureCesium = boneTextureCesium;
                    }

                    uniformMap.boneTexture = function () {

                        if (boneTextureCesium.version != boneTexture.version) {
                            //update 

                            var source = boneTexture.image
                            source.arrayBufferView = source.data;
                            try {
                                boneTextureCesium.copyFrom({ source })
                            } catch (err) {
                                boneTextureCesium.copyFrom(source)
                            }

                            boneTextureCesium.version = boneTexture.version;
                        } else {
                            boneTextureCesium.version = boneTexture.version;
                        }

                        return boneTextureCesium;
                    }
                    uniformMap.boneTextureSize = function () {
                        return skeleton.boneTextureSize;
                    }
                    // p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
                    // p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);

                } else {

                    // p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
                    uniformMap.boneMatrices = function () {
                        return skeleton.boneMatrices.elements;
                    }
                }

            }
        }
    }

    //

    function setMorphTargetsUniforms(material, object, uniformMap) {

        if (material && (material.morphTargets || material.morphNormals)) {

            // program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
            // program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );
            var morpTargethUniforms = renderer.morphtargets.getUniforms(object)
            uniformMap.morphTargetBaseInfluence = function () {
                return morpTargethUniforms.morphTargetBaseInfluence;
                // return object.geometry._morphBaseInfluence
            }
            uniformMap.morphTargetInfluences = function () {
                return morpTargethUniforms.morphTargetInfluences;
                // return object.geometry._morphInfluences
            }
        }
    }

    //

    function getCommonUniformCallback(uniformName, uniform, frameState) {

        var uniformVal = uniform.value;
        var typeOfVal = typeof uniformVal;

        if (uniform.type == 'f') {
            return function floatUniformCallbak() {
                return uniform.value || 0;
            }
        }
        else if (typeOfVal == 'number' || typeOfVal == 'boolean') {

            return function boolOrNumUniformCallbak() {
                return uniform.value;
            }

        }
        else if (!uniformVal) {

            var defaultVal = uniformName == 'envMap' ? visualizer.defaultCubeMap : visualizer.defaultTexture;

            return function nullOrTextureUniformCallback() {

                var texture3js = uniform.value;
                if (texture3js) {
                    var texture = textures.get(texture3js, frameState, defaultVal)
                    return texture;
                }
                else {
                    return defaultVal;
                }

            }

        } else if (uniformVal.isTexture) {
            var defaultVal = uniformName == 'envMap' ? visualizer.defaultCubeMap : visualizer.defaultTexture;

            return function textureUniformCallback() {

                var texture = textures.get(uniform.value, frameState, defaultVal)
                return texture;

            }
        }
        else if (uniformVal.isVector2 | uniformVal.isVector3 | uniformVal.isVector4 | uniformVal.isColor) {

            return function vecUniformCallbak() {
                return uniform.value;
            }

        } else if (uniformVal.isMatrix2 | uniformVal.isMatrix3 | uniformVal.isMatrix4) {

            return function matrixUniformCallbak() {
                return uniform.value.elements;
            }

        }
        else if (Array.isArray(uniformVal)) {

            if (!uniformVal.length) return;

            if (isPrimitiveTypeUniform(uniformVal[0])) {
                return function arrayUniformCallback() {
                    return uniform.value;
                }
            }
        }
        else {
            debugger
        }

    }

    function setCommonUniforms(uniforms, frameState, uniformMap) {

        for (const name in uniforms) {
            var uniform = uniforms[name];
            if (uniforms.hasOwnProperty(name) && uniform) {

                var uniformVal = uniform.value;

                var callback = getCommonUniformCallback(name, uniform, frameState)
                if (callback) {
                    uniformMap[name] = callback;

                } else if (isStructureArrayUniform(uniformVal)) {

                    setArrayUniform(name, uniformVal, uniformMap);

                } else {

                    setStructureUniform(name, uniformVal, uniformMap)
                }

            }
        }

        if (uniforms.datetime) {
            uniformMap.datetime = function () {
                return performance.now()
            }
        }

    }

    /**
     * 
     * @param {THREE.Material} material3js 
     * @param {THREE.Mesh} object3js 
     * @param {Cesium.FrameState} frameState 
     * @param {WebGLLights}lights
     * @return {{[key:string]:()=>Cesium.Texture|Cesium.CubeMap|boolean|number|{x:number,y:number,z?:number,w:number}|number[]|{red:number,green:number,blue:number:alpha:number}}}
     */
    this.getUniformMap = function (material3js, object3js, frameState, lights) {

        var uniformMap = {}
        var context = frameState.context;
        var uniformsSet = uniformCache.get(material3js);
        if (!uniformsSet || !uniformsSet.has(object3js)) return uniformMap;

        var uniforms = uniformsSet.get(object3js);

        setCommonUniforms(uniforms, frameState, uniformMap);
        setBuiltinUniforms(material3js, object3js, frameState, uniformMap)
        setLightsUniforms(material3js, object3js, frameState, uniformMap, uniforms, lights)
        setClippingUniforms(material3js, object3js, frameState, uniformMap)
        setMorphTargetsUniforms(material3js, object3js, uniformMap);
        setSkinningUniforms(material3js, object3js, frameState, uniformMap);

        if (object3js._instances) {
            uniformMap.czm_instanced_modifiedModelView = getModifiedModelViewCallback(context, object3js);
        }

        if (object3js.uniformMapLoadedCallback) {
            object3js.uniformMapLoadedCallback(uniformMap, frameState, object3js);
        }

        return uniformMap;
    }

    /**
     * 
     * @param {*} material3js 
     * @param {*} uniforms 
     * @param {*} object 
     * @private
     */
    this.set = function (material3js, uniforms, object) {

        if (!capabilities) capabilities = renderer.capabilities;
        if (!extensions) extensions = renderer.extensions;

        var uniformsSet = uniformCache.get(material3js);
        if (!uniformsSet) {
            uniformsSet = new WeakMap();
            uniformsSet.useTimes = 0;
            uniformCache.set(material3js, uniformsSet);
        }
        uniformsSet.useTimes++;

        var oldUniforms = uniformsSet.get(object);
        if (oldUniforms) {
            oldUniforms.materialDisposeCallback();
        }

        function onMaterialDispose() {
            uniformsSet.delete(object);
            if (material3js._isShadowDepthMaterial) {
                object.removeEventListener('dispose', onMaterialDispose)
            } else {
                material3js.removeEventListener('dispose', onMaterialDispose);
            }
            uniformsSet.useTimes--;

            if (uniformsSet.useTimes == 0) {
                uniformCache.delete(material3js);
            }


            //remove texture reference
            for (const key in uniforms) {
                const uniform = uniforms[key];
                if (uniforms.hasOwnProperty(key) && uniform) {
                    var uniformVal = uniform.value;
                    if (uniformVal && uniformVal.isTexture) {
                        textures.removeReference(uniformVal)
                    }
                }
            }

        }

        uniforms.materialDisposeCallback = onMaterialDispose;
        if (material3js._isShadowDepthMaterial) {
            object.addEventListener('dispose', onMaterialDispose)
        } else {
            material3js.addEventListener('dispose', onMaterialDispose);
        }

        uniformsSet.set(object, uniforms);

        this.refresh(material3js, object);

        //add texture reference
        for (const key in uniforms) {
            const uniform = uniforms[key];
            if (uniforms.hasOwnProperty(key) && uniform) {
                var uniformVal = uniform.value;
                if (uniformVal && uniformVal.isTexture) {
                    textures.addReference(uniformVal)
                }
            }
        }

        //reactLights

        if (capabilities.isWebGL2) {

            // WebGL 2

            rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
            rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

        } else {

            // WebGL 1

            if (extensions.has('OES_texture_float_linear') === true) {

                rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
                rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

            } else if (extensions.has('OES_texture_half_float_linear') === true) {

                rectAreaLTC1 = UniformsLib.LTC_HALF_1;
                rectAreaLTC2 = UniformsLib.LTC_HALF_2;

            } else {

                console.error('WebGLUniforms: Unable to use RectAreaLight. Missing WebGL extensions.');

            }

        }
    }

    /**
     * 
     * @param {THREE.Material} material3js 
     * @param {THREE.Mesh} object 
     * @param {object} [uniforms] 
     */
    this.refresh = function (material3js, object, uniforms) {

        if (!uniforms) {
            var uniformsSet = uniformCache.get(material3js);
            // if (!uniformsSet || !uniformsSet.has(object)) return;
            uniforms = uniformsSet.get(object);
            //>>includeStart('debug')
            // if (!uniforms) {
            //     debugger
            // }
            //>>includeEnd('debug')
        }
        if (!uniforms) {
            return
        }

        //
        if (uniforms.version == material3js.version) {
            if (material3js.autoRefresh == false) return;
        }

        if (visualizer.fog && uniforms.fogColor) {
            materials.refreshFogUniforms(uniforms, visualizer.fog)
        }

        var height = capabilities.gl.canvas.height;
        var pixelRatio = renderer._pixelRatio;

        materials.refreshMaterialUniforms(uniforms, material3js, pixelRatio, height);

        uniforms.version = material3js.version
    }

}

export default WebGLUniforms;
import GeometryUtils from "../GeometryUtils.js";
import WebGLGeometries from "./WebGLGeometries.js";
import WebGLProperties from "./WebGLProperties.js";
import WebGLRenderer from "./WebGLRenderer.js";
import WebGLRenderItem from "./WebGLRenderItem.js";
import WebGLRenderState from "./WebGLRenderState.js";
const { computeBoundingSphereAndIndices } = GeometryUtils;

function MaterialProperties() {
    this.fog = null;
    this.environment = null
    this.lightsStateVersion = 0;
    this.numClippingPlanes = 0
    this.numIntersection = 0
    this.clippingUniform = { value: [] }
    this.clippingState = []
    this.outputEncoding = -1;
    this.envMap = null;
    this.version = 0;
    this.renderVersion = 0;
    this.wireframe = false;
}

/**
 * 
 * @param {WebGLRenderer} renderer 
 */
function WebGLRenderItems(renderer) {

    const { DrawCommand, Cartesian4 } = Cesium;

    const visualizer = renderer._visualizer;
    const uniforms = renderer._uniforms;
    const properties = renderer._properties;
    const cubemaps = renderer._cubemaps;
    const cesiumRenderStates = renderer._cesiumRenderStates;
    const cesiumCommands = renderer._cesiumCommands;
    const cesiumShaderPrograms = renderer._cesiumShaderPrograms
    const cesiumVertextArrays = renderer._cesiumVertextArrays

    var objectDrawAttributes = new WebGLProperties();
    var renderItemsCache = new WeakMap();
    var materialsUsed = new WeakMap();

    //
    var changingState = {
        frameNumber: -1,
        changingCount: 0,
        maxChangingCount: visualizer.maxChangingCount
    }

    Object.defineProperties(this, {
        changingState: {
            get() {
                return changingState;
            }
        },
        objectDrawAttributes: {
            get() {
                return objectDrawAttributes;
            }
        },
        renderItemsCache: {
            get() {
                return renderItemsCache;
            }
        },
        materialsUsed: {
            get() {
                return materialsUsed;
            }
        }
    })

    //

    function dispose() {

        objectDrawAttributes = new WebGLProperties();
        renderItemsCache = new WeakMap();
        materialsUsed = new WeakMap();
    }

    /**
     * 
     * @param {THREE.Mesh|THREE.Line|THREE.Points|THREE.Sprite} object 
     * @param {THREE.Material} objectMaterial 
     * @param {WebGLRenderItem[]} renderItems 
     */
    function set(object, objectMaterial, renderItems) {

        var commandsSet = renderItemsCache.get(object);
        var materialSet = materialsUsed.get(object);
        if (!commandsSet) {
            commandsSet = new WeakMap();
            materialSet = [];
            renderItemsCache.set(object, commandsSet);
            materialsUsed.set(object, materialSet);
        }

        commandsSet.useTimes = commandsSet.useTimes || 0;

        function onObjectMaterialDispose() {

            commandsSet.delete(objectMaterial);
            commandsSet.useTimes--;
            if (commandsSet.useTimes == 0) {
                renderItemsCache.delete(object);
                materialsUsed.delete(object);
            }
        }

        renderItems.forEach(function (renderItem) {
            const material = renderItem.material;

            function onSubMaterialDispose() {

                renderItem.destroy();

                var itemIndex = renderItems.indexOf(renderItem)
                if (itemIndex >= 0) renderItems.splice(itemIndex, 1);

                if (renderItems.length == 0) onObjectMaterialDispose();

                material.removeEventListener('dispose', onSubMaterialDispose);
            }
            material.addEventListener('dispose', onSubMaterialDispose);
        })

        commandsSet.useTimes++;

        commandsSet.set(objectMaterial, renderItems);
        materialSet.push(objectMaterial);
    }

    function updateSkinningAndMorphTargets(object, geometry, material, frameState) {
        //skinning
        const objectProperties = properties.get(object);
        if (object.isSkinnedMesh && objectProperties.skinningFrameNumber != frameState.frameNumber) {
            objectProperties.skinningFrameNumber = frameState.frameNumber;
            const skeleton = object.skeleton;
            skeleton.update();
            if (skeleton.boneTextureCesium) {
                skeleton.boneTextureCesium.needsUpdate = true;
            }
        }
        //morph
        if (object.material.morphTargets || object.material.morphNormals) {
            if (objectProperties.morphtargetFrameNumber != frameState.frameNumber) {//避免同一帧反复计算morph参数
                objectProperties.morphtargetFrameNumber = frameState.frameNumber;
                renderer.morphtargets.update(object, geometry, material);
            }
        }
    }

    //

    function materialNeedsLights(material) {

        return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
            material.isMeshStandardMaterial || material.isShadowMaterial ||
            (material.isShaderMaterial && material.lights === true);

    }

    function initMaterial(material, wireframe, lights, shadows, firstTime) {

        const clipping = renderer._clipping;
        const currentRenderTarget = renderer.getRenderTarget();
        const fog = visualizer.fog;
        const environment = material.isMeshStandardMaterial ? visualizer.environment : null;
        const encoding = (currentRenderTarget === null) ? renderer.outputEncoding : currentRenderTarget.texture.encoding;
        const envMap = cubemaps.get(material.envMap || environment);

        //initMaterial
        var materialProperties = properties.get(material, firstTime ? new MaterialProperties() : undefined);

        materialProperties.needsLights = materialNeedsLights(material);
        materialProperties.fog = fog;
        materialProperties.environment = environment
        materialProperties.lightsStateVersion = lights.state.version
        materialProperties.numClippingPlanes = clipping.numPlanes
        materialProperties.numIntersection = clipping.numIntersection
        materialProperties.outputEncoding = encoding
        materialProperties.envMap = envMap;
        materialProperties.shadows = shadows.length;
        materialProperties.wireframe = wireframe;
        materialProperties.version = material.version;
        materialProperties.shadowMapType = renderer.shadowMap.type;
        materialProperties.rendererVersion = renderer.version;
    }

    //
 
    /**
     * 创建`pickId`或者`pickIds`，用于实现点击拾取对象功能
     * * `pickId` —— 根据对象的`pickObject`创建，允许对象作为一个独立的整体被点击拾取；
     * * `pickIds` —— 根据对象的`pickObjects`数组创建，允许将对象按材质拆分成多个子部件分别被场景点击拾取，同一次点击只能拾取到一个子部件。
     * @private
     */
     function initPickObject(object, context) {
        let pickObjects = object.pickObjects, objectMaterial = object.material;

        if (!object.pickObject && !pickObjects && Array.isArray(objectMaterial)) {
            var materials = objectMaterial;
            pickObjects = [];
            for (let materialIndex = 0; materialIndex < materials.length; materialIndex++) {
                const material = materials[materialIndex];
                pickObjects.push({
                    primitive: visualizer,
                    id: object,
                    mesh: object,
                    material: material,
                    materialIndex: materialIndex
                })
            }
            object.pickObjects = pickObjects;
        }

        if (pickObjects && pickObjects.length) {

            let pickIds = []
            for (let i = 0; i < pickObjects.length; i++) {
                const pickObject = pickObjects[i];
                var pickId = pickObject.pickId;
                if (pickId == undefined) {
                    pickId = context.createPickId(pickObject);
                }

                const globalPickIds = visualizer._pickIds;
                if (!globalPickIds.includes(pickId)) {
                    globalPickIds.push(pickId);
                }

                pickObject.pickId = pickId;
                pickIds.push(pickId);
            }
            object.pickIds = pickIds;

        } else {
            var pickObject = object.pickObject ? object.pickObject : {
                primitive: visualizer,
                id: object,
                mesh: object
            };
            object.pickObject = pickObject;

            var pickId = pickObject.pickId;
            if (pickId == undefined) {
                pickId = context.createPickId(pickObject);
            }

            const pickIds = visualizer._pickIds;
            if (!pickIds.includes(pickId)) {
                pickIds.push(pickId);
            }

            pickObject.pickId = pickId;
            object.pickId = pickId;
        }

    }

    //

    function updateVerexAttribute(vertexArray, name, arrayView) {
        const attrLocation = vertexArray._attributeLocations[name];
        const vaAttribute = vertexArray._attributes[attrLocation];
        const vertexBuffer = vaAttribute.vertexBuffer;

        if (vertexBuffer._sizeInBytes != arrayView.length * arrayView.constructor.BYTES_PER_ELEMENT) {
            console.warn('Mesh3D.WebGLRenderItems:vertexBuffer [' + name + '] size has changed');
            return
        }

        if (arrayView instanceof Uint32Array) {
            arrayView = new Float32Array(arrayView)
            console.warn('Mesh3D.WebGLRenderItems：暂不支持Uint32Array类型顶点数组，已经强制替换为Float32Array（这会增加内存开销）');
        }

        vertexBuffer.copyFromArrayView(arrayView, 0);
    }

    function updateVertexArray(geometryAttributes, drawAttributes, vertexArrayList, object) {

        const objectMaterial = object.material;
        var morph = objectMaterial.morphTargets || objectMaterial.morphNormals,
            skinning = object.isSkinnedMesh
        const useEncodedPosition = visualizer.useEncodedPosition;

        if (!skinning && !morph) {

            for (const key in geometryAttributes) {

                const drawAttribute = drawAttributes[key];
                const geometryAttribute = geometryAttributes[key];

                if (drawAttribute.version != geometryAttribute.version) {
                    const arrayView = geometryAttribute.array;

                    if (key == 'position' && useEncodedPosition) {
                        debugger

                        var factor = 1e6;
                        var positionHigh = new Float32Array(arrayView.length);
                        var positionLow = new Float32Array(arrayView.length);
                        var encodedResult = { high: 0, low: 0 }
                        for (let i = 0; i < arrayView.length; i++) {
                            const value = arrayView[i];
                            Cesium.EncodedCartesian3.encode(value * factor, encodedResult);
                            positionHigh[i] = encodedResult.high
                            positionLow[i] = encodedResult.low
                        }
                        for (let i = 0; i < vertexArrayList.length; i++) {
                            const vertexArray = vertexArrayList[i];
                            updateVerexAttribute(vertexArray, 'positionHigh', positionHigh);
                            updateVerexAttribute(vertexArray, 'positionLow', positionLow);
                        }
                    }
                    else {
                        for (let i = 0; i < vertexArrayList.length; i++) {
                            const vertexArray = vertexArrayList[i];
                            updateVerexAttribute(vertexArray, key, arrayView);

                        }
                    }

                    drawAttribute.version = geometryAttribute.version;
                }

            }

        }

        if (object.isInstancedMesh) {

            var instanceMatrix = object.instanceMatrix,
                instanceColor = object.instanceColor;

            if (!drawAttributes.instanceMatrix) drawAttributes.instanceMatrix = { version: -1 }
            if (instanceColor && !drawAttributes.instanceColor) drawAttributes.instanceColor = { version: -1 }

            if (drawAttributes.instanceMatrix.version != instanceMatrix.version) {

                const arrayView = instanceMatrix.array;

                for (let i = 0; i < vertexArrayList.length; i++) {
                    const vertexArray = vertexArrayList[i];
                    updateVerexAttribute(vertexArray, 'instanceMatrix', arrayView);
                }

                drawAttributes.instanceMatrix.version = instanceMatrix.version
            }

            if (instanceColor && drawAttributes.instanceColor.version != instanceColor.version) {

                const arrayView = instanceColor.array;
                for (let i = 0; i < vertexArrayList.length; i++) {
                    const vertexArray = vertexArrayList[i];
                    updateVerexAttribute(vertexArray, 'instanceColor', arrayView);
                }

                drawAttributes.instanceColor.version = instanceColor.version;
            }

        }

    }

    //

    var _currentCamera3js, _currentMaterialId;

    function updateLocalClipping(material, camera3js, useCache, defaultMaterialProperties) {
        const clipping = renderer._clipping;
        useCache = useCache && material.id === _currentMaterialId;

        properties.get(material, defaultMaterialProperties)

        // we might want to call this function with some ClippingGroup
        // object instead of the material, once it becomes feasible
        // (#8465, #8379)
        clipping.setState(material, camera3js, useCache);

        _currentMaterialId = material.id;
    }

    function updateClippingUniform(material, materialProperties) {
        materialProperties = materialProperties || properties.get(material)
        const clipping = renderer._clipping;
        var clippingPlanes = clipping.uniform.value;
        var materialClippingPlanes = materialProperties.clippingUniform.value
        if (clippingPlanes) Cartesian4.unpackArray(clippingPlanes, materialClippingPlanes);
        else materialClippingPlanes.length = 0;

    }

    /**
     * 
     * @param {THREE.Mesh|THREE.Line|THREE.Points} object 
     * @param {Cesium.FrameState} frameState 
     * @param {boolean}sysWireframe
     * @param {WebGLRenderState}currentRenderState
     * @param {THREE.Camera}camera3js
     * @returns {WebGLRenderItem[]}
     */
    function getAndUpdate(object, frameState, sysWireframe, currentRenderState, camera3js) {

        if (changingState.frameNumber != frameState.frameNumber) {
            changingState.changingCount = 0;
            changingState.frameNumber = frameState.frameNumber
        }

        sysWireframe = !!sysWireframe && !object.isLine && !object.isPoints;
        var wireframe = sysWireframe;

        const context = frameState.context;
        const geometry = WebGLGeometries.get(object.geometry, object.material);
        const groupsOptimized = geometry.groupsOptimized;
        const materialIndicesUsed = geometry.materialIndicesUsed;

        const programs = renderer._programs;
        const lights = currentRenderState.lights;
        const clipping = renderer._clipping;
        const shadows = currentRenderState.shadowsArray;

        const objectMaterial = object.material;
        const geometryAttributes = geometry.attributes;

        const objectProperties = properties.get(object);
        const drawAttributes = objectDrawAttributes.get(object);

        const drawRange = geometry.drawRange;

        if (!geometryAttributes.position.count
            || objectMaterial.visible == false
            || drawRange.count == 0) {
            return [];
        }

        //clipping

        const camera3jsChanged = camera3js !== _currentCamera3js
        const _clippingEnabled = currentRenderState.clippingEnabled;
        const _localClippingEnabled = currentRenderState.localClippingEnabled;
        var clippingNeedsUpdate = false;
        if (_clippingEnabled === true) {
            if (_localClippingEnabled === true || camera3jsChanged) {
                clippingNeedsUpdate = true;
            }
        }
        _currentCamera3js = camera3js;


        //

        updateSkinningAndMorphTargets(object, geometry, objectMaterial, frameState);

        /**
         * @type {WebGLRenderItem[]}
         * @private
         */
        var renderItems = object.renderItems;
        if (objectProperties.material != object.material) {
            var commandsSet = renderItemsCache.get(object);
            renderItems = commandsSet && commandsSet.get(objectMaterial);
            objectProperties.material = object.material;
        }

        var oldIndex = geometry.index

        if (renderItems == undefined) {
            //create renderItems

            initPickObject(object, context);

            if (Array.isArray(objectMaterial)) {

                materialIndicesUsed.forEach(materialIndex => {
                    const material = objectMaterial[materialIndex];
                    if (material.wireframe) wireframe = true;
                });
                materialIndicesUsed.forEach(materialIndex => {
                    const material = objectMaterial[materialIndex];
                    if (clippingNeedsUpdate) {
                        updateLocalClipping(material, camera3js, !camera3jsChanged, new MaterialProperties())
                    }
                    initMaterial(material, wireframe, lights, shadows, !clippingNeedsUpdate)

                    updateClippingUniform(material);
                });

                //use wireframe indices
                if (wireframe) geometry.index = WebGLGeometries.getWireframeAttribute(geometry);

                renderItems = cesiumCommands.createArray(object, lights, shadows);

            } else {

                wireframe = wireframe || !!objectMaterial.wireframe;

                if (wireframe) geometry.index = WebGLGeometries.getWireframeAttribute(geometry);

                if (clippingNeedsUpdate) {
                    updateLocalClipping(objectMaterial, camera3js, !camera3jsChanged, new MaterialProperties())
                }
                initMaterial(objectMaterial, wireframe, lights, shadows, true);

                updateClippingUniform(objectMaterial);

                var renderItem = cesiumCommands.create(object, lights, shadows);
                renderItem.boundingSphere = geometry.boundingSphere;
                renderItems = [renderItem];

            }

            if (geometry.index != oldIndex) geometry.index = oldIndex;

            for (let i = 0; i < renderItems.length; i++) {

                const renderItem = renderItems[i];
                const drawCommand = renderItem.drawCommand;
                const material = renderItem.material;

                const parameters = programs.getParameters(
                    material, lights.state, shadows, visualizer, object
                );
                const programCacheKey = programs.getProgramCacheKey(parameters);

                if (wireframe) {
                    renderItem.primitiveType = drawCommand.primitiveType;
                    drawCommand.primitiveType = Cesium.PrimitiveType.LINES;
                }

                renderItem.renderVersion = properties.get(material).renderVersion;
                renderItem.programCacheKey = programCacheKey;
                renderItem.materialVersion = material.version;
                renderItem.wireframe = wireframe;
                renderItem.update(object, drawCommand, geometry, visualizer.modelMatrixNeedsUpdate);

            }

            set(object, objectMaterial, renderItems);

            //

            for (const key in geometryAttributes) {
                if (geometryAttributes.hasOwnProperty(key)) {
                    drawAttributes[key] = { version: geometryAttributes[key].version };
                }
            }

        } else {
            //update renderItems

            var attributesChanged = false;
            for (const key in geometryAttributes) {
                if (!(key in drawAttributes)) {
                    attributesChanged = true;
                    drawAttributes[key] = { version: geometryAttributes[key].version }
                }
            }
            var positionChanged = geometryAttributes.position.version != drawAttributes.position.version;
            if (positionChanged) geometry.computeBoundingSphere();

            const vaToUpdateList = [];

            const _currentRenderTarget = renderer.getRenderTarget();
            const fog = visualizer.fog;
            const encoding = (_currentRenderTarget === null) ? renderer.outputEncoding : _currentRenderTarget.texture.encoding;

            for (let i = 0; i < renderItems.length; i++) {

                const renderItem = renderItems[i];

                const material = renderItem.material;
                const drawCommand = renderItem.drawCommand;
                const materialIndex = renderItem.materialIndex;
                const groupIndex = renderItem.groupIndex;

                const materialProperties = properties.get(material);

                if (clippingNeedsUpdate) {
                    updateLocalClipping(material, camera3js, !camera3jsChanged)
                }

                updateClippingUniform(material, materialProperties);

                //

                var materialChanged = false;
                const environment = material.isMeshStandardMaterial ? visualizer.environment : null;
                const envMap = cubemaps.get(material.envMap || environment);
                var renderStateNeedsUpdate = false;
                if (renderItem.materialVersion == material.version) {

                    if (material.fog && materialProperties.fog !== fog) {

                        materialChanged = true;

                    } else if (materialProperties.environment !== environment) {

                        materialChanged = true;

                    } else if (materialProperties.needsLights && (materialProperties.lightsStateVersion !== lights.state.version)) {

                        materialChanged = true;

                    } else if (materialProperties.numClippingPlanes !== undefined &&
                        (materialProperties.numClippingPlanes !== clipping.numPlanes ||
                            materialProperties.numIntersection !== clipping.numIntersection)) {

                        materialChanged = true;

                    } else if (materialProperties.outputEncoding !== encoding) {

                        materialChanged = true;

                    } else if (materialProperties.envMap !== envMap) {

                        materialChanged = true;
                    }
                    else if (materialProperties.shadows !== shadows.length) {
                        materialChanged = true;

                    } else if (materialProperties.shadowMapType != renderer.shadowMap.type) {
                        materialChanged = true;
                    } else if (materialProperties.rendererVersion != renderer.version) {
                        materialChanged = true;
                    }

                    if (materialChanged) {

                        if (!isFinite(materialProperties.renderVersion)) debugger
                        materialProperties.renderVersion++;

                    } else {
                        if (renderItem.renderVersion != materialProperties.renderVersion) {

                            materialChanged = true;

                        }

                        if (renderItem.renderStateVersion != material.renderStateVersion) {
                            renderItem.renderStateVersion = material.renderStateVersion
                            renderStateNeedsUpdate = true;
                        }
                    }

                } else {
                    materialChanged = true;
                }

                wireframe = material.wireframe || sysWireframe;

                if (materialChanged) {

                    if (changingState.maxChangingCount > changingState.changingCount) {
                        initMaterial(material, wireframe, lights, shadows);

                        const parameters = programs.getParameters(
                            material, lights.state, shadows, visualizer, object
                        );
                        var programCacheKey = programs.getProgramCacheKey(parameters);

                        materialChanged = renderItem.programCacheKey !== programCacheKey

                        renderItem.programCacheKey = programCacheKey;
                        renderItem.renderVersion = materialProperties.renderVersion;
                        renderItem.materialVersion = material.version;

                        changingState.changingCount++;
                    } else {
                        materialChanged = false;
                    }

                }

                //update shaderProgram,uniformMap

                const wireframeChanged = renderItem.wireframe != wireframe
                const geometryChanged = renderItem.geometry != object.geometry;
                if (attributesChanged || materialChanged || wireframeChanged || geometryChanged) {

                    //wireframe index & boundingSphere
                    var wireframeIndices = renderItem.wireframeIndices;
                    if (wireframe && !wireframeIndices) {

                        geometry.index = WebGLGeometries.getWireframeAttribute(geometry);

                        var boundingSphereAndIndices = computeBoundingSphereAndIndices(geometry, material.transparent ? groupIndex : materialIndex, !material.transparent, renderItem.boundingSphere);
                        wireframeIndices = boundingSphereAndIndices.indices;
                        renderItem.wireframeIndices = wireframeIndices;
                        renderItem.boundingSphere = boundingSphereAndIndices.boundingSphere;

                        geometry.index = oldIndex;

                    } else if (positionChanged) {
                        //boundingSphere 
                        var boundingSphereAndIndices = computeBoundingSphereAndIndices(geometry, material.transparent ? groupIndex : materialIndex, !material.transparent, renderItem.boundingSphere);
                        renderItem.boundingSphere = boundingSphereAndIndices.boundingSphere;
                    }

                    //new vertexArray
                    if (attributesChanged || wireframeChanged || geometryChanged) {

                        //TODO:groups=>release vaAttributeCache 
                        var va = drawCommand.vertexArray;
                        if (!va.isDestroyed()) {

                            if (i > 0 || wireframeChanged) {
                                //1、几何属性变化或者使用新几何体时，同一个几何体第二组及以后只更新索引缓冲区（indexBuffer）；
                                //2、在线框和面两种模式切换时，只更新索引缓冲区（indexBuffer）。

                                var indexBuffer = va._indexBuffer;
                                if (
                                    defined(indexBuffer) &&
                                    !indexBuffer.isDestroyed() &&
                                    indexBuffer.vertexArrayDestroyable
                                ) {
                                    indexBuffer.destroy();
                                }

                            } else {
                                va.destroy();
                            }
                        }

                        va = cesiumVertextArrays.create(geometry, object, materialIndex, wireframe ? wireframeIndices : undefined)
                        drawCommand.vertexArray = va;

                    }

                    //new shaderProgram, uniformMap
                    var shaderProgram = drawCommand.shaderProgram;
                    if (!shaderProgram.isDestroyed || !shaderProgram.isDestroyed()) shaderProgram.destroy()

                    var attributeLocations = drawCommand.vertexArray._attributeLocations;
                    shaderProgram = cesiumShaderPrograms.get(material, attributeLocations, object, lights, shadows);
                    drawCommand.shaderProgram = shaderProgram;
                    drawCommand.renderState = cesiumRenderStates.create(material, object)
                    drawCommand.uniformMap = uniforms.getUniformMap(material, object, frameState, lights);

                    //

                    if (wireframe) {
                        if (renderItem.primitiveType == undefined) renderItem.primitiveType = drawCommand.primitiveType;
                        drawCommand.primitiveType = Cesium.PrimitiveType.LINES;
                    } else if (renderItem.primitiveType != undefined) {
                        drawCommand.primitiveType = renderItem.primitiveType;
                    }

                    renderItem.wireframe = wireframe;

                }
                else {

                    if (renderStateNeedsUpdate) {
                        drawCommand.renderState = cesiumRenderStates.create(material, object)
                    }

                    uniforms.refresh(material, object);

                    vaToUpdateList.push(drawCommand.vertexArray);

                    //boundingSphere
                    if (positionChanged) {
                        var boundingSphereAndIndices = computeBoundingSphereAndIndices(geometry, material.transparent ? groupIndex : materialIndex, !material.transparent, renderItem.boundingSphere);
                        renderItem.boundingSphere = boundingSphereAndIndices.boundingSphere;
                    }

                }

                renderItem.update(object, drawCommand, geometry, visualizer.modelMatrixNeedsUpdate);

            }

            updateVertexArray(geometryAttributes, drawAttributes, vaToUpdateList, object);
        }

        object.renderItems = renderItems;

        return renderItems;
    }

    /**
     * 
     * @param {THREE.Mesh|THREE.Line|THREE.Points|THREE.Sprite} object  
     * @returns {WebGLRenderItem[]}
     */
    function get(object) {

        const objectProperties = properties.get(object);
        const objectMaterial = object.material
        if (!objectProperties.material) return;
        if (objectProperties.material == objectMaterial) return object.renderItems;

        var commandsSet = renderItemsCache.get(object);
        var renderItems = commandsSet && commandsSet.get(objectMaterial);

        return renderItems;
    }

    /**
     * 
     * @param {THREE.Mesh|THREE.Line|THREE.Points} object 
     * @param {THREE.Geometry|THREE.BufferGeometry} geometry 
     * @param {THREE.Material} material 
     * @param {WebGLRenderItem} renderItem 
     * @param {string} name 
     * @param {Cesium.FrameState} frameState 
     * @param {WebGLRenderState} [currentRenderState] 
     * @param {THREE.Camera}camera3js
     * @returns {Cesium.DrawCommand}
     */
    function getAndUpdateDerived(object, geometry, material, renderItem, name, frameState, currentRenderState, camera3js) {

        const lights = currentRenderState.lights, shadows = currentRenderState.shadowsArray;
        geometry = WebGLGeometries.get(geometry);
        const geometryAttributes = geometry.attributes;
        const drawAttributes = objectDrawAttributes.get(object);
        //clipping

        const clipping = renderer._clipping;
        const camera3jsChanged = camera3js !== _currentCamera3js
        const _clippingEnabled = currentRenderState.clippingEnabled;
        const _localClippingEnabled = currentRenderState.localClippingEnabled;
        var clippingNeedsUpdate = false;
        if (_clippingEnabled === true) {
            if (_localClippingEnabled === true || camera3jsChanged) {
                clippingNeedsUpdate = true;
            }
        }
        _currentCamera3js = camera3js;

        // updateSkinningAndMorphTargets(object, geometry, material, frameState);

        var originalDrawCommand = renderItem.drawCommand;
        var drawCommand = originalDrawCommand.derivedCommands[name];

        var derivedProperties = originalDrawCommand.derivedProperties
        var derivedCommandProperties = derivedProperties[name];
        if (!derivedCommandProperties) {
            derivedCommandProperties = {};
            derivedProperties[name] = derivedCommandProperties;
        }

        var attributeLocations = originalDrawCommand.vertexArray._attributeLocations
        var commandNeedsUpdate = !drawCommand;
        if (!commandNeedsUpdate) {
            if (derivedCommandProperties.materialVersion != renderItem.materialVersion
                || derivedCommandProperties.renderStateVersion != renderItem.material.renderStateVersion) {
                commandNeedsUpdate = true;
                derivedCommandProperties.materialVersion = renderItem.materialVersion
                derivedCommandProperties.renderStateVersion = renderItem.material.renderStateVersion
            }
            else commandNeedsUpdate = drawCommand.vertexArray._attributeLocations != attributeLocations
            if (commandNeedsUpdate) drawCommand.onMaterialDispose && drawCommand.onMaterialDispose()
        }

        if (commandNeedsUpdate) {

            if (clippingNeedsUpdate) {
                updateLocalClipping(material, camera3js, !camera3jsChanged, new MaterialProperties())
            } else {
                properties.get(material, new MaterialProperties())
            }

            updateClippingUniform(material)

            drawCommand = DrawCommand.shallowClone(originalDrawCommand);
            originalDrawCommand.derivedCommands[name] = drawCommand;

            drawCommand.shaderProgram = cesiumShaderPrograms.get(material, attributeLocations, object, lights, shadows)
            drawCommand.uniformMap = uniforms.getUniformMap(material, object, frameState, lights);
            drawCommand.renderState = cesiumRenderStates.create(material, object, false);

            function onMaterialDispose() {
                drawCommand.shaderProgram.destroy()

                const isDestroyed = originalDrawCommand.isDestroyed;
                if (!isDestroyed || !isDestroyed()) {
                    delete originalDrawCommand.derivedCommands[name];
                }

                material.removeEventListener('dispose', onMaterialDispose)
            }

            if (material._isShadowDepthMaterial) {
                object.addEventListener('dispose', onMaterialDispose)
            } else {
                material.addEventListener('dispose', onMaterialDispose)
            }

            drawCommand.onMaterialDispose = onMaterialDispose;
        } else {

            if (clippingNeedsUpdate) {
                updateLocalClipping(material, camera3js, !camera3jsChanged, new MaterialProperties())
            }
            updateClippingUniform(material);

            if (derivedCommandProperties.numClippingPlanes !== undefined &&
                (derivedCommandProperties.numClippingPlanes !== clipping.numPlanes ||
                    derivedCommandProperties.numIntersection !== clipping.numIntersection)) {

                var shaderProgram = drawCommand.shaderProgram;
                if (!shaderProgram.isDestroyed || !shaderProgram.isDestroyed()) shaderProgram.destroy()

                drawCommand.shaderProgram = cesiumShaderPrograms.get(material, attributeLocations, object, lights, shadows)
                drawCommand.uniformMap = uniforms.getUniformMap(material, object, frameState, lights);
                drawCommand.renderState = cesiumRenderStates.create(material, object, false);

            }

            uniforms.refresh(material, object);
            drawCommand.vertexArray = originalDrawCommand.vertexArray;
        }

        derivedCommandProperties.numClippingPlanes = clipping.numPlanes;
        derivedCommandProperties.numIntersection = clipping.numIntersection;

        renderItem.update(object, drawCommand, geometry, visualizer.modelMatrixNeedsUpdate);

        updateVertexArray(geometryAttributes, drawAttributes, [drawCommand.vertexArray], object)

        return drawCommand;
    }

    /**
     * 
     * @param {THREE.Mesh|THREE.Line|THREE.Points} object 
     */
    function remove(object) {

        var materialSet = materialsUsed.get(object);
        var commandsSet = renderItemsCache.get(object);

        if (materialSet && commandsSet) {

            materialSet.forEach(material => {

                var renderItems = commandsSet.get(material);
                if (!renderItems) return;

                renderItems.forEach(function (renderItem) {

                    const wireframeIndexBuffer = renderItem.wireframeIndexBuffer
                    const isDestroyed = wireframeIndexBuffer.isDestroyed;
                    if (!isDestroyed || !isDestroyed()) wireframeIndexBuffer.destroy();
                    delete renderItem.wireframeIndexBuffer
                    delete renderItem.indexBuffer
                });

            })
        }

        materialsUsed.delete(object);
        renderItemsCache.delete(object);
    }

    this.get = get;
    this.remove = remove;
    this.getAndUpdate = getAndUpdate;
    this.getAndUpdateDerived = getAndUpdateDerived;
    this.dispose = dispose;
}

export default WebGLRenderItems;
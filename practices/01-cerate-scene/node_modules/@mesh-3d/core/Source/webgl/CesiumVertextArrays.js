
import GeometryUtils from '../GeometryUtils.js';
import WebGLGeometries from './WebGLGeometries.js';
import WebGLRenderer from './WebGLRenderer.js';

function WebGLAttributeCache() {

    var _vaAttributes = new WeakMap();
    this.get = function (geometryAttribute) {
        return _vaAttributes.get(geometryAttribute);
    }
    this.set = function (geometryAttribute, vaAttribute, geometry) {

        function onGeometryDispose() {
            // _vaAttributes.delete(vaAttribute);
            _vaAttributes.delete(geometryAttribute);
            geometry.removeEventListener('dispose', onGeometryDispose)
        }
        geometry.addEventListener('dispose', onGeometryDispose);
        _vaAttributes.set(geometryAttribute, vaAttribute);
        // _vaAttributes.set(vaAttribute, geometryAttribute);
    }

    this.delete = function (attribute) {
        // var cacheVal = _vaAttributes.get(attribute);
        // _vaAttributes.delete(cacheVal);
        _vaAttributes.delete(attribute);
    }
}

/**
 * 顶点数组工具，使用threejs BufferGeometry和Cesium Geometry，生成、更新DrawCommand的vertexArray
 * @param {WebGLRenderer} renderer 
 */
function CesiumVertextArrays(renderer) {

    const {
        Matrix4,
        defined,
        GeometryPipeline,
        BufferUsage,
        VertexArray,
        defaultValue,
        Cartesian3,
        Cartesian2,
        Cartesian4,
        Color,
        Buffer,
        ComponentDatatype,
        IndexDatatype,
        BoundingSphere
    } = Cesium;

    const visualizer = renderer._visualizer;

    let _webglAttributeCache = new WebGLAttributeCache();
    let scratchMatrix = new Matrix4();

    function getVertexBufferTypedArray(mesh, creating) {

        var instances = creating ? mesh._instances : mesh._availableInstances;
        var instancesLength = instances.length;
        var collectionCenter = mesh._center;

        var vertexSizeInFloats = 12;

        var bufferData = mesh._vertexBufferTypedArray;
        if (!defined(bufferData) || instancesLength * vertexSizeInFloats > bufferData.length) {
            bufferData = new Float32Array(instancesLength * vertexSizeInFloats);
        }

        // Hold onto the buffer data so we don't have to allocate new memory every frame.
        mesh._vertexBufferTypedArray = bufferData;

        for (var i = 0; i < instancesLength; ++i) {

            var modelMatrix = instances[i].modelMatrix;

            // Instance matrix is relative to center
            var instanceMatrix = Matrix4.clone(modelMatrix, scratchMatrix);
            instanceMatrix[12] -= collectionCenter.x;
            instanceMatrix[13] -= collectionCenter.y;
            instanceMatrix[14] -= collectionCenter.z;

            var offset = i * vertexSizeInFloats;

            // First three rows of the model matrix
            bufferData[offset + 0] = instanceMatrix[0];
            bufferData[offset + 1] = instanceMatrix[4];
            bufferData[offset + 2] = instanceMatrix[8];
            bufferData[offset + 3] = instanceMatrix[12];
            bufferData[offset + 4] = instanceMatrix[1];
            bufferData[offset + 5] = instanceMatrix[5];
            bufferData[offset + 6] = instanceMatrix[9];
            bufferData[offset + 7] = instanceMatrix[13];
            bufferData[offset + 8] = instanceMatrix[2];
            bufferData[offset + 9] = instanceMatrix[6];
            bufferData[offset + 10] = instanceMatrix[10];
            bufferData[offset + 11] = instanceMatrix[14];

        }

        return bufferData;
    }

    function getPickIdBufferTypedArray(mesh, context, creating) {
        var i;
        var instances = creating ? mesh._instances : mesh._availableInstances;
        var instancesLength = instances.length

        var pickIdBuffer = mesh._pickIdBufferTypedArray;
        if (!pickIdBuffer || instancesLength * 4 > pickIdBuffer.length) {
            pickIdBuffer = new Uint8Array(instancesLength * 4);
        }
        mesh._pickIdBufferTypedArray = pickIdBuffer;

        for (i = 0; i < instancesLength; ++i) {
            var instance = instances[i];
            var pickId = mesh._pickIds[instance.instanceId];
            if (!pickId) {
                pickId = context.createPickId(instance);
                mesh._pickIds[instance.instanceId] = pickId;
            }
            var pickColor = pickId.color;
            var offset = i * 4;
            pickIdBuffer[offset] = Color.floatToByte(pickColor.red);
            pickIdBuffer[offset + 1] = Color.floatToByte(pickColor.green);
            pickIdBuffer[offset + 2] = Color.floatToByte(pickColor.blue);
            pickIdBuffer[offset + 3] = Color.floatToByte(pickColor.alpha);
        }
        return pickIdBuffer;
    }

    function getInstancedAttribTypedArray(mesh, instancedAttribute, creating) {
        var i;
        // var instances = mesh._availableInstances;
        var instances = creating ? mesh._instances : mesh._availableInstances;
        var instancesLength = instances.length;
        var name = instancedAttribute.name;
        var componentsPerAttribute;
        var isColorValue = instancedAttribute.default instanceof Color
        if (typeof instancedAttribute.default == 'number') {
            componentsPerAttribute = 1;
        }
        else if (instancedAttribute.default instanceof Cartesian2) {
            componentsPerAttribute = 2;
        }
        else if (instancedAttribute.default instanceof Cartesian3) {
            componentsPerAttribute = 3;
        }
        else if (instancedAttribute.default instanceof Cartesian4) {
            componentsPerAttribute = 4;
        } else if (isColorValue) {
            componentsPerAttribute = 4;
        }

        var bufferData = mesh['_' + name + 'BufferTypedArray'];
        if (!bufferData || instancesLength * componentsPerAttribute > bufferData.length) {
            if (isColorValue) {
                bufferData = new Uint8Array(instancesLength * componentsPerAttribute);
            }
            else {
                bufferData = new Float32Array(instancesLength * componentsPerAttribute);
            }
        }
        mesh['_' + name + 'BufferTypedArray'] = bufferData;

        if (isColorValue) {
            for (i = 0; i < instancesLength; ++i) {
                var instance = instances[i];
                var val = instance[name];
                var offset = i * componentsPerAttribute;

                bufferData[offset] = Color.floatToByte(val.red);
                bufferData[offset + 1] = Color.floatToByte(val.green);
                bufferData[offset + 2] = Color.floatToByte(val.blue);
                bufferData[offset + 3] = Color.floatToByte(val.alpha);
            }
        } else if (typeof instancedAttribute.default == 'number') {
            for (i = 0; i < instancesLength; ++i) {
                var instance = instances[i];
                var val = instance[name];
                bufferData[i] = val;
            }
        }
        else if (instancedAttribute.default instanceof Cartesian2) {

            for (i = 0; i < instancesLength; ++i) {
                var instance = instances[i];
                var val = instance[name];
                var offset = i * componentsPerAttribute;
                bufferData[offset] = val.x;
                bufferData[offset + 1] = val.y;
            }
        }
        else if (instancedAttribute.default instanceof Cartesian3) {

            for (i = 0; i < instancesLength; ++i) {
                var instance = instances[i];
                var val = instance[name];
                var offset = i * componentsPerAttribute;
                bufferData[offset] = val.x;
                bufferData[offset + 1] = val.y;
                bufferData[offset + 2] = val.z;
            }
        }
        else if (instancedAttribute.default instanceof Cartesian4) {
            for (i = 0; i < instancesLength; ++i) {
                var instance = instances[i];
                var val = instance[name];
                var offset = i * componentsPerAttribute;
                bufferData[offset] = val.x;
                bufferData[offset + 1] = val.y;
                bufferData[offset + 2] = val.z;
                bufferData[offset + 3] = val.w;
            }
        }
        return bufferData;

    }

    function createMeshInstancedAttributes(mesh, context, vertexArrayAttributes, attributeLocations, maxAttribLocation) {
        var instancedAttributes = mesh.instancedAttributes;
        instancedAttributes.forEach(function (instancedAttribute) {

            var name = instancedAttribute.name
            attributeLocations[name] = ++maxAttribLocation

            var buffer = Buffer.createVertexBuffer({
                context: context,
                typedArray: getInstancedAttribTypedArray(mesh, instancedAttribute, true),
                usage: BufferUsage.STATIC_DRAW
            });
            instancedAttribute._buffer = buffer;

            var attribute = {
                index: attributeLocations[instancedAttribute.name],
                vertexBuffer: buffer,
                componentsPerAttribute: 4,
                componentDatatype: ComponentDatatype.FLOAT,
                normalize: false,
                offsetInBytes: 0,
                strideInBytes: 0,
                instanceDivisor: 1
            }
            if (typeof instancedAttribute.default == 'number') {
                attribute.componentsPerAttribute = 1;
            }
            else if (instancedAttribute.default instanceof Cartesian2) {
                attribute.componentsPerAttribute = 2;
            }
            else if (instancedAttribute.default instanceof Cartesian3) {
                attribute.componentsPerAttribute = 3;
            }
            else if (instancedAttribute.default instanceof Cartesian4) {
                attribute.componentsPerAttribute = 4;
            } else if (instancedAttribute.default instanceof Color) {
                attribute.componentDatatype = ComponentDatatype.UNSIGNED_BYTE;
                attribute.normalize = true;
                attribute.componentsPerAttribute = 4;
            }

            vertexArrayAttributes.push(attribute);

        })

        return maxAttribLocation;

    }

    function createInstanceMvMatrixVertexBuffer(mesh, context) {
        var pickIdBuffer = getPickIdBufferTypedArray(mesh, context, true);
        mesh._pickIdBuffer = Buffer.createVertexBuffer({
            context: context,
            typedArray: pickIdBuffer,
            usage: BufferUsage.STATIC_DRAW
        });
        var vertexBufferTypedArray = getVertexBufferTypedArray(mesh, true);
        mesh._vertexBuffer = Buffer.createVertexBuffer({
            context: context,
            typedArray: vertexBufferTypedArray,
            usage: BufferUsage.STATIC_DRAW
        });
    }

    function copyFromBufferView(vertexBuffer, arrayView, offsetInBytes) {
        offsetInBytes = offsetInBytes || 0;
        var gl = vertexBuffer._gl;
        var target = vertexBuffer._bufferTarget;
        gl.bindBuffer(target, vertexBuffer._buffer);
        gl.bufferData(target, arrayView, gl.DYNAMIC_DRAW);
        gl.bindBuffer(target, null);

    }

    function updateInstanceVertexBuffer(mesh, context) {
        var vertexBufferTypedArray = getVertexBufferTypedArray(mesh);
        copyFromBufferView(mesh._vertexBuffer, vertexBufferTypedArray);

        var pickIdBufferTypedArray = getPickIdBufferTypedArray(mesh, context);
        copyFromBufferView(mesh._pickIdBuffer, pickIdBufferTypedArray);

        var instancedAttributes = mesh.instancedAttributes;
        instancedAttributes.forEach(function (instancedAttribute) {
            var bufferTypedArray = getInstancedAttribTypedArray(mesh, instancedAttribute);
            copyFromBufferView(instancedAttribute._buffer, bufferTypedArray);
        })
    }

    function createPickIds(mesh, context) {
        // PERFORMANCE_IDEA: we could skip the pick buffer completely by allocating
        // a continuous range of pickIds and then converting the base pickId + batchId
        // to RGBA in the shader.  The only consider is precision issues, which might
        // not be an issue in WebGL 2.
        var instances = mesh._instances;
        var instancesLength = instances.length;
        var pickIds = new Array(instancesLength);
        for (var i = 0; i < instancesLength; ++i) {
            pickIds[i] = context.createPickId(instances[i]);
        }
        return pickIds;
    }

    //创建实例化mesh所有实例的整体外包围球，并计算中心，因为cesium的实例化渲染传递矩阵是需要这个中心加入运算
    function createInstanceBoundingSphere(mesh) {
        var instancesLength = mesh._instances.length;
        var points = new Array(instancesLength);

        for (var i = 0; i < instancesLength; ++i) {

            points[i] = Matrix4.getTranslation(mesh._instances[i].modelMatrix, new Cartesian3());
        }

        mesh._boundingSphere = BoundingSphere.fromPoints(points);
        Cartesian3.clone(mesh._boundingSphere.center, mesh._center);
    }

    /**
     * 转换Three.js BufferGeometry的InterleavedBufferAttribute
     * @param {string} name
     * @param {THREE.InterleavedBufferAttribute|THREE.InstancedInterleavedBuffer} attribute 
     * @param {{[key:string]:number}}attributeLocations
     * @param {Cesium.Context}
     * @private
     */
    function createInterleavedAttribute3js(name, attribute, attributeLocations, context) {


        var data = attribute.data;
        var stride = data.stride;
        var offset = attribute.offset;

        var array = data.array;
        var bytesPerElement = array.constructor.BYTES_PER_ELEMENT

        var vertexBuffer = Buffer.createVertexBuffer({
            context: context,
            typedArray: array,
            usage: data.usage
        });

        let vaAttribute = {
            index: attributeLocations[name],
            vertexBuffer: vertexBuffer,
            componentDatatype: GeometryUtils.getAttributeComponentType(array),
            componentsPerAttribute: attribute.itemSize,
            normalize: attribute.normalized,
            offsetInBytes: offset * bytesPerElement,
            strideInBytes: stride * bytesPerElement
        };

        if (data && data.isInstancedInterleavedBuffer) {
            vaAttribute.instanceDivisor = data.meshPerAttribute || 1
        }
        return vaAttribute;
    }

    /**
     * 
     * @param {string} name 
     * @param {THREE.BufferAttribute|THREE.InstancedBufferAttribute} attribute 
     * @param {{[key:string]:number}} attributeLocations 
     * @param {Cesium.Context} context 
     * @param {Cesium.BufferUsage}bufferUsage
     * @param {{start:number,count:number}}[group]
     * @returns {Cesium.VertexArrayAttribute}
     * @private
     */
    function createAttribute3js(name, attribute, attributeLocations, context, bufferUsage, group) {

        try {

            var array = attribute.array;
            if (array instanceof Uint32Array) {
                array = new Float32Array(array)
                console.warn('Mesh3D.CesiumVertextArrays：暂不支持Uint32Array类型顶点数组，已经强制替换为Float32Array（这会增加内存开销）');
            }

            var vertexBuffer = Buffer.createVertexBuffer({
                context: context,
                typedArray: array,
                usage: attribute.usage || bufferUsage
            });

            let vaAttribute = {
                index: attributeLocations[name],
                vertexBuffer: vertexBuffer,
                componentDatatype: GeometryUtils.getAttributeComponentType(array),
                componentsPerAttribute: attribute.itemSize,
                normalize: attribute.normalized
            };

            if (attribute.isInstancedBufferAttribute) {
                vaAttribute.offsetInBytes = 0;
                vaAttribute.strideInBytes = 0;
                vaAttribute.instanceDivisor = attribute.meshPerAttribute || 1;
            }

            return vaAttribute;
        } catch (err) {
            debugger
            throw err
        }
    }

    /**
     * 
     * 
     * @param {object} options
     * @param {THREE.BufferGeometry} options.geometry 
     * @param {Cesium.Context} options.context 
     * @param {Cesium.BufferUsage} [options.bufferUsage]
     * @param {{start:number,count:number}}[options.group]
     * @param {ArrayBufferView}[options.indices]
     * @returns {Cesium.Buffer}
     * @private 
     */
    function createIndexBuffer3js(options) {


        // var mesh = options.mesh;
        // var geometry = mesh.geometry;
        const geometry = options.geometry;
        const groups = geometry.groups;
        const bufferUsage = defaultValue(options.bufferUsage, BufferUsage.DYNAMIC_DRAW);
        const context = options.context;
        const group = options.group;
        const groupOptimized = options.groupOptimized

        //索引buffer

        var indices = options.indices, indexBuffer, index = geometry.index;
        if (!indices) {
            if (typeof group != 'undefined' && groups.length > 1) {

                //处理threejs用gl.drawArrays绘制的部分，转成用drawElements绘制
                indices = GeometryUtils.genGeometryIndices(geometry, group, groupOptimized)

            } else if (index) {

                indices = index.array;

            }
        }

        if (indices && indices.length > 0) {

            var indexDatatype = IndexDatatype.UNSIGNED_SHORT;
            if (indices instanceof Uint8Array) indexDatatype = IndexDatatype.UNSIGNED_BYTE;
            else if (indices instanceof Uint32Array) indexDatatype = IndexDatatype.UNSIGNED_INT;

            indexBuffer = Buffer.createIndexBuffer({
                context: context,
                typedArray: indices,
                usage: bufferUsage,
                indexDatatype: indexDatatype,
            });

        }

        return indexBuffer;
    }

    /**
     * 
     * 
     * @param {object} options
     * @param {THREE.BufferGeometry} options.geometry 
     * @param {Cesium.Context} options.context 
     * @param {{[key:string]:number}} options.attributeLocations 
     * @param {Cesium.VertexArrayAttribute[]}[options.vertexArrayAttributes]
     * @param {{start:number,count:number}}[options.group]
     * @param {ArrayBufferView}[options.indices]
     * @param {boolean}[options.useEncodedPosition=false]
     * @private
     */
    function fromBufferGeometry3js(options) {

        const geometry = options.geometry;
        // const position = geometry.attributes.position;
        const groups = geometry.groups;
        // const drawRange = geometry.drawRange;
        const context = options.context;
        const attributeLocations = options.attributeLocations;
        const group = options.group;
        const groupOptimized = options.groupOptimized;
        const bufferUsage = defaultValue(options.bufferUsage, BufferUsage.DYNAMIC_DRAW);
        var vaAttributes = [].concat(options.vertexArrayAttributes || []);
        var attributes3js = geometry.attributes;

        if (options.useEncodedPosition) {
            //positionHigh+positionLow
            attributes3js = Object.assign({}, geometry.attributes);
            var position = attributes3js.position, positions = position.array;
            var positionHigh = attributes3js.positionHigh = Object.assign({}, position)
            var positionLow = attributes3js.positionLow = Object.assign({}, position);
            positionHigh.array = new Float32Array(positions.length)
            positionLow.array = new Float32Array(positions.length)

            var encodedResult = { high: 0, low: 0 };
            var factor = 1e6;
            positions.forEach((value, i) => {
                Cesium.EncodedCartesian3.encode(value * factor, encodedResult);
                positionHigh.array[i] = encodedResult.high
                positionLow.array[i] = encodedResult.low
            });

            delete attributes3js.position;
        }

        //indexBuffer

        var indexBuffer = createIndexBuffer3js({
            geometry: geometry,
            context: context,
            group: group,
            groupOptimized: groupOptimized,
            bufferUsage: bufferUsage,
            indices: options.indices
        })

        //vertexBuffer

        var instanceCount, vaAttributeFromCache = group && groups.length > 1;

        for (const name in attributes3js) {
            if (attributes3js.hasOwnProperty(name) && defined(attributes3js[name])) {

                let attribute3js = attributes3js[name],
                    vaAttribute = vaAttributeFromCache ? _webglAttributeCache.get(attribute3js) : undefined;

                if (!vaAttribute) {
                    if (attribute3js.isInterleavedBufferAttribute) {
                        vaAttribute = createInterleavedAttribute3js(name, attribute3js, attributeLocations, context)

                    } else {
                        vaAttribute = createAttribute3js(name, attribute3js, attributeLocations, context, bufferUsage, group)
                    }

                    if (vaAttribute.instanceDivisor) {
                        instanceCount = vaAttribute.instanceDivisor * attribute3js.count;
                    }
                    _webglAttributeCache.set(attribute3js, vaAttribute, geometry);
                }

                vaAttributes.push(vaAttribute);

            }
        }

        var va = new VertexArray({
            context: context,
            attributes: vaAttributes,
            indexBuffer: indexBuffer
        });
        va._attributeLocations = attributeLocations;
        va.instanceCount = instanceCount;

        attributes3js = null;

        return va;

    }


    /**
     * 
     * 
     * @param {Cesium.Geometry|THREE.BufferGeometry} geometry 
     * @param {Mesh|THREE.Mesh} mesh 
     * @param {Cesium.Context} context 
     * @param {{start:number,count:number}|number}[group] group or materialIndex
     * @param {ArrayBufferView}[indices]
     * @param {boolean}[groupOptimized]  
     */
    this.create = function (geometry, mesh, group, indices, groupOptimized) {

        const frameSate = visualizer.frameState, context = frameSate.context;

        let useEncodedPosition = visualizer.useEncodedPosition;

        var mesh3js = mesh;
        var attributes = geometry.attributes;
        if (mesh3js && useEncodedPosition) {
            attributes = Object.assign({}, geometry.attributes)
            attributes.positionHigh = attributes.position
            attributes.positionLow = attributes.position
            delete attributes.position;
        }

        var attributeLocations = GeometryPipeline.createAttributeLocations({ attributes });
        var maxAttribLocation = 0, instanceCount;
        var va;

        for (var location in attributeLocations) {
            if (attributeLocations.hasOwnProperty(location)) {
                maxAttribLocation = Math.max(maxAttribLocation, attributeLocations[location])
            }
        }

        var vertexArrayAttributes;
        if (mesh._instances && mesh._instances.length) {
            createInstanceBoundingSphere(mesh);

            vertexArrayAttributes = []

            mesh._pickIds = createPickIds(mesh, context);

            createInstanceMvMatrixVertexBuffer(mesh, context);

            var vertexSizeInFloats = 12;
            var componentSizeInBytes = ComponentDatatype.getSizeInBytes(ComponentDatatype.FLOAT);

            var instancedAttributes = {
                czm_modelMatrixRow0: {
                    index: maxAttribLocation + 1,
                    vertexBuffer: mesh._vertexBuffer,
                    componentsPerAttribute: 4,
                    componentDatatype: ComponentDatatype.FLOAT,
                    normalize: false,
                    offsetInBytes: 0,
                    strideInBytes: componentSizeInBytes * vertexSizeInFloats,
                    instanceDivisor: 1
                },
                czm_modelMatrixRow1: {
                    index: maxAttribLocation + 2,
                    vertexBuffer: mesh._vertexBuffer,
                    componentsPerAttribute: 4,
                    componentDatatype: ComponentDatatype.FLOAT,
                    normalize: false,
                    offsetInBytes: componentSizeInBytes * 4,
                    strideInBytes: componentSizeInBytes * vertexSizeInFloats,
                    instanceDivisor: 1
                },
                czm_modelMatrixRow2: {
                    index: maxAttribLocation + 3,
                    vertexBuffer: mesh._vertexBuffer,
                    componentsPerAttribute: 4,
                    componentDatatype: ComponentDatatype.FLOAT,
                    normalize: false,
                    offsetInBytes: componentSizeInBytes * 8,
                    strideInBytes: componentSizeInBytes * vertexSizeInFloats,
                    instanceDivisor: 1
                }
            };

            instancedAttributes.a_pickColor = {
                index: maxAttribLocation + 4,
                vertexBuffer: mesh._pickIdBuffer,
                componentsPerAttribute: 4,
                componentDatatype: ComponentDatatype.UNSIGNED_BYTE,
                normalize: true,
                offsetInBytes: 0,
                strideInBytes: 0,
                instanceDivisor: 1
            };

            for (var location in instancedAttributes) {
                if (instancedAttributes.hasOwnProperty(location)) {
                    attributeLocations[location] = ++maxAttribLocation;
                    vertexArrayAttributes.push(instancedAttributes[location])
                }
            }

            maxAttribLocation = createMeshInstancedAttributes(mesh, context, vertexArrayAttributes, attributeLocations, maxAttribLocation);

        } else if (mesh3js.isInstancedMesh) {
            vertexArrayAttributes = []
            var instanceMatrix = mesh3js.instanceMatrix,
                instanceColor = mesh3js.instanceColor;

            var vertexSizeInFloats = 16;
            var componentSizeInBytes = ComponentDatatype.getSizeInBytes(ComponentDatatype.FLOAT);

            var vertexBuffer = Buffer.createVertexBuffer({
                context: context,
                typedArray: instanceMatrix.array,
                usage: BufferUsage.STATIC_DRAW
            });
            var instancedAttributes = {};

            for (let i = 0; i < 4; i++) {
                var location = 'instanceMatrix' + (i ? i : ''),
                    index = ++maxAttribLocation;
                var instancedAttribute = {
                    index: index,
                    vertexBuffer: vertexBuffer,
                    componentsPerAttribute: 4,
                    componentDatatype: ComponentDatatype.FLOAT,
                    normalize: false,
                    offsetInBytes: i * vertexSizeInFloats,
                    strideInBytes: componentSizeInBytes * vertexSizeInFloats,
                    instanceDivisor: 1
                }
                vertexArrayAttributes.push(instancedAttribute);
                attributeLocations[location] = index;
            }

            if (mesh3js.instanceColor) {
                attributeLocations['instanceColor'] = ++maxAttribLocation;
                var instanceColor = createAttribute3js('instanceColor', mesh3js.instanceColor, attributeLocations, context, group, BufferUsage.STATIC_DRAW)
                instanceColor.instanceDivisor = 1;
                vertexArrayAttributes.push(instanceColor);

            }

            instanceCount = mesh3js.count;
        }

        if (geometry.isBufferGeometry) {

            va = fromBufferGeometry3js({
                context: context,
                geometry: geometry,
                attributeLocations: attributeLocations,
                bufferUsage: BufferUsage.STATIC_DRAW,
                vertexArrayAttributes: vertexArrayAttributes,
                group: group,
                indices: indices,
                groupOptimized: groupOptimized,
                useEncodedPosition: useEncodedPosition
            });
        }
        else {

            attributes = geometry.attributes;
            for (const key in attributes) {
                var attribute = attributes[key]
                if (!attribute) delete attributes[key]
                else if (attribute.componentDatatype == ComponentDatatype.DOUBLE) {
                    attribute.values = new Float32Array(attribute.values)
                }
            }

            va = VertexArray.fromGeometry({
                context: context,
                geometry: geometry,
                attributeLocations: attributeLocations,
                bufferUsage: BufferUsage.STATIC_DRAW,
                vertexArrayAttributes: vertexArrayAttributes
            });
        }

        if (vertexArrayAttributes && vertexArrayAttributes.length) {
            va._cacehVertexArrayAttributes = vertexArrayAttributes;
        }
        va._attributeLocations = attributeLocations;
        if (instanceCount) va.instanceCount = instanceCount;
        va._attributes.sort((a, b) => {
            return a.index - b.index;
        })

        return va;
    }

    /**
     * 
     * @param {Mesh|THREE.Mesh} mesh  
     * @param {Cesium.DrawCommand} command 
     * @param {THREE.BufferGeometry}[geometry3js]
     * @param {boolean}[forceUpdate]
     * @private
     */
    this.update = function (mesh, command, geometry3js, forceUpdate) {

        const frameSate = visualizer.frameState, context = frameSate.context;

        var mesh3js = mesh;
        if (!geometry3js && mesh3js) geometry3js = WebGLGeometries.get(mesh3js.geometry);

        var geometry = mesh.geometry;
        //更新属性缓冲区
        var attributes = geometry.attributes;

        var attributes3js = geometry3js && geometry3js.attributes;
        var va = command.vertexArray;
        var vaNeedsUpdate = false;

        var morph = false, skinning = false;
        if (mesh3js) {
            morph = mesh3js.material.morphTargets || mesh3js.material.morphNormals;
            skinning = mesh3js.isSkinnedMesh
        }

        if (!skinning && !morph) {

            for (var name in attributes) {
                var attribute = attributes[name];
                if (!attribute) continue;

                // if (morph && (name.includes('morphTarget') || name.includes('morphNormal'))) continue;

                var needsUpdate = forceUpdate || attribute.needsUpdate != false

                if (!attributes3js && needsUpdate == false) continue;

                if (updateVerexAttribute(va, name, (attributes3js && attributes3js[name]) || attribute, needsUpdate)) {
                    attribute.needsUpdate = false;
                } else {
                    vaNeedsUpdate = true;
                    break;
                }
            }
        }

        //更新索引缓冲区
        if (!vaNeedsUpdate && geometry.indexNeedsUpdate) {
            var ib = va.indexBuffer;
            geometry.indexNeedsUpdate = false;
            ib.copyFromArrayView(geometry.indices, 0);
        }

        if (!vaNeedsUpdate && mesh._instances && mesh._instances.length) {
            updateInstanceVertexBuffer(mesh, context);
        }

        //重建vertexArray
        if (vaNeedsUpdate) {
            var va = command.vertexArray;
            if (!va.isDestroyed()) {
                va.destroy();

                if (_webglAttributeCache) {
                    for (var name in attributes3js) {
                        if (attributes3js.hasOwnProperty(name) && attributes3js[name]) {
                            _webglAttributeCache.delete(attributes3js[name])
                        }
                    }
                    debugger
                }
            }

            command.vertexArray = this.create(mesh, context);
            for (var name in attributes) {
                if (attributes.hasOwnProperty(name) && attributes[name]) {
                    attributes[name].needsUpdate = false;
                }
            }
            mesh.geometry.indexNeedsUpdate = false;

        } else if (mesh3js && mesh3js.isInstancedMesh) {

            var instanceMatrix = mesh3js.instanceMatrix,
                instanceColor = mesh3js.instanceColor;

            if (va._attributes[va._attributeLocations['instanceMatrix']].version != instanceMatrix.version) {

                updateVerexAttribute(va, 'instanceMatrix', instanceMatrix);
            }

            if (instanceColor && va._attributes[va._attributeLocations['instanceColor']].version != instanceColor.version) {
                updateVerexAttribute(va, 'instanceColor', instanceColor);
            }
        }

        return vaNeedsUpdate;
    }

    /**
     * 
     * @param {Mesh|THREE.Mesh} mesh 
     * @param {string} attributeName 
     * @param {THREE.BufferAttribute|Cesium.GeometryAttribute}geometryAttribute
     * @private
     */
    this.updateVerexBuffer = function (mesh, attributeName, geometryAttribute) {
        var renderItems = mesh.renderItems; //(mesh._actualMesh || mesh).command;
        if (!renderItems) return;
        if (attributeName == 'position') debugger;
        renderItems.forEach(renderItem => {
            if (!renderItem) return;
            const drawCommand = renderItem.drawCommand;
            var va = drawCommand.vertexArray;
            updateVerexAttribute(va, attributeName, geometryAttribute, true)
        })
    }

    function updateVerexAttribute(va, name, geometryAttribute, needsUpdate) {

        var attrLocation = va._attributeLocations[name];
        if (attrLocation == undefined) return false;

        var vaAttr = va._attributes[attrLocation];
        // needsUpdate = needsUpdate || vaAttr.version != geometryAttribute.version;

        // if (!needsUpdate) return true;

        var vb = vaAttr.vertexBuffer;
        var arrayView = geometryAttribute.values || geometryAttribute.array;

        var BYTES_PER_ELEMENT = arrayView.constructor.BYTES_PER_ELEMENT;
        if (vb._sizeInBytes != arrayView.length * BYTES_PER_ELEMENT) {
            return false
        }

        vb.copyFromArrayView(arrayView, 0);
        // vaAttr.version = geometryAttribute.version;
        return true;
    }

    /**
     * 
     * @param {THREE.BufferGeometry} geometry3js 
     */
    this.delete = function (geometry3js) {
        if (_webglAttributeCache) {
            var attributes3js = geometry3js.attributes;
            for (var name in attributes3js) {
                if (attributes3js.hasOwnProperty(name) && attributes3js[name]) {
                    _webglAttributeCache.delete(attributes3js[name])
                }
            }
        }
    }

}

export default CesiumVertextArrays;
 
/**
* shader工具，生成、处理顶着色器和片元着色器的代码，处理实例化shader，转换threejs shader
*@constructor
*/
function ShaderUtils() { }

/**
 * 
 * @param {string} source 
 * @param {string} chunck 
 */
export function insertBeforeMain(source, chunck) {
    let renamedMain = chunck + "\nvoid main()";
    return source.replace(/void\s+main\s*\(\s*(?:void)?\s*\)/g, renamedMain);
}

ShaderUtils.insertBeforeMain = insertBeforeMain;

/**
 * 
 * @param {string} source 
 * @param {string} chunck 
 */
export function insertAfterMain(source, chunck) {
    let renamedMain = "void main(){\n" + chunck;
    return source.replace(/void\s+main\s*\(\s*(?:void)?\s*\)\s*{/g, renamedMain);
}
ShaderUtils.insertAfterMain = insertAfterMain;
/**
 * 
 * @param {string} source 
 * @param {string} chunck 
 */
export function appendMain(source, chunck) {

    if (!chunck) return source;

    let start = source.lastIndexOf('}')
    if (start >= 0 && chunck.length) {
        let a = source.substring(0, start);
        let b = source.substring(start);
        if (chunck[chunck.length - 1] != '\n')
            source = a + chunck + '\n' + b;
        else source = a + chunck + b;
    }
    return source;
}
ShaderUtils.appendMain = appendMain;

/**
 * 
 * @param {string} source 
 * @param {string} include
 * @param {string} chunck 
 */
ShaderUtils.replaceIncludes = function (source, include, chunck) {
    return source.replace(include, chunck);
}

/**
 * 
 * @param {string} source 
 * @param {RegExp} pattern 
 * @param {string} chunck 
 * @returns {string}
 */
export function insertBefore(source, pattern, chunck) {
    let regex = pattern;
    if (typeof pattern == 'string') {
        regex = new RegExp(pattern, 'g');
    }
    let m = regex.exec(source);
    if (m) {
        let start = m.index;
        let a = source.substring(0, start);
        let b = source.substring(start);
        source = a + chunck + b;
    }
    return source;
}
ShaderUtils.insertBefore = insertBefore

/**
 * 
 * @param {string} source 
 * @param {RegExp} pattern 
 * @param {string} chunck 
 * @returns {string}
 */
export function insertAfter(source, pattern, chunck) {
    let regex = pattern;
    if (typeof pattern == 'string') {
        regex = new RegExp(pattern, 'g');
    }
    let m = regex.exec(source);
    if (m) {
        let start = m.index + m[0].length;
        let a = source.substring(0, start);
        let b = source.substring(start);
        source = a + chunck + b;
    }
    return source;
}
ShaderUtils.insertAfter = insertAfter;



var positionRegex = /attribute\s+vec(?:3|4)\s+(.*)3DHigh;/g;

ShaderUtils._modifyShaderPosition = function (
    primitive,
    vertexShaderSource,
    scene3DOnly
) {
    var match;

    var forwardDecl = "";
    var attributes = "";
    var computeFunctions = "";

    while ((match = positionRegex.exec(vertexShaderSource)) !== null) {
        var name = match[1];

        var functionName =
            "vec4 czm_compute" + name[0].toUpperCase() + name.substr(1) + "()";

        // Don't forward-declare czm_computePosition because computePosition.glsl already does.
        if (functionName !== "vec4 czm_computePosition()") {
            forwardDecl += functionName + ";\n";
        }

        if (!defined(primitive.rtcCenter)) {
            // Use GPU RTE
            if (!scene3DOnly) {
                attributes +=
                    "attribute vec3 " +
                    name +
                    "2DHigh;\n" +
                    "attribute vec3 " +
                    name +
                    "2DLow;\n";

                computeFunctions +=
                    functionName +
                    "\n" +
                    "{\n" +
                    "    vec4 p;\n" +
                    "    if (czm_morphTime == 1.0)\n" +
                    "    {\n" +
                    "        p = czm_translateRelativeToEye(" +
                    name +
                    "3DHigh, " +
                    name +
                    "3DLow);\n" +
                    "    }\n" +
                    "    else if (czm_morphTime == 0.0)\n" +
                    "    {\n" +
                    "        p = czm_translateRelativeToEye(" +
                    name +
                    "2DHigh.zxy, " +
                    name +
                    "2DLow.zxy);\n" +
                    "    }\n" +
                    "    else\n" +
                    "    {\n" +
                    "        p = czm_columbusViewMorph(\n" +
                    "                czm_translateRelativeToEye(" +
                    name +
                    "2DHigh.zxy, " +
                    name +
                    "2DLow.zxy),\n" +
                    "                czm_translateRelativeToEye(" +
                    name +
                    "3DHigh, " +
                    name +
                    "3DLow),\n" +
                    "                czm_morphTime);\n" +
                    "    }\n" +
                    "    return p;\n" +
                    "}\n\n";
            } else {
                computeFunctions +=
                    functionName +
                    "\n" +
                    "{\n" +
                    "    return czm_translateRelativeToEye(" +
                    name +
                    "3DHigh, " +
                    name +
                    "3DLow);\n" +
                    "}\n\n";
            }
        } else {
            // Use RTC
            vertexShaderSource = vertexShaderSource.replace(
                /attribute\s+vec(?:3|4)\s+position3DHigh;/g,
                ""
            );
            vertexShaderSource = vertexShaderSource.replace(
                /attribute\s+vec(?:3|4)\s+position3DLow;/g,
                ""
            );

            forwardDecl += "uniform mat4 u_modifiedModelView;\n";
            attributes += "attribute vec4 position;\n";

            computeFunctions +=
                functionName +
                "\n" +
                "{\n" +
                "    return u_modifiedModelView * position;\n" +
                "}\n\n";

            vertexShaderSource = vertexShaderSource.replace(
                /czm_modelViewRelativeToEye\s+\*\s+/g,
                ""
            );
            vertexShaderSource = vertexShaderSource.replace(
                /czm_modelViewProjectionRelativeToEye/g,
                "czm_projection"
            );
        }
    }

    return [forwardDecl, attributes, vertexShaderSource, computeFunctions].join(
        "\n"
    );
};

ShaderUtils.modifyShaderPosition = function (mesh, shader) {
    var vs = shader.vertexShader;
    if (!vs.includes('transformed')) return;
    vs = vs.replace(
        'gl_Position = projectionMatrix * mvPosition',
        'vec4 mvis_positionEC = vec4( transformed, 1.0 );\n\
        #ifdef USE_INSTANCING\n\
            mvis_positionEC = instanceMatrix * mvis_positionEC;\n\
        #endif\n\
        mvis_positionEC=vec4(mvis_positionEC.xyz - u_cameraPositionLC,1.);\n\
        gl_Position = czm_modelViewProjectionRelativeToEye * mvis_positionEC;\n\
        '
    );
    shader.vertexShader = vs;
}

/**
 *  positionHigh+positionLow
 * @param {Mesh} mesh 
 * @param {object} shader
 * @param {string} shader.vertexShader
 * @param {string} shader.fragmentShader
 */
ShaderUtils.modifyEncodedPosition = function (mesh, shader) {
    var vs = shader.vertexShader
    vs = vs.replace(
        /attribute\s?vec3\s?position\s?;/g, '\
         attribute vec3 positionHigh;\n\
         attribute vec3 positionLow;\n\
         vec3 position;\n\
        ');
    shader.vertexShader = this.insertAfterMain(vs, 'position=(positionHigh+positionLow)*1e-6;\n');

}

/**
 * 修改threejs shader中shadowWorldPosition
 * @param {Mesh} mesh 
 * @param {object} shader
 * @param {string} shader.vertexShader
 * @param {string} shader.fragmentShader
 */
ShaderUtils.modifyShadowWorldPosition = function (mesh, shader) {
    var vs = shader.vertexShader
    if (/vec4\s?shadowWorldPosition;/g.test(vs)) {
        vs = vs.replace(
            /vec4\s?shadowWorldPosition;/g,
            'vec4 shadowWorldPosition;\n\
		vec4 worldPositionThree = vec4( transformed, 1.0 );\n\
		#ifdef USE_INSTANCING\n\
			worldPositionThree = instanceMatrix * worldPositionThree;\n\
        #endif\n\
        // vec3 transformedNormalThree = objectNormal;\n\
        // #ifdef USE_INSTANCING\n\
        //     mat3 m = mat3( instanceMatrix );\n\
        //     transformedNormalThree /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\
        //     transformedNormalThree = m * transformedNormalThree;\n\
        // #endif\n\
        // shadowWorldNormal= normalMatrixWorld*transformedNormalThree;\n\
        worldPositionThree=matrixWorld*worldPositionThree;\n');
        vs = vs.replace(
            /shadowWorldPosition\s?=\s?worldPosition\s?\+\s?/g,
            'shadowWorldPosition = worldPositionThree + '
        );
    }

    if (vs.includes('#define DISTANCE')) {

        vs = vs.replace(/vWorldPosition\s?=\s?worldPosition.xyz\s?;/g, '\n\
        vec4 worldPositionThree = vec4(transformed, 1.0 );\n\
        #ifdef USE_INSTANCING\n\
            worldPositionThree = instanceMatrix * worldPositionThree;\n\
        #endif\n\
        worldPositionThree = matrixWorld * worldPositionThree;\n\
        vWorldPosition=worldPositionThree.xyz;\n');
    }

    shader.vertexShader = vs;
}

/**
 * 修改threejs shader中环境贴图相关代码
 * @param {Mesh} mesh 
 * @param {object} shader
 * @param {string} shader.vertexShader
 * @param {string} shader.fragmentShader
 */
ShaderUtils.modifyEnvMapQueryVec = function (mesh, shader) {

    const Matrix4 = Cesium.Matrix4
    // if (Matrix4.equals(mesh.modelMatrix, Matrix4.IDENTITY)) return;
    var fs = shader.fragmentShader;
    // if (/cameraToVertex\s?=\s?normalize\(\s?worldPosition.xyz\s?-\s?cameraPosition \);/g.test(shader.vertexShader)) {
    fs = fs.replace(
        /textureCube\s?\(\s?envMap\s?,\s?vec3\s?\(\s?flipEnvMap\s?\*\s?reflectVec.x\s?,\s?reflectVec.yz\s?\)\s\)/g,
        ' textureCube( envMap,vec3( flipEnvMap *(_CesiumNormal2ThreeNormal* reflectVec).x, (_CesiumNormal2ThreeNormal*reflectVec).yz ) )'
    );
    // }

    fs = fs.replace(
        /\(\s?envMap\s?,\s?reflectVec/g,
        '( envMap,_CesiumNormal2ThreeNormal * reflectVec'
    );

    // if (/\(\s?envMap\s?,\s?queryVec/g.test(fs)) {
    fs = fs.replace(
        /\(\s?envMap\s?,\s?queryVec/g,
        '( envMap,_CesiumNormal2ThreeNormal* queryVec'
    );
    // }
    // if (/\(\s?envMap\s?,\s?queryReflectVec/g.test(fs)) {
    fs = fs.replace(
        /\(\s?envMap\s?,\s?queryReflectVec/g,
        '( envMap,_CesiumNormal2ThreeNormal* queryReflectVec'
    );
    // }

    // if (/equirectUv\(\s?reflectVec\s?\)/g.test(fs)) {
    fs = fs.replace(
        /equirectUv\(\s?reflectVec\s?\)/g,
        'equirectUv( _CesiumNormal2ThreeNormal* reflectVec )'
    );
    // }

    // if (/equirectUv\(\s?direction\s?\)/g.test(fs)) {
    fs = fs.replace(
        /equirectUv\(\s?direction\s?\)/g,
        'equirectUv( _CesiumNormal2ThreeNormal* direction )'
    );
    // }

    if (/textureCubeUV\s?\(\s?envMap\s?,\s?reflectVec/g.test(fs)) {
        fs = fs.replace(
            /textureCubeUV\s?\(\s?envMap\s?,\s?reflectVec/g,
            'textureCubeUV(envMap, _CesiumNormal2ThreeNormal* reflectVec'
        );

    }
    if (/textureCubeUV\s?\(\s?envMap\s?,\s?worldNormal/g.test(fs)) {

        fs = fs.replace(
            /textureCubeUV\s?\(\s?envMap\s?,\s?worldNormal/g,
            'textureCubeUV(envMap, _CesiumNormal2ThreeNormal* worldNormal'
        );

    }
    shader.fragmentShader = fs;
    // console.log(shader.fragmentShader);
}
 

/**
 * 处理实例化shader代码
 * @param {THREE.Mesh} mesh 
 * @param {object} shader
 * @param {string} shader.vertexShader
 * @param {string} shader.fragmentShader
 */
ShaderUtils.processInstanceShader = function (mesh, shader) {
    if (mesh._instances && mesh._instances.length) {

        var vs = shader.vertexShader;
        var renamedSource = Cesium.ShaderSource.replaceMain(vs, 'czm_instancing_main');
        renamedSource = renamedSource.replace(/.*uniform\s+mat4\s+modelViewMatrix/g, 'mat4 modelViewMatrix')
            .replace(/.*uniform\s+mat4\s+u_modelViewMatrix/g, 'mat4 u_modelViewMatrix')
            .replace(/.*uniform\s+mat4\s+modelMatrix/g, 'mat4 modelMatrix')
            .replace(/.*uniform\s+mat4\s+u_modelMatrix/g, 'mat4 u_modelMatrix')

        var addFunctionCode = '';
        var u_mats = [];
        var getNormalMatrixCode = '';
        //非threejs instanceMesh实例化渲染，增加计算实例的normalMatrix的glsl代码
        addFunctionCode = '\n\
        mat3 inverse_mat3(mat3 m)\n\
            {\n\
                float Determinant = \n\
                      m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])\n\
                    - m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])\n\
                    + m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]);\n\
                    \n\
                mat3 Inverse;\n\
                Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]);\n\
                Inverse[1][0] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]);\n\
                Inverse[2][0] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]);\n\
                Inverse[0][1] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]);\n\
                Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]);\n\
                Inverse[2][1] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]);\n\
                Inverse[0][2] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]);\n\
                Inverse[1][2] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]);\n\
                Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]);\n\
                Inverse /= Determinant;\n\
                \n\
                return Inverse;\n\
            }\n\
            \n\
           mat3 transpose (mat3 m) {\n\
            \n\
                float tmp;\n\
                 \n\
                tmp = m[0][ 1 ]; m[0][ 1 ] = m[1][ 0 ]; m[1][ 0 ] = tmp;\n\
                tmp = m[0][ 2 ]; m[0][ 2 ] = m[2][ 0 ]; m[2][ 0 ] = tmp;\n\
                tmp = m[1][ 2 ]; m[1][ 2 ] = m[2][ 1 ]; m[2][ 1 ] = tmp;\n\
                \n\
                return m;\n\
            }\n\
            \n\
            ';
        renamedSource = renamedSource
            .replace(/.*uniform\s+mat3\s+u_normalMatrix/g, 'mat3 u_normalMatrix')
            .replace(/.*uniform\s+mat3\s+normalMatrix/g, 'mat3 normalMatrix');

        if (!/mat3\s+normalMatrix/g.test(renamedSource))
            u_mats.push('mat3 normalMatrix;');
        if (!/mat3\s+u_normalMatrix/g.test(renamedSource))
            u_mats.push('mat3 u_normalMatrix;');

        getNormalMatrixCode = '\n\
                   normalMatrix=mat3(modelViewMatrix);\n\
                   normalMatrix=transpose(inverse_mat3(normalMatrix));\n\
                   u_normalMatrix=normalMatrix;\n\
                ';
        // 

        if (!/mat4\s+u_modelMatrix/g.test(renamedSource))
            u_mats.push('mat4 u_modelMatrix;');
        if (!/mat4\s+u_modelViewMatrix/g.test(renamedSource))
            u_mats.push('mat4 u_modelViewMatrix;');


        var pickAttribute = 'attribute vec4 a_pickColor;\n' +
            'varying vec4 czm_pickColor;\n';
        var pickVarying = '    czm_pickColor = a_pickColor;\n';

        vs = //'mat4 czm_instanced_modelView;\n' +
            'attribute vec4 czm_modelMatrixRow0;\n' +
            'attribute vec4 czm_modelMatrixRow1;\n' +
            'attribute vec4 czm_modelMatrixRow2;\n' +
            'uniform mat4 czm_instanced_modifiedModelView;\n' +
            // batchIdAttribute +
            u_mats.join('\n') +
            pickAttribute +
            renamedSource +
            addFunctionCode +
            'void main()\n' +
            '{\n' +
            '    modelMatrix = mat4(czm_modelMatrixRow0.x, czm_modelMatrixRow1.x, czm_modelMatrixRow2.x, 0.0, czm_modelMatrixRow0.y, czm_modelMatrixRow1.y, czm_modelMatrixRow2.y, 0.0, czm_modelMatrixRow0.z, czm_modelMatrixRow1.z, czm_modelMatrixRow2.z, 0.0, czm_modelMatrixRow0.w, czm_modelMatrixRow1.w, czm_modelMatrixRow2.w, 1.0);\n' +
            '    modelViewMatrix = czm_instanced_modifiedModelView * modelMatrix;\n' +
            '    u_modelMatrix =modelMatrix;\n' +
            '    u_modelViewMatrix = modelViewMatrix ;\n' +
            // globalVarsMain +
            getNormalMatrixCode +
            '    czm_instancing_main();\n' +
            pickVarying +
            '}\n';
        shader.vertexShader = vs;
    }
}

/**
 * 处理实例化shader代码
 * @param {Mesh|THREE.Mesh} mesh 
 * @param {object} shader
 * @param {string} shader.vertexShader
 * @param {string} shader.fragmentShader
 */
ShaderUtils.processOcclusionCulling = function (mesh, shader) {
    if (mesh.material.transparent) return;

    shader.fragmentShader = Cesium.ShaderSource.replaceMain(shader.fragmentShader, 'mvis_OcclusionCulling');
    var mvis_OcclusionCulling = '\n\
    uniform sampler2D occlusionCullingMap;\n\
    uniform bool occlusionCullingToggle;\n\
    uniform vec2 occlusionCullingResolution;\n\
    void main(){\n\
        if(occlusionCullingToggle){\n\
            vec4 tPkColor=texture2D(occlusionCullingMap,gl_FragCoord.xy/occlusionCullingResolution);\n\
            if(tPkColor.r!=czm_pickColor.r||tPkColor.g!=czm_pickColor.g||tPkColor.b!=czm_pickColor.b||tPkColor.a!=czm_pickColor.a){\n\
               discard;\n\
            }\n\
            // gl_FragColor=tPkColor;\n\
        }\n\
        else{\n\
            mvis_OcclusionCulling();\n\
        }\n\
    }'
    shader.fragmentShader += mvis_OcclusionCulling;
}

export default ShaderUtils;
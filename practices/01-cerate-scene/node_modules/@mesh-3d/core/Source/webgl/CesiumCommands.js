
import WebGLGeometries from './WebGLGeometries.js';
import GeometryUtils from '../GeometryUtils.js';
import WebGLRenderItem from './WebGLRenderItem.js';
import WebGLLights from './WebGLLights.js';
import WebGLRenderer from './WebGLRenderer.js';
/**
 * 绘图命令工具，用于生成、更新、销毁Cesium.DrawCommand 
 * @param {WebGLRenderer} renderer  
 */
export default function CesiumCommands(renderer) {

    const visualizer = renderer._visualizer;
    const webglUniforms = renderer._uniforms
    const cesiumRenderStates = renderer._cesiumRenderStates;
    const cesiumShaderPrograms = renderer._cesiumShaderPrograms
    const cesiumVertextArrays = renderer._cesiumVertextArrays

    /**
     *  
     * @param {THREE.Mesh} mesh3js 
     * @param {WebGLLights}lights
     * @param {number}[materialIndexOrGroupIndex] 
     * @param {ArrayBufferView}indices
     * @param {boolean}[groupOptimized]
     * @returns {WebGLRenderItem}
    */
    this.create = function (mesh3js, lights, shadows, materialIndexOrGroupIndex, indices, groupOptimized) {
        const frameState = visualizer.frameState,
            context = frameState.context;
        // const webglUniforms = renderer._uniforms;
        // const cesiumRenderStates = renderer._cesiumRenderStates
        const geometry = WebGLGeometries.get(mesh3js.geometry);
        const groups = geometry.groups;
        var material3js = mesh3js.material;

        var pickIdStr = 'czm_pickColor';
        var primitiveType;

        const { defined, Matrix4, PrimitiveType, DrawCommand, Pass } = Cesium;

        //primitiveType

        if (mesh3js.isMesh) {

            if (material3js.wireframe) {

                primitiveType = PrimitiveType.LINES;

            } else {

                primitiveType = PrimitiveType.TRIANGLES;

            }

        }
        else if (mesh3js.isLine) {

            if (mesh3js.isLineSegments) {
                primitiveType = PrimitiveType.LINES;
            }
            else if (mesh3js.isLineLoop) {
                primitiveType = PrimitiveType.LINE_LOOP;
            } else {
                primitiveType = PrimitiveType.LINE_STRIP;
            }

        } else if (mesh3js.isPoints) {
            primitiveType = PrimitiveType.POINTS;
        } else {
            primitiveType = PrimitiveType.TRIANGLES;
        }

        //

        var instances = mesh3js.instances;
        var availableInstances = mesh3js._availableInstances;

        var drawCommand = new DrawCommand({
            modelMatrix: instances && instances.length > 0 ? undefined : Matrix4.clone(visualizer.modelMatrix),
            owner: mesh3js,
            castShadows: true,

            pickId: pickIdStr,

            receiveShadows: true,
            primitiveType: primitiveType,
            cull: false,
            instanceCount: instances && instances.length > 0 ? availableInstances.length : undefined,
        });

        //vertexArray

        let vertexArray = cesiumVertextArrays.create(geometry, mesh3js, materialIndexOrGroupIndex, indices, groupOptimized);
        var attributeLocations = vertexArray._attributeLocations;

        if (vertexArray.instanceCount) {
            drawCommand.instanceCount = vertexArray.instanceCount;
        }

        drawCommand.vertexArray = vertexArray;

        //shaderProgram
        var materialIndex = materialIndexOrGroupIndex, groupIndex = null;
        if (Array.isArray(material3js)) {
            //group
            if (!groupOptimized) {
                groupIndex = materialIndexOrGroupIndex
                materialIndex = groups[groupIndex].materialIndex;
            }
            material3js = material3js[materialIndex];
        }

        drawCommand.shaderProgram = cesiumShaderPrograms.get(material3js, attributeLocations, mesh3js, lights, shadows);

        //pass

        var pass = mesh3js.pass;
        if (typeof pass != 'number' || pass < 0 || pass > Pass.TRANSLUCENT) {
            pass = material3js.translucent ? Pass.TRANSLUCENT : Pass.CESIUM_3D_TILE
        }
        // drawCommand.pass = material3js.translucent ?  Pass.TRANSLUCENT : pass//|| Pass.CESIUM_3D_TILE
        drawCommand.pass = material3js.translucent ? Pass.TRANSLUCENT : (material3js.stencilWrite ? Pass.CESIUM_3D_TILE_CLASSIFICATION : Pass.CESIUM_3D_TILE)
        drawCommand._v_pass = material3js.translucent || material3js.transparent ? Pass.TRANSLUCENT : pass//Pass.CESIUM_3D_TILE

        if (!defined(material3js.allowPick)) {
            material3js.allowPick = true;
        }

        drawCommand.renderState = cesiumRenderStates.create(material3js, mesh3js);
        drawCommand._renderStateOptions = material3js._renderStateOptions;

        drawCommand.uniformMap = webglUniforms.getUniformMap(material3js, mesh3js, frameState, lights, shadows);

        if (mesh3js.uniformMapLoadedCallback) {
            mesh3js.uniformMapLoadedCallback(drawCommand.uniformMap, frameState, mesh3js);
        }

        return new WebGLRenderItem(drawCommand, material3js, materialIndex, mesh3js, geometry, visualizer, groupIndex);
    }


    /**
     * 
     * @param {THREE.Mesh} mesh3js 
     * @param {WebGLLights}[lights]
     * @param {THREE.Light[]}[shadows]
     * @returns {WebGLRenderItem[]}
     */
    this.createArray = function (mesh3js, lights, shadows) {

        var renderItems = [];
        var geometry = WebGLGeometries.get(mesh3js.geometry, mesh3js.material);
        var groupsOptimized = geometry.groupsOptimized;
        //合并材质相同的组，drawCommand数量与material的相同
        for (let i = 0; i < groupsOptimized.length; i++) {

            const newGroup = groupsOptimized[i];
            var materialIndex = newGroup.materialIndex;
            var groupOptimized = true;
            // const groupIndex = newGroup.groupIndex;
            // const material = mesh3js.material[materialIndex];
            // if (material.transparent && !material.translucent) {
            //     groupOptimized = false;
            //     materialIndex=groupIndex;
            // }
            var boundingSphereAndIndices = GeometryUtils.computeBoundingSphereAndIndices(geometry, materialIndex, groupOptimized);
            const { boundingSphere, indices } = boundingSphereAndIndices;
            var renderItem = this.create(mesh3js, lights, shadows, materialIndex, indices, groupOptimized);
            renderItem.boundingSphere = boundingSphere;
            renderItems.push(renderItem);

        }

        // //不合并，drawCommand数量与group的相同
        // var geometry = mesh3js.geometry;
        // var groups = geometry.groups;
        // groups.forEach((group) => {
        //     var renderItem = this.create(mesh3js, frameSate, visualizer, group);
        //     renderItems.push(renderItem);
        // }); 

        return renderItems;
    }

    /**
     * 
     * @param {THREE.Mesh|THREE.Line|THREE.Points|THREE.Sprite} mesh  
     * @param {THREE.BufferGeometry}geometry
     */
    this.update = function (mesh, geometry) {

        const { BoundingSphere, Matrix4 } = Cesium;

        geometry = geometry || mesh.geometry;

        var renderItems = Array.isArray(mesh.renderItems) ? mesh.renderItems : [mesh.renderItems];

        var hasGroup = Array.isArray(mesh.material);

        renderItems.forEach((renderItem) => {
            var drawCommand = renderItem.drawCommand;
            var material = renderItem.material || mesh.material;

            if (mesh.isInstancedMesh) {
                drawCommand.instanceCount = mesh.count;
            }

            if (mesh.instances && mesh.instances.length) {

                //boundingVolume
                if (mesh.frustumCulled != false && !drawCommand.boundingVolume) {
                    var bs = BoundingSphere.clone(mesh._boundingSphere);
                    drawCommand.boundingVolume = bs;
                }

                //instanceCount

                drawCommand.instanceCount = mesh._availableInstances.length;
            }
            else if (mesh.frustumCulled != false || material.translucent || material.transparent) {
                //boundingVolume

                var bs = hasGroup && drawCommand.__boundingSphere ? drawCommand.__boundingSphere : geometry.boundingSphere;

                if (!bs) {
                    if (geometry.computeBoundingSphere) {
                        geometry.computeBoundingSphere();
                        bs = geometry.boundingSphere;
                    }
                    else {
                        var positionAttr = geometry.attributes.position
                        bs = BoundingSphere.fromVertices(positionAttr.values || positionAttr.array);
                        geometry.boundingSphere = bs;
                    }
                }

                if (!drawCommand.boundingVolume) {
                    drawCommand.boundingVolume = BoundingSphere.clone(bs);
                }

                if (visualizer._modelMatrixNeedsUpdate || mesh.modelMatrixNeedsUpdate || !drawCommand.boundingVolume._multiplyByModelMatrix) {
                    Matrix4.multiplyByPoint(mesh.modelMatrix, bs.center, drawCommand.boundingVolume.center);
                    drawCommand.boundingVolume.radius = bs.radius * Matrix4.getMaximumScale(mesh.modelMatrix)
                    drawCommand.boundingVolume._multiplyByModelMatrix = true;
                }

                let instanceCount = geometry.maxInstancedCount || geometry.instanceCount
                if (instanceCount) {
                    drawCommand.instanceCount = instanceCount;
                }
            }

            //modelMatrix 
            drawCommand.modelMatrix = mesh.modelMatrix;
        });

        if (hasGroup) {

            renderItems.forEach((renderItem) => {
                var material = renderItem.material;
                visualizer.renderer._uniforms.refresh(material, mesh);

            })

        }

    }

}


import ConstantMap from "./ConstantMap.js";

function WebGLTextures(visualizer) {

    const {
        TextureMinificationFilter, TextureWrap,
        ContextLimits, Sampler,
        PixelFormat, defined, Texture, CubeMap
    } = Cesium;

    const _Math = Cesium.Math;

    // var renderer = visualizer.renderer;
    // var cubemaps = renderer._cubemaps;
    var textureCache = visualizer._textureCache;

    var textures = new WeakMap();
    var textureReferences = new WeakMap();
    var disposeCallbacks = new WeakMap();

    /**
     * 
     * @param {Cesium.Texture|Cesium.CubeMapFace} destTexture 
     * @param {object} source
     * @param {ArrayBufferView} source.arrayBufferView
     * @param {number} source.width
     * @param {number} source.height
     * @param {ArrayBufferView[]} source.mipLevels
     * @private
     */
    function uploadTextureData(destTexture, source) {

        var size = destTexture._size;
        var pixelFormat = destTexture._pixelFormat;
        var pixelDatatype = destTexture._pixelDatatype;

        var preMultiplyAlpha = destTexture._preMultiplyAlpha;
        var flipY = destTexture._flipY;

        /**
         * @type {WebGLRenderingContext}
         * @private
         */
        var gl = destTexture._gl || destTexture._context._gl;
        var textureTarget = destTexture._textureTarget;
        var texture = destTexture._texture;
        var targetFace = typeof destTexture._targetFace == 'number' ? destTexture._targetFace : textureTarget;

        var width = source.width;
        var height = source.height;
        var arrayBufferView = source.arrayBufferView;

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(textureTarget, texture);

        var unpackAlignment = 4;

        gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

        // Source: typed array
        var arrayBufferView = source.arrayBufferView;

        var isCompressed = PixelFormat.isCompressedFormat(pixelFormat);
        if (isCompressed) {
            gl.compressedTexImage2D(
                targetFace,
                0,//level
                pixelFormat,
                width,
                height,
                0,
                arrayBufferView
            );
        } else {
            gl.texImage2D(
                targetFace,
                0,
                pixelFormat,
                width,
                height,
                0,
                pixelFormat,
                pixelDatatype,
                arrayBufferView
            );
        }

        if (defined(source.mipLevels)) {
            var mipWidth = width;
            var mipHeight = height;
            for (var i = 0; i < source.mipLevels.length; ++i) {
                mipWidth = Math.floor(mipWidth / 2) | 0;
                if (mipWidth < 1) {
                    mipWidth = 1;
                }
                mipHeight = Math.floor(mipHeight / 2) | 0;
                if (mipHeight < 1) {
                    mipHeight = 1;
                }
                if (isCompressed) {
                    gl.compressedTexImage2D(
                        targetFace,
                        i + 1,
                        pixelFormat,
                        mipWidth,
                        mipHeight,
                        0,
                        source.mipLevels[i]
                    );
                } else {
                    gl.texImage2D(
                        targetFace,
                        i + 1,
                        pixelFormat,
                        mipWidth,
                        mipHeight,
                        0,
                        pixelFormat,
                        pixelDatatype,
                        source.mipLevels[i]
                    );
                }
            }
        }

        gl.bindTexture(textureTarget, null);
    }

    function convertSampler(texture3js) {
        var sampler = {};

        sampler.minificationFilter = ConstantMap.minFilterMap[texture3js.minFilter];
        sampler.magnificationFilter = ConstantMap.magFilterMap[texture3js.magFilter];
        sampler.wrapS = ConstantMap.textureWrapMap[texture3js.wrapS];
        sampler.wrapT = ConstantMap.textureWrapMap[texture3js.wrapT];
        sampler.maximumAnisotropy = texture3js.anisotropy;
        return new Sampler(sampler);
    }

    /**
     * 
     * @param {THREE.Texture} texture3js 
     * @param {Cesium.Context} frameState 
     * @private
     */
    function createTexture(texture3js, context) {
        var format = formatsMap[texture3js.format];
        var type = typesMap[texture3js.type];
        var preMultiplyAlpha = texture3js.premultiplyAlpha;
        var flipY = texture3js.flipY;
        var sampler = convertSampler(texture3js);
        var image = texture3js.image;
        var mipmaps = texture3js.mipmaps;
        var width = image.width;
        var height = image.height;
        var hasMipmaps = mipmaps && mipmaps.length > 0;

        //gen mipmap

        var mipmap =
            (sampler.minificationFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST) ||
            (sampler.minificationFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR) ||
            (sampler.minificationFilter === TextureMinificationFilter.LINEAR_MIPMAP_NEAREST) ||
            (sampler.minificationFilter === TextureMinificationFilter.LINEAR_MIPMAP_LINEAR);

        //PowerOfTwo

        var requiresNpot = mipmap ||
            (sampler.wrapS === TextureWrap.REPEAT) ||
            (sampler.wrapS === TextureWrap.MIRRORED_REPEAT) ||
            (sampler.wrapT === TextureWrap.REPEAT) ||
            (sampler.wrapT === TextureWrap.MIRRORED_REPEAT);

        var source = image;

        var npot = source && (!_Math.isPowerOfTwo(source.width) || !_Math.isPowerOfTwo(source.height));
        if (requiresNpot && npot) {

            // WebGL requires power-of-two texture dimensions for mipmapping and REPEAT/MIRRORED_REPEAT wrap modes.
            var canvas = document.createElement('canvas');
            canvas.width = _Math.nextPowerOfTwo(source.width);
            canvas.height = _Math.nextPowerOfTwo(source.height);
            var canvasContext = canvas.getContext('2d');
            canvasContext.drawImage(source, 0, 0, source.width, source.height, 0, 0, canvas.width, canvas.height);
            source = canvas;
            width = canvas.width;
            height = canvas.height;
        }

        //maximumTextureSize

        let needsResize = false;
        if (width > ContextLimits.maximumTextureSize) {
            width = ContextLimits.maximumTextureSize;
            needsResize = true;

            console.warn("Mesh3D.WebGLTextures:Width should be less than or equal to the maximum texture size (" +
                ContextLimits.maximumTextureSize +
                ").  Check maximumTextureSize.");
        }
        if (height > ContextLimits.maximumTextureSize) {
            console.warn("Mesh3D.WebGLTextures:Height should be less than or equal to the maximum texture size (" +
                ContextLimits.maximumTextureSize +
                ").  Check maximumTextureSize.");
            height = ContextLimits.maximumTextureSize;
            needsResize = true;
        }

        if (needsResize) {

            console.warn("Mesh3D.WebGLTextures:Width and height must be less than or equal to the maximum texture size (" +
                ContextLimits.maximumTextureSize +
                ").  Check maximumTextureSize.");

            var canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            var canvasContext = canvas.getContext('2d');
            canvasContext.drawImage(source, 0, 0, source.width, source.height, 0, 0, canvas.width, canvas.height);
            source = canvas;
            width = canvas.width;
            height = canvas.height;
        }

        //new Texture

        var texture = new Texture({
            context: context,
            source: hasMipmaps ? undefined : source,
            width: width,
            height: height,
            pixelFormat: format,
            pixelDatatype: type,
            sampler: sampler,
            flipY: flipY,
            preMultiplyAlpha: preMultiplyAlpha
        });

        if (mipmap) {
            texture.generateMipmap();
        }

        return texture;
    }
    /**
     * 
     * @param {THREE.Texture} texture3js 
     * @param {Cesium.Context} context 
     * @private
     */
    function createDataTexture(texture3js, context) {
        var format = formatsMap[texture3js.format];
        var type = typesMap[texture3js.type];
        var preMultiplyAlpha = texture3js.premultiplyAlpha;
        var flipY = texture3js.flipY;
        var sampler = convertSampler(texture3js);
        var image = texture3js.image;
        var mipmaps = texture3js.mipmaps;
        var width = image.width > 1 ? image.width : 1;
        var height = image.height > 1 ? image.height : 1;
        var hasMipmaps = mipmaps && mipmaps.length > 0;

        var texture = new Texture({
            context: context,
            source: hasMipmaps ? undefined : {
                arrayBufferView: image.data,
                width: width,
                height: height
            },
            width: width,
            height: height,
            pixelFormat: format,
            pixelDatatype: type,
            sampler: sampler,
            flipY: flipY,
            preMultiplyAlpha: preMultiplyAlpha
        });

        if (hasMipmaps) {
            debugger
            var source = { width, height };
            source.arrayBufferView = mipmaps[0].data;

            if (mipmaps.length > 1) {
                var mipLevels = [];
                for (let i = 1; i < mipmaps.length; i++) {
                    mipLevels.push(mipmaps[i].data)
                }
                source.mipLevels = mipLevels;
            }

            texture._pixelFormat = format;
            uploadTextureData(texture, source);
            texture._initialized = true;
        }

        return texture;
    }
    /**
     * 
     * @param {THREE.Texture} texture3js 
     * @param {Cesium.Context} context 
     * @private
     */
    function createCompressedTexture(texture3js, context) {
        var format = formatsMap[texture3js.format];
        var type = typesMap[texture3js.type];
        var preMultiplyAlpha = texture3js.premultiplyAlpha;
        var flipY = texture3js.flipY;
        var sampler = convertSampler(texture3js);
        var image = texture3js.image;
        var mipmaps = texture3js.mipmaps;
        var width = image.width
        var height = image.height
        var isCompressed = PixelFormat.isCompressedFormat(format);

        var texture = new Texture({
            context: context,
            width: width,
            height: height,
            pixelFormat: isCompressed ? PixelFormat.RGBA : format,
            pixelDatatype: type,
            sampler: sampler,
            flipY: flipY,
            preMultiplyAlpha: preMultiplyAlpha
        });

        var source = { width, height };
        source.arrayBufferView = mipmaps[0].data;

        if (mipmaps.length > 1) {

            var mipLevels = [];
            for (let i = 1; i < mipmaps.length; i++) {
                mipLevels.push(mipmaps[i].data)
            }
            source.mipLevels = mipLevels;
        }

        texture._pixelFormat = format;
        uploadTextureData(texture, source);
        texture._initialized = true;

        return texture;
    }

    /**
     * 
     * @param {THREE.Texture} texture3js 
     * @param {Cesium.Context} context 
     * @private
     */
    function createCubeMap(texture3js, context) {

        var format = formatsMap[texture3js.format];
        var type = typesMap[texture3js.type];
        var images = texture3js.image;
        var mipmaps = texture3js.mipmaps;

        images = images.map(image => {
            if (image.isDataTexture) {
                debugger
                return {
                    arrayBufferView: image.data,
                    width: image.data,
                    height: image.height
                }
            }
            return image;
        })

        var cubeMap = new CubeMap({
            context: context,
            source: {
                positiveX: images[0],
                negativeX: images[1],
                positiveY: images[2],
                negativeY: images[3],
                positiveZ: images[4],
                negativeZ: images[5]
            },
            pixelFormat: format,
            pixelDatatype: type,
            preMultiplyAlpha: texture3js.preMultiplyAlpha,
            flipY: texture3js.flipY
        });

        if (mipmaps && mipmaps.length) {
            debugger
        }
        return cubeMap;

    }

    /**
     * 
     * @param {THREE.Texture} texture3js 
     * @param {Cesium.Context} context 
     * @private
     */
    function createCompressedCubeMap(texture3js, context) {
        var format = formatsMap[texture3js.format];
        var type = typesMap[texture3js.type];
        var preMultiplyAlpha = texture3js.premultiplyAlpha;
        var flipY = texture3js.flipY;

        var images = texture3js.image;
        var width = images.width || images[0].width
        var height = images.height || images[0].height
        var isCompressed = PixelFormat.isCompressedFormat(format);

        var cubemap = new CubeMap({
            width: width,
            height: height,
            context: context,
            pixelFormat: isCompressed ? PixelFormat.RGBA : format,
            pixelDatatype: type,
            preMultiplyAlpha: preMultiplyAlpha,
            flipY: flipY
        });

        var faces = ["positiveX", "negativeX", "positiveY", "negativeY", "positiveZ", "negativeZ"]
        faces.forEach((face, faceId) => {

            var cubeFace = cubemap[face], image = images[faceId],
                mipmaps = image.mipmaps, source = { width, height };

            source.arrayBufferView = mipmaps[0].data;

            if (mipmaps.length > 1) {
                var mipLevels = [];
                for (let i = 1; i < mipmaps.length; i++) {
                    mipLevels.push(mipmaps[i].data)
                }
                source.mipLevels = mipLevels;
            }

            cubeFace._pixelFormat = format;
            uploadTextureData(cubeFace, source);
            cubeFace._initialized = true;
        });

        return cubemap;
    }

    /**
     * 
     * @param {THREE.Texture} texture3js 
     * @param {Cesium.Context} context 
     * @private
     */
    function createHdrCubeMap(texture3js, context) {

        var format = formatsMap[texture3js.format];
        var type = typesMap[texture3js.type];
        var preMultiplyAlpha = texture3js.premultiplyAlpha;
        var flipY = texture3js.flipY;

        var images = texture3js.image.map(image => {
            if (image.isDataTexture) {
                var tex = image;
                return {
                    width: tex.image.width,
                    height: tex.image.height,
                    arrayBufferView: tex.image.data
                }
            }
            return image;
        });

        var cubeMap = new CubeMap({
            context: context,
            source: {
                positiveX: images[0],
                negativeX: images[1],
                positiveY: images[2],
                negativeY: images[3],
                positiveZ: images[4],
                negativeZ: images[5]
            },
            pixelFormat: format,
            pixelDatatype: type,
            preMultiplyAlpha: preMultiplyAlpha,
            flipY: flipY
        });

        return cubeMap;
    }

    function isImagesLoaded(texture3js) {
        var images = texture3js.image, imagesLoaded = true;

        if (!images || !images.length) return false;

        for (let i = 0; i < images.length; i++) {
            const image = images[i];
            if (!image) {
                imagesLoaded = false;
                break;
            }
        }

        return imagesLoaded;
    }

    this.has = function has(texture3js) {
        return textures.has(texture3js)
    }

    var hasOffscreenCanvas = typeof OffscreenCanvas != 'undefined'
    /**
     * 
     * @param {THREE.Texture|THREE.CanvasTexture|THREE.DataTexture|THREE.CubeTexture|THREE.DataTexture3D|THREE.DepthTexture|THREE.VideoTexture|THREE.CompressedTexture} texture3js 
     * @param {Cesium.FrameState} frameState  
     * @returns {Cesium.Texture|Cesium.CubeMap}
     */
    this.get = function get(texture3js, frameState, defaultVal) {

        // if (!texture3js) return defaultVal;

        if (textureCache[texture3js.uuid]) {
            return textureCache[texture3js.uuid];
        }

        var context = frameState.context;
        var texture = textures.get(texture3js);

        if (texture && texture.version != texture3js.version) {
            texture = this.delete(texture3js);
        }

        if (!texture) {

            var defaultTexture = visualizer.defaultTexture,
                defaultCubeMap = visualizer.defaultCubeMap;

            var image = texture3js.image;

            if (texture3js.isCanvasTexture || texture3js.isVideoTexture) {

                if (image) {
                    texture = createTexture(texture3js, context);
                } else {
                    return defaultTexture;
                }

            } else if (texture3js.isDataTexture) {

                if (image && image.data) {

                    texture = createDataTexture(texture3js, context);

                } else {
                    return defaultVal || defaultTexture;
                }

            } else if (texture3js.isCubeTexture) {

                if (image.length == 6 && isImagesLoaded(texture3js)) {
                    texture = createCubeMap(texture3js, context);
                } else {
                    return defaultCubeMap;
                }

            } else if (texture3js.isCompressedTexture) {

                if (image) {

                    if (Array.isArray(image)) {

                        if (texture3js.mipmaps) {
                            texture = createCompressedTexture(texture3js, context)
                        }
                        else {

                            if (isImagesLoaded(texture3js)) {
                                texture = createCompressedCubeMap(texture3js, context);
                            }
                            else {
                                return defaultVal || defaultCubeMap;
                            }
                        }

                    } else {
                        texture = createCompressedTexture(texture3js, context)
                    }

                } else {
                    return defaultTexture;
                }

            } else if (Array.isArray(image)) {//hdr CubeTexture

                if (isImagesLoaded(texture3js)) {
                    texture = createHdrCubeMap(texture3js, context);
                } else {
                    return defaultVal || defaultCubeMap;
                }

            } else if (image && (
                image instanceof HTMLCanvasElement
                || image instanceof HTMLVideoElement
                || image instanceof HTMLImageElement
                || image instanceof ImageData
                || (hasOffscreenCanvas && image instanceof OffscreenCanvas)
                || image instanceof ImageBitmap
            )) {

                texture = createTexture(texture3js, context);

            } else {

                return defaultVal || defaultTexture;
            }

            this.set(texture3js, texture);
        }

        return texture;
    }

    this.set = function set(texture3js, texture) {
        if (!texture || !texture3js) {
            console.warn('Mesh3D.WebGLTextures:texture3js or texture is empty');
            return;
        }

        texture.version = texture3js.version;
        textures.set(texture3js, texture);

        function disposeCallback() {

            var latestTexture = textures.get(texture3js);
            if (latestTexture !== undefined) {
                if (!latestTexture.isDestroyed || !latestTexture.isDestroyed()) latestTexture.destroy();
                textures.delete(texture3js);
            }

            texture3js.removeEventListener('dispose', disposeCallback);
            disposeCallbacks.delete(texture3js);
        }

        texture3js.addEventListener('dispose', disposeCallback);
        disposeCallbacks.set(texture3js, disposeCallback);
    }

    this.delete = function (texture3js) {

        var disposeCallback = disposeCallbacks.get(texture3js);
        if (disposeCallback) disposeCallback();
    }

    /**
     * 
     * @param {THREE.Texture} texture3js 
     */
    this.addReference = function (texture3js) {
        var reference = textureReferences.get(texture3js) || 0;
        textureReferences.set(texture3js, ++reference);
    }

    /**
     * 
     * @param {THREE.Texture} texture3js 
     */
    this.removeReference = function (texture3js) {
        var reference = textureReferences.get(texture3js)
        if (reference != undefined) {
            reference--;
            if (reference == 0) {
                this.delete(texture3js);
                textureReferences.delete(texture3js)
            } else {
                textureReferences.set(texture3js, reference);
            }
        }
    }

    Object.defineProperties(this, {
        textures: {
            get() {
                return textures;
            }
        },
        textureReferences: {
            get() {
                return textureReferences
            }
        }
    })

    if (typeof THREE == 'undefined') return

    const { formatsMap, typesMap } = ConstantMap;
}

export default WebGLTextures;
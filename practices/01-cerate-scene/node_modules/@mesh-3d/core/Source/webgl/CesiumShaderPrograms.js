
import ShaderUtils from "./ShaderUtils.js";
import MeshVisualizer from '../MeshVisualizer.js';
import WebGLRenderer from './WebGLRenderer.js';
import { unrollLoops } from './WebGLProgram.js'
import WebGLPrograms from './WebGLPrograms.js';
import WebGLLights from "./WebGLLights.js";
import extension_lights_pars from './Shaders/extension_lights_pars.glsl.js';
import extention_lights_fragment_begin from './Shaders/extention_lights_fragment_begin.glsl.js';
let emptyLights = {
    directional: [],
    point: [],
    spot: [],
    rectArea: [],
    hemi: [],

    directionalShadowMap: [],
    pointShadowMap: [],
    spotShadowMap: []
}
 
/**
 * 
 * @param {WebGLRenderer} renderer 
 */
export default function CesiumShaderPrograms(renderer) {
    const visualizer = renderer._visualizer;
    const webglUniforms = renderer._uniforms;
    const properties = renderer._properties;

    const { ShaderSource, ShaderProgram } = Cesium;
  
    /**
     *  
     * @param {{fragmentShader:string,vertexShader:string}} shader 
     */
    function appendExtensionLights(shader) {
        //
        var fixedWebGLLights = visualizer._fixedWebGLLights;
        var partialWebGLLights = visualizer._partialWebGLLights;
        var NUM_STATIC_POINT_LIGHTS = fixedWebGLLights.state.point.length
        var NUM_PAITIAL_POINT_LIGHTS = partialWebGLLights.state.point.length
        if (NUM_STATIC_POINT_LIGHTS > 0 || NUM_PAITIAL_POINT_LIGHTS > 0) {
            var fs = shader.fragmentShader;
            fs = ShaderUtils.insertAfter(
                fs, /uniform vec3 lightProbe\[ 9 \];/g,
                extension_lights_pars
                    .replace(/NUM_STATIC_POINT_LIGHTS/g, NUM_STATIC_POINT_LIGHTS)
                    .replace(/NUM_PAITIAL_POINT_LIGHTS/g, NUM_PAITIAL_POINT_LIGHTS)
            );
            fs = ShaderUtils.insertAfter(
                fs, /IncidentLight directLight;/g,
                extention_lights_fragment_begin
                    .replace(/NUM_STATIC_POINT_LIGHTS/g, NUM_STATIC_POINT_LIGHTS)
                    .replace(/NUM_PAITIAL_POINT_LIGHTS/g, NUM_PAITIAL_POINT_LIGHTS)
            );
            shader.fragmentShader = fs;
        }
    }

    /**
     *  
     * @param {THREE.Mesh|THREE.Line|THREE.LineLoop|THREE.LineSegments|THREE.Points|THREE.Sprite} object   
     * @param {WebGLLights} [lights]
     * @param {THREE.Light[]} [shadows]
     */
    function compileShader3js(material3js, object, lights, shadows) {

        //three version >= 0.119.1

        let scene = visualizer; 
        shadows = shadows || null;

        /**
         * @type {WebGLPrograms}
         * @private
         */
        const programs = renderer._programs;

        var parameters = programs.getParameters(
            material3js, material3js.lightMap ? emptyLights : lights.state, shadows, scene, object
        );
        var uniforms = programs.getUniforms(material3js);
        parameters.uniforms = uniforms;

        if (typeof material3js.onBeforeCompile == 'function') {
            material3js.onBeforeCompile(parameters, renderer);
        }

        if (material3js.isNodeMaterial) {
            uniforms = parameters.uniforms;
            parameters = programs.getParameters(
                material3js, material3js.lightMap ? emptyLights : lights.state, shadows, scene, object
            );
            parameters.uniforms = uniforms;

            //
            var materialProperties = properties.get(material3js)
            materialProperties.needsLights = material3js.lights;
            materialProperties.clipping = material3js.clipping;
        }

        var cacheKey = programs.getProgramCacheKey(parameters);
        var program = renderer._programs.acquireProgram(parameters, cacheKey);
        program.uniforms = parameters.uniforms;
        return program;

    }

    /**
     * 
     * @param {THREE.Material} material 
     * @param {{[key:string]:number}} attributeLocations 
     * @param {THREE.Mesh|THREE.Line|THREE.LineLoop|THREE.LineSegments|THREE.Points|THREE.Sprite} object  
     * @returns {Cesium.ShaderProgram}
     * @private
     */
    this.get = function (material3js, attributeLocations, object, lights, shadows) {

        let context = visualizer.frameState.context;

        var instances = object.instances;

        var shader;
        // var lights = visualizer._lights.state;
        var scene = visualizer;
        // var shadows = visualizer._shadowsArray;

        shader = compileShader3js(material3js, object, lights, shadows);

        ShaderUtils.processInstanceShader(object, shader);

        //TODO:
        //  ShaderUtils.processOcclusionCulling(object, shader);

        let pickIdStr = 'czm_pickColor';
        let pickColorQualifier = instances && instances.length ? 'varying' : (material3js.pickColorQualifier || 'uniform')
        let pickColorDefinition = pickColorQualifier + ' vec4 ' + pickIdStr + ';\n'
        let logDepthExtension =
            '#ifdef GL_EXT_frag_depth \n' +
            '#extension GL_EXT_frag_depth : enable \n' +
            '#endif \n\n';

        shader.vertexShader = '\n\
                #define CESIUM_MESH_VISUALIZER\n\
                uniform vec3 u_cameraPositionLC;\n\
                uniform mat4 matrixWorld;\n\
                uniform mat3 normalMatrixWorld;\n\
                uniform mat4 viewMatrixThree;\n\
                uniform mat4 modelViewMatrixInverse;\n\
                uniform mat4 _CesiumModel2ThreeModel;\n\
                uniform mat3 _CesiumNormal2ThreeNormal;\n\
                uniform mat4 _ThreeModel2CesiumModel;\n\
                uniform mat3 _ThreeNormal2CesiumNormal;\n\
                '  + shader.vertexShader;

        var fs = '\n\
                #define CESIUM_MESH_VISUALIZER\n\
                uniform mat4 matrixWorld;\n\
                uniform mat3 normalMatrixWorld;\n\
                uniform mat4 viewMatrixThree;\n\
                uniform mat4 modelViewMatrixInverse;\n\
                uniform mat4 _CesiumModel2ThreeModel;\n\
                uniform mat3 _CesiumNormal2ThreeNormal;\n\
                uniform mat4 _ThreeModel2CesiumModel;\n\
                uniform mat3 _ThreeNormal2CesiumNormal;\n'+ shader.fragmentShader;
        shader.fragmentShader = fs;
        if (visualizer.useEncodedPosition) {
            ShaderUtils.modifyEncodedPosition(object, shader);
        }
        ShaderUtils.modifyShadowWorldPosition(object, shader);
        ShaderUtils.modifyEnvMapQueryVec(object, shader);

        appendExtensionLights(shader);
        shader.fragmentShader = unrollLoops(shader.fragmentShader)
        //
        if (material3js.onAfterCompile) {
            material3js.onAfterCompile(shader, renderer);
        }

        //
        if (material3js.pickColorQualifier == 'varying') {//&& !material3js.isShaderMaterial) {
            if (shader.vertexShader.indexOf(pickIdStr) == -1) {
                var pickColorName = material3js.pickColorName || 'pickColor';
                shader.vertexShader = ShaderUtils.insertBeforeMain(shader.vertexShader, 'attribute vec4 ' + pickColorName + ';\n' + 'varying vec4 ' + pickIdStr + ';\n')
                shader.vertexShader = ShaderUtils.insertAfterMain(shader.vertexShader, pickIdStr + '=' + pickColorName + ';\n')
            }
        }

        //
        webglUniforms.set(material3js, shader.uniforms, object, lights, shadows);
        //
        var vs = new ShaderSource({
            sources: [shader.vertexShader]
        });
        var fs = new ShaderSource({
            sources: [pickColorDefinition + shader.fragmentShader, logDepthExtension],
        });

        var translucent = material3js.translucent || material3js.transparent;
        if (!translucent && context.fragmentDepth) {
            fs.defines.push('WRITE_DEPTH');
        }

        var shaderProgram = ShaderProgram.fromCache({
            context: context,
            fragmentShaderSource: fs,
            vertexShaderSource: vs,
            attributeLocations: attributeLocations
        });

        return shaderProgram;
    }

}

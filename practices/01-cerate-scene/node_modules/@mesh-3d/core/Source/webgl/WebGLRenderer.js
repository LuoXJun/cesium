import WebGLExtensions from './WebGLExtensions.js';
import WebGLCapabilities from './WebGLCapabilities.js';
import WebGLPrograms from './WebGLPrograms.js';
import RendererUtils from '../RendererUtils.js'
import WebGLMorphtargets from './WebGLMorphtargets.js';
import WebGLShadowMap from './WebGLShadowMap.js';
import CameraUtils from '../CameraUtils.js';
import WebGLProperties from './WebGLProperties.js';
import WebGLClipping from './WebGLClipping.js';
import WebGLCubeMaps from './WebGLCubeMaps.js';
import ConstantMap from './ConstantMap.js';
import WebGLUniforms from './WebGLUniforms.js';
import WebGLMaterials from './WebGLMaterials.js';
import WebGLTextures from './WebGLTextures.js';
import WebGLRenderItems from './WebGLRenderItems.js';
import MeshVisualizer from '../MeshVisualizer.js';
import WebGLRenderStates from './WebGLRenderStates.js';
import WebGLRenderState from './WebGLRenderState.js';
import WebGLRenderTargets from './WebGLRenderTargets.js';
import CesiumRenderStates from './CesiumRenderStates.js';
import CesiumCommands from './CesiumCommands.js';
import CesiumShaderPrograms from './CesiumShaderPrograms.js';
import CesiumVertextArrays from './CesiumVertextArrays.js';


var clearCommandScratch;
/**
 * 实现部分threejs WebGLRenderer接口，支持渲染到THREE.WebGLRenderTarget等功能
 */
class WebGLRenderer {
    /**
     * 
     * @param {MeshVisualizer} visualizer 
     */
    constructor(visualizer) {

        const {
            Camera, Matrix4, RenderState, ClearCommand, Color
        } = Cesium;
        const _THREE = THREE;
        const {
            LinearEncoding, NoToneMapping,
            Matrix3, Vector3
        } = _THREE;


        function CesiumRenderStateCache() {
            var list = new WeakMap();

            this.get = function (drawCommand, camera) {
                var cameras = list.get(drawCommand);
                if (cameras == undefined) {
                    cameras = new WeakMap();
                    list.set(drawCommand, cameras);
                }
                var rs = cameras.get(camera);
                if (rs == undefined) {
                    rs = new RenderState(drawCommand.renderState);
                    cameras.set(camera, rs);
                }
                return rs;
            }

            this.delete = function (drawCommand) {
                list.delete(drawCommand);
            }

            this.dispose = function () {
                list = new WeakMap();
            }

        }

        const scope = this;
        var colorBuffer = {

            setMask: function (colorMask) {

            },

            setLocked: function (lock) {
            },

            setClear: function (r, g, b, a, premultipliedAlpha) {

            },

            reset: function () {

            }

        };


        var depthBuffer = {

            setTest: function (enabled) {

                const gl = getGL()
                const glEnum = gl.DEPTH_TEST;
                if (enabled) {
                    gl.enable(glEnum);
                } else {
                    gl.disable(glEnum);
                }
            },

            setMask: function (depthMask) { },

            setFunc: function (depthFunc) { },

            setLocked: function (lock) { },

            setClear: function (depth) { },

            reset: function () { }

        };


        var stencilBuffer = {

            setTest: function (stencilTest) { },

            setMask: function (stencilMask) { },

            setFunc: function (stencilFunc, stencilRef, stencilMask) { },

            setOp: function (stencilFail, stencilZFail, stencilZPass) { },

            setLocked: function (lock) { },

            setClear: function (stencil) { },

            reset: function () { }

        };

        this.state = {

            buffers: {
                color: colorBuffer,
                depth: depthBuffer,
                stencil: stencilBuffer
            },
            viewport: function (viewport) {
                getGL().viewport(viewport.x, viewport.y, viewport.width, viewport.height);
            }
        }
        function getGL() {
            return scope._capabilities.gl;
        }
        //

        this._visualizer = visualizer;

        //threejs renderer params 
        this.gammaOutput = false;
        this.gammaInput = false;

        this._nClipPlanes = 0;
        this._nClipIntersection = 0;
        this._currentRenderTarget = null;


        // user-defined clipping

        this.clippingPlanes = [];
        this.localClippingEnabled = false;

        // physically based shading

        this.gammaFactor = 2.0;	// for backwards compatibility

        this._outputEncoding = null


        // physical lights

        this._physicallyCorrectLights = false;

        // tone mapping

        this._toneMapping = null;// NoToneMapping;
        this.toneMappingExposure = 1.0;
        this.toneMappingWhitePoint = 1.

        // morphs

        this.maxMorphTargets = 8;
        this.maxMorphNormals = 4;


        this._outputEncoding = LinearEncoding;
        this._toneMapping = NoToneMapping;

        this.vr = {
            enabled: false
        };
        this.xr = {
            enabled: false
        };

        /**
         * @type {WebGLShadowMap}
         */
        this.shadowMap = new WebGLShadowMap(this, null, 16000);

        this._cubemaps = new WebGLCubeMaps(this)

        this._properties = new WebGLProperties();

        this._materials = new WebGLMaterials(this._properties);

        this._textures = new WebGLTextures(visualizer);

        this._uniforms = new WebGLUniforms(this);

        this._cesiumRenderStateCache = new CesiumRenderStateCache()
        this._cesiumRenderStates = new CesiumRenderStates(this)
        this._cesiumShaderPrograms=new CesiumShaderPrograms(this)
        this._cesiumVertextArrays=new CesiumVertextArrays(this)
        this._cesiumCommands = new CesiumCommands(this)

        const webglRenderItems = this._webglRenderItems = new WebGLRenderItems(this);

        this._webglRenderStates = new WebGLRenderStates();


        const webGLRenderTargets = new WebGLRenderTargets(visualizer);

        /**
         * @type {WebGLClipping}
         */
        this._clipping = null;
        /**
         * @type {WebGLPrograms}
         */
        this._programs = null;
        /**
         * @type {WebGLCapabilities}
         */
        this._capabilities = null;
        /**
         * @type {WebGLExtensions}
         */
        this._extensions = null;

        this._pixelRatio = 1.0;

        /**
         * @type {WebGLMorphtargets}
         */
        this.morphtargets = null;

        /**
         * @type {Boolean}
         */
        this.autoClear = true;
        this.autoClearColor = true
        this.autoClearDepth = true
        this.autoClearStencil = true

        this._currentActiveCubeFace = 0;
        this._currentActiveMipmapLevel = 0;

        this.renderState = null;
        this.autoConvertCamera = false;
        this.overrideModelMatrix = null;

        this._clearColor = new _THREE.Color('black')
        this._clearAlpha = 0;
        this.isCesiumRenderer = true;

        this.version = 0;

        // 

        /**
         * 
         * @param {Cesium.FrameState} frameState 
         */
        function init(frameState) {
            var gl = frameState.context._gl

            if (!this._capabilities) {
                const extensions = this._extensions = new WebGLExtensions(gl)
                const capabilities = this._capabilities = new WebGLCapabilities(gl, extensions, {

                });
                if (capabilities.isWebGL2 === false) {

                    extensions.get('WEBGL_depth_texture');
                    extensions.get('OES_texture_float');
                    extensions.get('OES_texture_half_float');
                    extensions.get('OES_texture_half_float_linear');
                    extensions.get('OES_standard_derivatives');
                    extensions.get('OES_element_index_uint');
                    extensions.get('ANGLE_instanced_arrays');

                }
                this.shadowMap.maxTextureSize = capabilities.maxTextureSize;

                extensions.get('OES_texture_float_linear');

                this._clipping = new WebGLClipping(this._properties, this._visualizer);
                this._programs = new WebGLPrograms(this, this._cubemaps, extensions, capabilities, this._clipping);

                this.morphtargets = new WebGLMorphtargets(gl,this);
            }

            this._pixelRatio = frameState.pixelRatio;

            if (!this._frameState) this._frameState = frameState;

        }

        /**
         * 
         * @param {THREE.Object3D|MeshVisualizer} scene  
         * @param {Cesium.Camera|THREE.PerspectiveCamera|THREE.OrthographicCamera} camera
         * @param {Cesium.FrameState} [frameState] 
         */
        function render(scene, camera, frameState) {
            frameState = frameState || this._frameState;
            if (!scene) {
                throw new Error('WebGLRenderer.render:缺少参数scene')
            }
            if (!frameState) {
                throw new Error('WebGLRenderer.render:MeshVisualizer未初始化，需要传递参数frameState')
            }

            /**
             * @type {THREE.WebGLRenderTarget}
             * @private
             */
            let renderTarget = this._currentRenderTarget;
            let visualizer = this._visualizer;

            if (!renderTarget) throw new Error('WebGLRenderer.render:未设置renderTarget')

            if (this.autoClear) {
                this.clear(null, 1, 0);
            }
            const framebuffers = webGLRenderTargets.get(renderTarget);
            const framebuffer = framebuffers[this._currentActiveCubeFace || 0];
            const context = frameState.context;
            const us = context.uniformState
            const globalCamera = frameState.camera;
            const currentCullingVolume = frameState.cullingVolume

            var referenceFrame;
            if (this.autoConvertCamera) {
                referenceFrame = {}
                referenceFrame.matrix = visualizer._actualModelMatrixYup || visualizer.modelMatrix;
                referenceFrame.inverseMatrix = visualizer._actualModelMatrixYupInverse || visualizer._actualModelMatrixInverse;
            }

            let customCamera, camera3js;
            /**
             * @type {THREE.Frustum}
             * @private
             */
            // let frustum3js;
            if (camera && !(camera instanceof Camera)) {

                camera3js = camera;
                if (camera.isPerspectiveCamera) {
                    camera = CameraUtils.fromPerspectiveCamera3js(camera, visualizer._scene, referenceFrame);

                }
                else if (camera.isOrthographicCamera) camera = CameraUtils.fromOrthographicCamera3js(camera, visualizer._scene, referenceFrame);
                else {

                    visualizer.traverseObject3D(scene, (object) => {
                        object.currentFrustumCulled = object.frustumCulled;
                        object.frustumCulled = false;
                        object.modelMatrixNeesUpdate = false;
                    })

                    customCamera = {
                        camera: camera,
                        _normalMatrix: new Matrix3(),
                        cameraPosition: new Vector3()
                    }
                    globalCamera.customCamera = customCamera;
                    // console.warn('unsupport camera ' + camera.type);
                    camera = null;
                    // return
                }

                // if (!referenceFrame && !camera3js._referenceFrame)
                //     frustum3js = CameraUtils.getFrustum3js(camera3js)
            }

            const currenCamera = camera || globalCamera;
            const cemeraChanged = currenCamera != globalCamera
            frameState.camera = currenCamera;

            if (cemeraChanged) {
                us.update(frameState);
                // frameState.cullingVolume = currenCamera.frustum.computeCullingVolume(
                //     currenCamera.position,
                //     currenCamera.direction,
                //     currenCamera.up
                // );
            }

            if (this.overrideModelMatrix) {
                visualizer.traverseObject3D(scene, (object) => {
                    object.currentFrustumCulled = object.frustumCulled;
                    object.frustumCulled = false;
                    object.modelMatrix = Matrix4.multiply(object.matrixWorld.elements, this.overrideModelMatrix, object.modelMatrix || new Matrix4());
                    if (object.up.y) RendererUtils.yUp2Zup(object.modelMatrix, object.modelMatrix)
                    object.modelMatrixNeesUpdate = false;
                })
            }

            //execute drawCommand

            var drawCommands = [];
            visualizer.update(frameState, scene, drawCommands);

            drawCommands.forEach((drawCommand) => {
                //
                if (customCamera) {
                    let object = drawCommand.owner;
                    object = object.mesh3js || object;

                    customCamera.modelMatrix = object.matrixWorld.elements;

                    object.modelViewMatrix.multiplyMatrices(customCamera.camera.matrixWorldInverse, object.matrixWorld);
                    customCamera.modelViewMatrix = object.modelViewMatrix.elements;

                    customCamera.projectionMatrix = customCamera.camera.projectionMatrix.elements;

                    customCamera._normalMatrix.getNormalMatrix(object.modelViewMatrix);
                    customCamera.normalMatrix = customCamera._normalMatrix.elements;

                    customCamera.cameraPosition.setFromMatrixPosition(customCamera.camera.matrixWorld);
                }

                //

                let originalRs = drawCommand.renderState;
                // var rs=this._cesiumRenderStateCache.get(drawCommand,currenCamera);
                /**
                 * @type {Cesium.RenderState}
                 * @private
                 */
                let rs = drawCommand.renderState
                var viewport = renderTarget.viewport;
                rs = Object.assign({}, rs)

                if (this.renderState) {

                    rs = Object.assign(rs, this.renderState)
                    // rs = new RenderState(rs);
                }

                if (viewport) rs.viewport = viewport;

                if (!renderTarget.stencilBuffer) {
                    rs.stencilTest = { enabled: false }
                    // rs.stencilTest.enabled = false
                }
                if (!renderTarget.depthBuffer && !renderTarget.depthTexture) {
                    rs.depthTest = { enabled: false }
                    // rs.depthTest.enabled = false
                }
                if (renderTarget.scissorTest) {
                    var scissor = renderTarget.scissor;
                    rs.scissorTest = {
                        enabled: true,
                        rectangle: { x: scissor.x, y: scissor.y, width: scissor.width, height: scissor.height }
                    }
                    // rs.scissorTest.enabled = true
                    // rs.rectangle = { x: scissor.x, y: scissor.y, width: scissor.width, height: scissor.height }
                } else {
                    // rs.scissorTest.enabled = false
                    rs.scissorTest = {
                        enabled: false
                    }
                }

                rs = new RenderState(rs);

                var oldFramebuffer = drawCommand.framebuffer
                drawCommand.renderState = rs;
                drawCommand.framebuffer = framebuffer;
                drawCommand.execute(context);
                drawCommand.framebuffer = oldFramebuffer;
                drawCommand.renderState = originalRs;

            });

            if (globalCamera.customCamera || this.overrideModelMatrix) {
                visualizer.traverseObject3D(scene, (object) => {
                    object.frustumCulled = object.currentFrustumCulled;
                })
            }

            delete globalCamera.customCamera;
            frameState.camera = globalCamera;

            if (cemeraChanged) {
                frameState.cullingVolume = currentCullingVolume;
                us.update(frameState);
            }

            // console.log('renderToRenderTarget', drawCommands.length);

            drawCommands.length = 0;
        }


        //for shadowMap
        /**
         * 
         * @param {Cesium.Camera|THREE.Camera} camera 
         * @param {THREE.Scene|MeshVisualizer} scene 
         * @param {THREE.BufferGeometry} geometry 
         * @param {THREE.Material} material 
         * @param {THREE.Mesh|THREE.Line|THREE.Points|THREE.Sprite} object 
         * @param {{materialIndex:number,renderItemIndex:number,groupIndex:number}} group 
         * @param {WebGLRenderState} currentWebglRenderState
         * @param {THREE.Camera}camera3js
         * @param {string} [passName] 
         * @param {Cesium.FrameState} [frameState] 
         * @private
         */
        function renderBufferDirect(camera, scene, geometry, material, object, group, currentWebglRenderState, camera3js, passName, frameState) {
            frameState = this._frameState || frameState;

            if (!frameState) {
                throw new Error('WebGLRenderer.renderBufferDirect:MeshVisualizer未初始化，需要传递参数frameState')
            }

            const renderItems = webglRenderItems.get(object, currentWebglRenderState.camera)

            if (!renderItems) return;

            /**
             * @type {THREE.WebGLRenderTarget}
             * @private
             */
            let renderTarget = this._currentRenderTarget;
            let visualizer = this._visualizer, cesScene = visualizer._scene;
            if (!renderTarget) throw new Error('WebGLRenderer.renderBufferDirect:未设置renderTarget')

            if (this.autoClear) this.clear();

            var framebuffers = webGLRenderTargets.get(renderTarget);
            var framebuffer = framebuffers[this._currentActiveCubeFace || 0];

            var context = frameState.context;
            let us = context.uniformState
            var globalCamera = frameState.camera;

            //copy camera
            if (camera && !(camera instanceof Camera)) {
                if (camera.isPerspectiveCamera) camera = CameraUtils.fromPerspectiveCamera3js(camera, null, cesScene);
                else if (camera.isOrthographicCamera) camera = CameraUtils.fromOrthographicCamera3js(camera, null, cesScene);
                else {
                    throw new Error('unsupport camera ' + camera.type);
                }
            }

            //save original camera
            var currenCamera = camera || globalCamera;
            frameState.camera = currenCamera;
            //use new camera
            if (currenCamera !== globalCamera) us.update(frameState);

            //modelMatrix
            if (object.modelMatrixNeesUpdate || object.needsUpdate) {
                visualizer.computeModelMatrix(object, frameState);
            }

            //copy drawCommand
            const renderItemIndex = renderItems.length > 1 ? group.renderItemIndex : 0;
            passName = passName ? passName : ['_renderBufferDirect', material.uuid, geometry.uuid, renderItemIndex].join('_');
            var renderItem = renderItems[renderItemIndex];
            var drawCommand = webglRenderItems.getAndUpdateDerived(object, geometry, material, renderItem, passName, frameState, currentWebglRenderState, camera3js);

            var renerable = !!drawCommand;
            // var _frustum=CameraUtils.getFrustum3js(camera);
            if (renerable && renderItem.frustumCulled) {
                var boundingVolume = renderItem.boundingVolume;
                // var distanceToCamera = Cartesian3.distance(boundingVolume.center, currenCamera.positionWC) //currenCamera.distanceToBoundingSphere(boundingVolume);
                // var range = visualizer._minRange;
                // if (distanceToCamera > 0) range = RendererUtils.computeRange(distanceToCamera, boundingVolume.radius, frameState)
                // if (range < visualizer._minRange) {
                //     debugger
                //     renerable = false;
                // } else {
                // var visibility = frameState.cullingVolume.computeVisibility(boundingVolume)
                // if (visibility == Intersect.OUTSIDE) {
                //     renerable = false;
                // }
                // }
            }

            //render

            if (renerable) {

                var oldRS = drawCommand.renderState;

                const viewport = renderTarget.viewport;

                var rs = this._cesiumRenderStateCache.get(drawCommand, currenCamera);
                // rs = new RenderState(rs)
                rs.depthMask = true;
                rs.depthTest.enabled = true;
                rs.stencilTest.enabled = false;
                rs.blending.enabled = false
                rs.viewport = viewport;
                drawCommand.renderState = rs;

                const gl = context._gl;
                RenderState.apply(gl, rs, context._defaultPassState);

                drawCommand.framebuffer = framebuffer;
                drawCommand.execute(context);
                drawCommand.framebuffer = null;
                drawCommand.renderState = oldRS
            }

            //restore camera
            frameState.camera = globalCamera;
            if (currenCamera !== globalCamera) us.update(frameState);

        }

        function clear(clearColor, depth, stencil) {

            if (!clearCommandScratch) {
                clearCommandScratch = new ClearCommand({
                    color: new Color(0.0, 0.0, 0.0, 0.0)
                });
            }

            if (clearColor) {
                Color.clone(clearColor, clearCommandScratch.color);
            } else {
                Color.clone(Color.TRANSPARENT, clearCommandScratch.color);
            }

            if (this._currentRenderTarget) {

                var framebuffers = webGLRenderTargets.get(this._currentRenderTarget);
                if (!framebuffers) return;

                var framebuffer = framebuffers[this._currentActiveCubeFace || 0];
                if (!framebuffer) return

                var frameState = this._frameState;
                var clearCommand = clearCommandScratch;
                if (typeof depth == 'number') {
                    clearCommand.depth = depth;
                } else {
                    clearCommand.depth = this.autoClearDepth ? 1 : undefined;
                }
                if (typeof stencil == 'number') {
                    clearCommand.stencil = stencil;
                } else {
                    clearCommand.stencil = this.autoClearStencil ? 0 : undefined;
                }

                clearCommand.framebuffer = framebuffer;
                clearCommand.renderState = frameState.context._defaultRenderState;
                clearCommand.execute(frameState.context);
            }
        }


        /**
         * 
         * @param {THREE.WebGLRenderTarget|THREE.WebGLRenderTargetCube} renderTarget 
         * @param {number} [activeCubeFace] 
         */
        function readPixels(renderTarget, activeCubeFace) {

            renderTarget = renderTarget || this._currentRenderTarget;
            activeCubeFace = activeCubeFace || this._currentActiveCubeFace;

            var framebuffers = webGLRenderTargets.get(renderTarget);
            if (!framebuffers) return;
            let framebuffer = framebuffers[activeCubeFace || 0];
            return RendererUtils.readPixels(this._frameState, {
                framebuffer: framebuffer,
                x: 0,
                y: 0,
                width: renderTarget.width,
                height: renderTarget.height
            });
        }

        /**
         * 
         * @param {THREE.WebGLRenderTarget|THREE.WebGLRenderTargetCube} renderTarget 
         * @param {number} [x] 
         * @param {number} [y] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {ArrayBufferView} [buffer] 
         * @param {number} [activeCubeFaceIndex] 
         */
        function readRenderTargetPixels(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
            renderTarget = renderTarget || this._currentRenderTarget;
            activeCubeFaceIndex = activeCubeFaceIndex || this._currentActiveCubeFace;

            var texture = renderTarget.texture
            var framebuffers = webGLRenderTargets.get(renderTarget);
            if (!framebuffers) return;
            let framebuffer = framebuffers[activeCubeFaceIndex || 0];
            return RendererUtils.readPixels(this._frameState, {
                framebuffer: framebuffer,
                x: x || 0,
                y: y || 0,
                width: width || renderTarget.width,
                height: height || renderTarget.height,
                pixelFormat: ConstantMap.formatsMap[texture.format],
                pixelDatatype: ConstantMap.typesMap[texture.type]
            }, buffer);
        }

        function dispose() {
            webglRenderItems.dispose()
            webGLRenderTargets.dispose();
        }

        this.init = init
        this.render = render;
        this.renderBufferDirect = renderBufferDirect;
        this.clear = clear
        this.readPixels = readPixels
        this.readRenderTargetPixels = readRenderTargetPixels;
        this.dispose = dispose;

    }

    get capabilities() { return this._capabilities }
    get extensions() { return this._extensions }

    set needsUpdate(val) { if (val) this.version++; }

    get outputEncoding() { return this._outputEncoding }
    set outputEncoding(val) {
        if (val != this._outputEncoding) {
            this._outputEncoding = val;
            this.needsUpdate = true;
        }
    }

    get toneMapping() { return this._toneMapping }
    set toneMapping(val) {
        if (val != this._toneMapping) {
            this._toneMapping = val;
            this.needsUpdate = true;
        }
    }

    get physicallyCorrectLights() { return this._physicallyCorrectLights }
    set physicallyCorrectLights(val) {
        if (val != this._physicallyCorrectLights) {
            this._physicallyCorrectLights = val;
            this.needsUpdate = true;
        }
    }


    setRenderTarget(renderTarget, activeCubeFace, activeMipmapLevel) {

        this._currentActiveCubeFace = activeCubeFace;
        this._currentActiveMipmapLevel = activeMipmapLevel;

        if (this._currentRenderTarget != renderTarget) {
            this._currentRenderTarget = renderTarget;
        }
    }

    getClearAlpha() {
        return this._clearAlpha
    }
    setClearAlpha(clearAlpha) {
        this._clearAlpha = clearAlpha;
    }

    getClearColor() {
        return this._clearColor;
    }
    setClearColor(clearColor) {
        if (this._clearColor.isColor) {
            this._clearColor.set(clearColor);
        }
        else {
            this._clearColor = clearColor;
        }
    }

    getRenderTarget() {
        return this._currentRenderTarget;
    }

    getActiveCubeFace() {
        return this._currentActiveCubeFace;
    }
    getActiveMipmapLevel() {
        return this._currentActiveMipmapLevel;
    }

    /**
     * @return {WebGLRenderingContext|WebGL2RenderingContext}
     */
    getContext() {
        if (!this._frameState) return;
        return this._frameState.context._gl;
    }

    setPixelRatio(pixelRatio) {
        this._pixelRatio = pixelRatio
    }

    /**
     * 
     * @param {THREE.WebGLRenderer} renderer 
     */
    copy(renderer) {

        this.autoClear = renderer.autoClear;
        this.autoClearColor = renderer.autoClearColor
        this.autoClearDepth = renderer.autoClearDepth
        this.autoClearStencil = renderer.autoClearStencil

        this.shadowMap.enabled = renderer.shadowMap.enabled
        this.shadowMap.type = renderer.shadowMap.type
        this.shadowMap.autoUpdate = renderer.shadowMap.autoUpdate

        // this.gammaFactor=renderer.gammaFactor;
        // this.gammaOutput=renderer.gammaOutput

        this.outputEncoding = renderer.outputEncoding;


        // physical lights

        this.physicallyCorrectLights = renderer.physicallyCorrectLights;

        // tone mapping

        this.toneMapping = renderer.toneMapping;
        this.toneMappingExposure = renderer.toneMappingExposure;
        // this.toneMappingWhitePoint = renderer.toneMappingWhitePoint

        // morphs

        this.maxMorphTargets = renderer.maxMorphTargets;
        this.maxMorphNormals = renderer.maxMorphNormals;

        this.clippingPlanes = renderer.clippingPlanes; // GUI sets it to globalPlanes
        this.localClippingEnabled = renderer.localClippingEnabled;

    }

    //仅保留定义，部分外部依赖可能会调用这些函数
    compile(scene, camera) { }
    setSize() { }
    clearDepth() { }

}

export default WebGLRenderer;

import WebGLRenderItem from "./WebGLRenderItem.js";

function painterSortStable(a, b) {

    if (a.groupOrder !== b.groupOrder) {

        return a.groupOrder - b.groupOrder;

    } else if (a.renderOrder !== b.renderOrder) {

        return a.renderOrder - b.renderOrder;

    }
    else if (a.material.id !== b.material.id) {

        return a.material.id - b.material.id;

    } else if (a.z !== b.z) {

        return a.z - b.z;

    } else {

        return a.id - b.id;

    }

}

function reversePainterSortStable(a, b) {

    if (a.groupOrder !== b.groupOrder) {

        return a.groupOrder - b.groupOrder;

    } else if (a.renderOrder !== b.renderOrder) {

        return a.renderOrder - b.renderOrder;

    } else if (a.z !== b.z) {

        return b.z - a.z;

    } else {

        return a.id - b.id;

    }

}


function WebGLRenderList() {

    /**
     * @type {WebGLRenderItem[]}
     * @private
     */
    const environment = []
    /**
     * @type {WebGLRenderItem[]}
     * @private
     */
    const opaque = [];
    /**
     * @type {WebGLRenderItem[]}
     * @private
     */
    const transparent = [];

    function init() {

        environment.length = 0;
        opaque.length = 0;
        transparent.length = 0;

    }

    function push(renderItem) {

        if (renderItem.pass == Cesium.Pass.ENVIRONMENT) environment.push(renderItem)
        else {
            const material = renderItem.material;
            (material.transparent === true || material.translucent ? transparent : opaque).push(renderItem);
        }
    }

    function unshift(renderItem) {
        if (renderItem.pass == Cesium.Pass.ENVIRONMENT) environment.unshift(renderItem)
        else {
            const material = renderItem.material;
            (material.transparent === true || material.translucent ? transparent : opaque).unshift(renderItem);
        }
    }

    function sort(customOpaqueSort, customTransparentSort) {

        if (environment.length > 1) environment.sort(customOpaqueSort || painterSortStable);
        if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
        if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);

    }

    function shouldRender(renderItem, frameState) {
        var { object, material } = renderItem;
        if (frameState.passes.pick && object.allowPick == false) return false
        return object.visible && material.visible;
    }

    function getDrawCommands(commandList, frameState) {

        for (let i = 0, l = environment.length; i < l; i++) {
            if (!shouldRender(environment[i], frameState)) continue;
            commandList.push(environment[i].drawCommand)
        }
        for (let i = 0, l = opaque.length; i < l; i++) {
            if (!shouldRender(opaque[i], frameState))
                continue
            commandList.push(opaque[i].drawCommand)
        }
        for (let i = 0, l = transparent.length; i < l; i++) {
            if (!shouldRender(transparent[i], frameState))
                continue;
            commandList.push(transparent[i].drawCommand)
        }
    }

    function setCurrentScene(currentScene, currentCamera) {

        for (let i = 0, l = environment.length; i < l; i++) {
            environment[i].currentScene = currentScene
            environment[i].currentCamera = currentCamera
        }
        for (let i = 0, l = opaque.length; i < l; i++) {
            opaque[i].currentScene = currentScene;
            opaque[i].currentCamera = currentCamera
        }
        for (let i = 0, l = transparent.length; i < l; i++) {
            transparent[i].currentScene = currentScene;
            transparent[i].currentCamera = currentCamera
        }
    }

    this.environment = environment;
    this.opaque = opaque;
    this.transparent = transparent;

    this.init = init;
    this.push = push;
    this.unshift = unshift;

    this.sort = sort;

    this.getDrawCommands = getDrawCommands
    this.setCurrentScene = setCurrentScene;

}

export default WebGLRenderList;
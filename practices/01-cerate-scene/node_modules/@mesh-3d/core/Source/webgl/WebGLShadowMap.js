
import CameraUtils from '../CameraUtils.js';
import MeshVisualizer from '../MeshVisualizer.js';
import WebGLGeometries from './WebGLGeometries.js';
// import vsm_frag from '../Shaders/vsm_frag.glsl.js';
// import vsm_vert from '../Shaders/vsm_vert.glsl.js';
import WebGLRenderer from './WebGLRenderer.js'


var vsm_frag = "uniform sampler2D shadow_pass;\n\
uniform vec2 resolution;\n\
uniform float radius;\n\
#include <packing>\n\
void main() {\n\
	float mean = 0.0;\n\
	float squared_mean = 0.0;\n\
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\
	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\
		#ifdef HORIZONAL_PASS\n\
		vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\
		mean += distribution.x;\n\
		squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\
		#else\n\
		float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\
		mean += depth;\n\
		squared_mean += depth * depth;\n\
		#endif\n\
	}\n\
	mean = mean * HALF_SAMPLE_RATE;\n\
	squared_mean = squared_mean * HALF_SAMPLE_RATE;\n\
	float std_dev = sqrt( squared_mean - mean * mean );\n\
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n\
}";
var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
/**
 * 
 * @param {WebGLRenderer} _renderer 
 * @param {*} _objects 
 * @param {number} maxTextureSize 
 */
function WebGLShadowMap(_renderer, _objects, maxTextureSize) {

	this.enabled = false;
	this.autoUpdate = true;
	this.needsUpdate = false;
	this.initialized = false;
	if (typeof THREE == 'undefined') {
		this.render = function () { }
		return;
	}

	let { FrontSide, BackSide, DoubleSide, RGBAFormat, NearestFilter, LinearFilter, PCFShadowMap, VSMShadowMap, RGBADepthPacking, NoBlending,
		WebGLRenderTarget,
		MeshDepthMaterial,
		MeshDistanceMaterial,
		ShaderMaterial,
		BufferAttribute,
		BufferGeometry,
		Mesh,
		Vector4,
		Vector2,
		Frustum
	} = THREE;

	let _frustum = new Frustum();

	const _shadowMapSize = new Vector2(),
		_viewportSize = new Vector2(),

		_viewport = new Vector4(),

		_depthMaterials = [],
		_distanceMaterials = [],

		_materialCache = {};

	const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

	const shadowMaterialVertical = new ShaderMaterial({

		defines: {
			SAMPLE_RATE: 2.0 / 8.0,
			HALF_SAMPLE_RATE: 1.0 / 8.0
		},

		uniforms: {
			shadow_pass: { value: null },
			resolution: { value: new Vector2() },
			radius: { value: 4.0 }
		},

		vertexShader: vsm_vert,

		fragmentShader: vsm_frag

	});
	shadowMaterialVertical.autoRefresh = true

	const shadowMaterialHorizonal = shadowMaterialVertical.clone();
	shadowMaterialHorizonal.defines.HORIZONAL_PASS = 1;
	shadowMaterialHorizonal.autoRefresh = true;

	const fullScreenTri = new BufferGeometry();
	var setAttributeFun = fullScreenTri.setAttribute ? 'setAttribute' : 'addAttribute';
	fullScreenTri[setAttributeFun](
		"position",
		new BufferAttribute(
			new Float32Array([- 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5]),
			3
		)
	);

	const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);

	const scope = this;


	Object.defineProperty(this, 'maxTextureSize', {
		get() { return maxTextureSize },
		set(val) {
			maxTextureSize = val;
		}
	})

	let _type = PCFShadowMap, mapVersion = 0;
	Object.defineProperties(this, {
		mapNeedsUpdate: {
			set(val) {
				if (val) mapVersion++;
			}
		},
		type: {
			get() {
				return _type
			},
			set(val) {
				if (val != _type) {
					_type = val;
					this.mapNeedsUpdate = true;
				}
			}
		}
	})

	var shadowMapRenderState, shadowMapRenderStateOpts = {
		blending: {
			enabled: false
		},
		scissorTest: {
			enabled: false
		},
		depthTest: {
			enabled: true
		},
		depthMask: true,
		colorMask: {
			red: true,
			green: true,
			blue: true,
			alpha: true
		},
		stencilTest: {
			enabled: false
		}
	}

	try {
		shadowMapRenderState = new Cesium.RenderState(shadowMapRenderStateOpts);
	} catch (err) {
		shadowMapRenderState.lineWidth = 0
		shadowMapRenderState =new Cesium.RenderState(shadowMapRenderStateOpts);
	}
	
	/**
	 * 
	 * @param {*} lights 
	 * @param {*} scene 
	 * @param {Cesium.FrameState} frameState 
	 * @param {MeshVisualizer} visualizer 
	 */
	this.render = function (lights, scene, frameState, visualizer) {

		// if (scope.enabled === false) return;
		if (scope.autoUpdate === false && scope.needsUpdate === false) return;

		if (lights.length === 0) return;
		lights = lights.slice();

		const uniformState = frameState.context.uniformState;
		const camera = frameState.camera;
		const currentCullingVolume = frameState.cullingVolume;

		const currentWebglRenderState = _renderer._webglRenderStates.get(scene, camera);
		const currentRenderTarget = _renderer.getRenderTarget();
		const activeCubeFace = _renderer.getActiveCubeFace();
		const activeMipmapLevel = _renderer.getActiveMipmapLevel();
		const autoClear = _renderer.autoClear;
		const currentRenderState = _renderer.renderState;
		_renderer.autoClear = false;
		/**
		 * @type {Cesium.RenderState}
		 */
		const renderState = shadowMapRenderState;
		_renderer.renderState = renderState;

		//camera reference frame
		let _referenceFrame = this._referenceFrame || {};

		this._referenceFrame = _referenceFrame;
		_referenceFrame.matrix = visualizer._actualModelMatrixYup || visualizer.modelMatrix;
		_referenceFrame.inverseMatrix = visualizer._actualModelMatrixYupInverse || visualizer._actualModelMatrixInverse;

		// render depth map

		for (let i = 0, il = lights.length; i < il; i++) {

			const light = lights[i];
			const shadow = light.shadow;
			let shadowCameraCesium, shadowCamera = shadow.camera;

			if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;

			if (shadow === undefined) {

				console.warn('Mesh3D.WebGLShadowMap:', light, 'has no shadow.');
				continue;

			}
			if (!shadowCamera.isPerspectiveCamera && !shadowCamera.isOrthographicCamera) {
				console.warn('Mesh3D.WebGLShadowMap:', light, 'camera is not supported.');
				continue;
			}

			_shadowMapSize.copy(shadow.mapSize);

			const shadowFrameExtents = shadow.getFrameExtents();

			_shadowMapSize.multiply(shadowFrameExtents);

			_viewportSize.copy(shadow.mapSize);

			if (_shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize) {

				if (_shadowMapSize.x > maxTextureSize) {

					_viewportSize.x = Math.floor(maxTextureSize / shadowFrameExtents.x);
					_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
					shadow.mapSize.x = _viewportSize.x;

				}

				if (_shadowMapSize.y > maxTextureSize) {

					_viewportSize.y = Math.floor(maxTextureSize / shadowFrameExtents.y);
					_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
					shadow.mapSize.y = _viewportSize.y;

				}

			}

			//TODO:处理阴影贴图尺寸变化的情况
			// // if (shadow.map && (shadow.map.width != _viewport.width || shadow.map.height != _viewport.height)) {
			// if (shadow.map && (shadow.mapSize.x != _viewport.width || shadow.mapSize.y != _viewport.height)) {
			// 	if (shadow.mapPass) {
			// 		shadow.mapPass.texture.dispose();
			// 		shadow.mapPass.dispose()
			// 		shadow.mapPass = null;
			// 	}
			// 	shadow.map.dispose()
			// 	shadow.map.texture.dispose();
			// 	shadow.map = null;
			// }

			/*<<阴影类型type变化时更新阴影贴图 */
			var mapNeedsUpdate = shadow.__mapVersion != mapVersion;
			if (mapNeedsUpdate) {
				if (shadow.mapPass) {
					shadow.mapPass.texture.dispose();
					shadow.mapPass.dispose()
					shadow.mapPass = null;
				}
				if (shadow.map) {
					shadow.map.dispose()
					shadow.map.texture.dispose();
					shadow.map = null;
				}
				shadow.__mapVersion = mapVersion;
			}
			/*阴影类型type变化时更新阴影贴图>> */

			if (this.type !== VSMShadowMap && shadow.mapPass) {
				if (shadow.map) {
					shadow.map.texture.dispose();
					shadow.map.dispose()
					shadow.map = null;
				}
				shadow.mapPass.dispose()
				shadow.mapPass.texture.dispose();
				shadow.mapPass = null;
			}

			if (shadow.mapPass === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {

				if (shadow.map) {
					shadow.map.texture.dispose();
					shadow.map.dispose()
				}

				const pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat, stencilBuffer: false };

				shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
				shadow.map.texture.name = light.name + ".shadowMap";

				shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);

				shadow.camera.updateProjectionMatrix();

			}

			if (shadow.map === null) {

				const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat, stencilBuffer: false };

				shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
				shadow.map.texture.name = light.name + ".shadowMap";

				shadow.camera.updateProjectionMatrix();

			}

			_renderer.setRenderTarget(shadow.map);
			_renderer.clear(Cesium.Color.WHITE, 1, 0)

			if (this.enabled) {

				const viewportCount = shadow.getViewportCount();
				for (let vp = 0; vp < viewportCount; vp++) {

					const viewport = shadow.getViewport(vp);

					_viewport.set(
						_viewportSize.x * viewport.x,
						_viewportSize.y * viewport.y,
						_viewportSize.x * viewport.z,
						_viewportSize.y * viewport.w
					);

					let currentViewport = shadow.map.viewport;
					shadow.map.viewport = _viewport;

					shadow.updateMatrices(light, vp);

					if (shadow.camera.isPerspectiveCamera) shadowCameraCesium = CameraUtils.fromPerspectiveCamera3js(shadowCamera, visualizer._scene, _referenceFrame)
					else if (shadow.camera.isOrthographicCamera) shadowCameraCesium = CameraUtils.fromOrthographicCamera3js(shadowCamera, visualizer._scene, _referenceFrame)

					_frustum = shadow.getFrustum();

					//

					frameState.camera = shadowCameraCesium;
					uniformState.update(frameState);
					// frameState.cullingVolume = shadowCameraCesium.frustum.computeCullingVolume(
					// 	shadowCameraCesium.position,
					// 	shadowCameraCesium.direction,
					// 	shadowCameraCesium.up
					// );

					//

					// const currentWebglRenderState = visualizer.getAndUpdateRenderState(scene, frameState, shadowCamera);

					renderState.viewport = _viewport;
					currentWebglRenderState.renderables.forEach(object => {
						renderObject(object, camera, shadowCameraCesium, light, this.type, false, currentWebglRenderState, shadow.camera);
					});

					frameState.camera = camera;
					frameState.cullingVolume = currentCullingVolume;
					uniformState.update(frameState);

					shadow.map.viewport = currentViewport;
					shadow.camera._referenceFrame = null;
				}

				// do blur pass for VSM

				if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {

					VSMPass(shadow, camera);

				}

				shadow.needsUpdate = false;

				if (shadow.onCameraChanged) {
					shadow.onCameraChanged(shadow.map)
				}
			}

		}

		_renderer.renderState = currentRenderState;
		_renderer.autoClear = autoClear;

		scope.needsUpdate = false;

		_renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);

	};

	//<<2020.10.23
	let VSMPassObjects = new WeakMap();
	/**
	 * 
	 * @param {THREE.Geometry|THREE.BufferGeometry} geometry 
	 * @param {THREE.Material} material 
	 */
	function getVSMPassMesh(geometry, material) {
		let objects = VSMPassObjects.get(geometry)
		if (objects === undefined) {
			objects = new WeakMap()
			VSMPassObjects.set(geometry, objects)
			geometry.addEventListener('dispose', function () {
				VSMPassObjects.delete(geometry);
			});
		}
		var object = objects.get(material)
		if (object == undefined) {
			object = new Mesh(geometry, material);
			material.addEventListener('dispose', function () {
				objects.delete(material);
			});
			objects.set(material, object);
		}

		return object;
	}
	//>>2020.10.23

	function VSMPass(shadow, camera) {

		const Color = Cesium.Color;
		const geometry = fullScreenMesh.geometry;
		//orig:
		// const geometry = _objects.update(fullScreenMesh);

		// vertical pass

		shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
		shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialVertical.uniforms.radius.value = shadow.radius;

		_renderer.renderState.depthTest.enabled = false;
		_renderer.renderState.depthMask = false;
		_renderer.shadowMap.enabled = false;

		_renderer.setRenderTarget(shadow.mapPass);
		_renderer.clear(Color.WHITE, 1, 0);

		//orig:
		// _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);

		//<<2020.10.23
		let vsmMesh = getVSMPassMesh(geometry, shadowMaterialVertical);
		vsmMesh.frustumCulled = false;
		_renderer.render(vsmMesh, camera);
		//>>2020.10.23

		// horizonal pass

		shadowMaterialHorizonal.uniforms.shadow_pass.value = shadow.mapPass.texture;
		shadowMaterialHorizonal.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialHorizonal.uniforms.radius.value = shadow.radius;
		_renderer.setRenderTarget(shadow.map);
		_renderer.clear(Color.WHITE, 1, 0);

		//<<2020.10.23
		vsmMesh = getVSMPassMesh(geometry, shadowMaterialHorizonal);
		vsmMesh.frustumCulled = false;
		_renderer.render(vsmMesh, camera);
		//>>2020.10.23
		_renderer.shadowMap.enabled = true;
		_renderer.renderState.depthTest.enabled = true;
		_renderer.renderState.depthMask = true;

		//orig:
		// _renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizonal, fullScreenMesh, null );

	}

	function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {

		const index = useMorphing << 0 //| useSkinning << 1 | useInstancing << 2;

		let material = _depthMaterials[index];

		if (material === undefined) {

			material = new MeshDepthMaterial({

				depthPacking: RGBADepthPacking,

				morphTargets: useMorphing,
				// skinning: useSkinning,

				//
				// depthTest: true,
				// depthWrite: true,
				// blending: NoBlending,
				// stencilWrite: false
			});

			_depthMaterials[index] = material;

		}

		return material;

	}

	function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {

		const index = useMorphing << 0 //| useSkinning << 1 | useInstancing << 2;

		let material = _distanceMaterials[index];

		if (material === undefined) {

			material = new MeshDistanceMaterial({

				morphTargets: useMorphing,
				// skinning: useSkinning

				//
				// , depthTest: true,
				// depthWrite: true,
				// blending: NoBlending,
				// stencilWrite: false
			});

			_distanceMaterials[index] = material;

		}

		return material;

	}

	function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {

		let result = null;

		let getMaterialVariant = getDepthMaterialVariant;
		let customMaterial = object.customDepthMaterial;

		if (light.isPointLight === true) {

			getMaterialVariant = getDistanceMaterialVariant;
			customMaterial = object.customDistanceMaterial;

		}

		if (customMaterial === undefined) {

			let useMorphing = false;

			if (material.morphTargets === true) {

				useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

			}

			let useSkinning = false;

			/*three.js<1.3
			if (object.isSkinnedMesh === true) {

				if (material.skinning === true) {

					useSkinning = true;

				} else {

					console.warn('Mesh3D.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);

				}

			}*/

			const useInstancing = object.isInstancedMesh === true;

			result = getMaterialVariant(useMorphing, useSkinning, useInstancing);

		} else {

			result = customMaterial;

		}

		if (_renderer.localClippingEnabled &&
			material.clipShadows === true &&
			material.clippingPlanes.length !== 0) {

			// in this case we need a unique material instance reflecting the
			// appropriate state

			const keyA = result.uuid, keyB = material.uuid;

			let materialsForVariant = _materialCache[keyA];

			if (materialsForVariant === undefined) {

				materialsForVariant = {};
				_materialCache[keyA] = materialsForVariant;

			}

			let cachedMaterial = materialsForVariant[keyB];

			if (cachedMaterial === undefined) {

				cachedMaterial = result.clone();
				materialsForVariant[keyB] = cachedMaterial;

			}

			result = cachedMaterial;

		}

		result.visible = material.visible;
		result.wireframe = material.wireframe;

		if (type === VSMShadowMap) {

			result.side = (material.shadowSide !== null) ? material.shadowSide : material.side;

		} else {
			result.side = (material.shadowSide !== null) ? material.shadowSide : shadowSide[material.side];
		}

		result.clipShadows = material.clipShadows;
		result.clippingPlanes = material.clippingPlanes;
		result.clipIntersection = material.clipIntersection;

		result.wireframeLinewidth = material.wireframeLinewidth;
		result.linewidth = material.linewidth;

		if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
			result.referencePosition.setFromMatrixPosition(light.matrixWorld);
			result.nearDistance = shadowCameraNear;
			result.farDistance = shadowCameraFar;
		}
		//for WebGLUinforms,WebGLRenderItems
		result._isShadowDepthMaterial = true

		return result;

	}

	const shadowMapRenderPassName = 'shadowMap';
	function renderObject(object, camera, shadowCamera, light, type, recursive, currentWebglRenderState, shadowCamera3js) {

		if (object.visible === false) return;

		const visible = !object.layers || !camera.layers || object.layers.test(camera.layers);

		if (visible && (object.isMesh || object.isLine || object.isPoints)) {

			if ((object.castShadow || (object.receiveShadow && type === VSMShadowMap))) {//} && (!object.frustumCulled || _frustum.intersectsObject(object))) {

				if (
					//light.name != "sunLight" &&
					object.frustumCulled && !_frustum.intersectsObject(object)) {
					return
				}

				// object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);

				//orig:
				// const geometry = _objects.update(object);

				let geometry = WebGLGeometries.get(object.geometry, object.material);

				const material = object.material;

				if (Array.isArray(material)) {

					var groupsOptimized = geometry.groupsOptimized

					for (let renderItemIndex = 0; renderItemIndex < groupsOptimized.length; renderItemIndex++) {

						const { materialIndex, groupIndex } = groupsOptimized[renderItemIndex];

						const groupMaterial = material[materialIndex];

						if (groupMaterial.visible) {

							const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera3js.near, shadowCamera3js.far, type);
							_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, { materialIndex, groupIndex, renderItemIndex }, currentWebglRenderState, shadowCamera3js, shadowMapRenderPassName + light.uuid);

						}
					}


				} else if (material.visible) {

					const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera3js.near, shadowCamera3js.far, type);

					_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null, currentWebglRenderState, shadowCamera3js, shadowMapRenderPassName + light.uuid);

				}

			}

		}

		const children = object.children;
		if (recursive == false || !children) return

		for (let i = 0, l = children.length; i < l; i++) {

			renderObject(children[i], camera, shadowCamera, light, type, recursive, currentWebglRenderState, shadowCamera3js);

		}

	}

}

export default WebGLShadowMap;

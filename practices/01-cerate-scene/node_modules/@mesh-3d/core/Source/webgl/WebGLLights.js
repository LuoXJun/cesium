/**
 * 改造threejs WebGLLights
 */

function WebGLLights() {

    const {
        Matrix4, Matrix3, Cartesian3, Color, Texture, PixelDatatype, PixelFormat
    } = Cesium;

    var cache = new UniformsCache();
    var shadowCache = new ShadowUniformsCache();

    var extensionState = {
        point: {
            positions: [],
            colors: [],
            decalDists: [],
            visibles: [],
            map: null, array: null
        }
    }
    var state = {

        version: 0,

        hash: {
            directionalLength: - 1,
            pointLength: - 1,
            spotLength: - 1,
            rectAreaLength: - 1,
            hemiLength: - 1,

            numDirectionalShadows: - 1,
            numPointShadows: - 1,
            numSpotShadows: - 1,
        },

        ambient: new Color(0, 0, 0, 1),
        /**
         * @type {Cesium.Cartesian3}
         * @private
         */
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadow: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        rectArea: [],
        /**
         * @type {{
         * position:Cesium.Cartesian3,
         * color:Cesium.Color,
         * distance:number,
         * decay:number
         * }[]}
         */
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],

        numDirectionalShadows: - 1,
        numPointShadows: - 1,
        numSpotShadows: - 1

    };

    for (var i = 0; i < 9; i++) state.probe.push(new Cartesian3());

    var vector3 = new Cartesian3();
    var matrix4 = new Matrix4();
    var matrix42 = new Matrix4();
    var matrix3 = new Matrix3();

    /**
     * 
     * @param {Light[]} lights 
     * @param {*} shadows 
     * @param {Cesium.Camera} camera 
     * @param {Cesium.FrameState}frameState
     * @private
     */
    function setup(lights, shadows, camera, frameState) {

        var r = 0, g = 0, b = 0;

        for (var i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);

        var directionalLength = 0;
        var pointLength = 0;
        var spotLength = 0;
        var rectAreaLength = 0;
        var hemiLength = 0;

        var numDirectionalShadows = 0;
        var numPointShadows = 0;
        var numSpotShadows = 0;

        var viewMatrix = camera.viewMatrix// camera.matrixWorldInverse;

        lights.sort(shadowCastingLightsFirst);

        extensionState.point.positions.length = 0
        extensionState.point.colors.length =
            extensionState.point.decalDists.length = 0

        for (var i = 0, l = lights.length; i < l; i++) {

            var light = lights[i];

            var color = light.color;//getColor(light.color);
            var intensity = light.intensity;
            var distance = light.distance;

            var shadowMap = (light.shadow && light.shadow.map) ? light.shadow.map.texture : null;

            if (light.isAmbientLight) {

                r += color.red * intensity;
                g += color.green * intensity;
                b += color.blue * intensity;

            } else if (light.isLightProbe) {//未处理

                for (var j = 0; j < 9; j++) {

                    // state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
                    // Cartesian3.add(
                    //     state.probe[j],
                    //     Cartesian3.multiplyByScalar(light.sh.coefficients[j],
                    //         intensity, state.probe[j]));

                    state.probe[j].x = light.sh.coefficients[j].x * intensity
                    state.probe[j].y = light.sh.coefficients[j].y * intensity
                    state.probe[j].z = light.sh.coefficients[j].z * intensity
                }

            } else if (light.isDirectionalLight) {

                var uniforms = cache.get(light);

                Color.multiplyByScalar(color, intensity, uniforms.color); //uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                Matrix4.getTranslation(light.modelMatrix, uniforms.direction);// uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                Matrix4.getTranslation(light.target.modelMatrix, vector3); //vector3.setFromMatrixPosition(light.target.matrixWorld);
                Cartesian3.subtract(uniforms.direction, vector3, uniforms.direction); //uniforms.direction.sub(vector3);
                transformDirection(uniforms.direction, viewMatrix);// Cesium.Matrix4.multiplyByPoint(viewMatrix, uniforms.direction, uniforms.direction); //uniforms.direction.transformDirection(viewMatrix);

                uniforms.shadow = light.castShadow;

                if (light.castShadow) {

                    const shadow = light.shadow;

                    const shadowUniforms = shadowCache.get(light);

                    shadowUniforms.shadowBias = shadow.bias;
                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                    shadowUniforms.shadowRadius = shadow.radius;
                    shadowUniforms.shadowMapSize = shadow.mapSize;

                    state.directionalShadow[directionalLength] = shadowUniforms;
                    state.directionalShadowMap[directionalLength] = shadowMap;
                    let shadowMatrix = light.shadow.matrix
                    state.directionalShadowMatrix[directionalLength] = Matrix4.clone(shadowMatrix.elements || shadowMatrix, state.directionalShadowMatrix[directionalLength]);

                    numDirectionalShadows++;

                }

                state.directional[directionalLength] = uniforms;

                directionalLength++;

            } else if (light.isSpotLight) {

                var uniforms = cache.get(light);

                Matrix4.getTranslation(light.modelMatrix, uniforms.position); //uniforms.position.setFromMatrixPosition(light.matrixWorld);
                Matrix4.multiplyByPoint(viewMatrix, uniforms.position, uniforms.position); //uniforms.position.applyMatrix4(viewMatrix);

                Color.multiplyByScalar(color, intensity, uniforms.color);//uniforms.color.copy(color).multiplyScalar(intensity);
                uniforms.distance = distance;

                // uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                // vector3.setFromMatrixPosition(light.target.matrixWorld);
                // uniforms.direction.sub(vector3);
                // uniforms.direction.transformDirection(viewMatrix);

                Matrix4.getTranslation(light.modelMatrix, uniforms.direction);// uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                Matrix4.getTranslation(light.target.modelMatrix, vector3); //vector3.setFromMatrixPosition(light.target.matrixWorld);
                Cartesian3.subtract(uniforms.direction, vector3, uniforms.direction); //uniforms.direction.sub(vector3);

                transformDirection(uniforms.direction, viewMatrix); //Cesium.Matrix4.multiplyByPoint(viewMatrix, uniforms.direction, uniforms.direction); //uniforms.direction.transformDirection(viewMatrix);

                uniforms.coneCos = Math.cos(light.angle);
                uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                uniforms.decay = light.decay;

                uniforms.shadow = light.castShadow;

                if (light.castShadow) {//未处理

                    const shadow = light.shadow;

                    const shadowUniforms = shadowCache.get(light);

                    shadowUniforms.shadowBias = shadow.bias;
                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                    shadowUniforms.shadowRadius = shadow.radius;
                    shadowUniforms.shadowMapSize = shadow.mapSize;

                    state.spotShadow[spotLength] = shadowUniforms;
                    state.spotShadowMap[spotLength] = shadowMap;

                    let shadowMatrix = light.shadow.matrix
                    state.spotShadowMatrix[spotLength] = Matrix4.clone(shadowMatrix.elements || shadowMatrix, state.spotShadowMatrix[spotLength]);

                    numSpotShadows++;
                }

                state.spot[spotLength] = uniforms;

                spotLength++;

            } else if (light.isRectAreaLight) {

                var uniforms = cache.get(light);

                // (a) intensity is the total visible light emitted
                //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

                // (b) intensity is the brightness of the light
                Color.multiplyByScalar(color, intensity, uniforms.color);//uniforms.color.copy(color).multiplyScalar(intensity);

                Matrix4.getTranslation(light.modelMatrix, uniforms.position);//uniforms.position.setFromMatrixPosition(light.matrixWorld);
                Matrix4.multiplyByPoint(viewMatrix, uniforms.position, uniforms.position);//uniforms.position.applyMatrix4(viewMatrix);

                // extract local rotation of light to derive width/height half vectors
                Matrix4.IDENTITY.clone(matrix42);  //matrix42.identity();
                Matrix4.clone(light.modelMatrix, matrix4);//matrix4.copy(light.matrixWorld);
                Matrix4.multiply(viewMatrix, matrix4, matrix4);//matrix4.premultiply(viewMatrix);
                Matrix4.multiplyByMatrix3(matrix42, Matrix4.getMatrix3(matrix4, matrix3), matrix42); //matrix42.extractRotation(matrix4);  


                Cartesian3.fromElements(light.width * 0.5, 0.0, 0.0, uniforms.halfWidth);//uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
                Cartesian3.fromElements(0.0, light.height * 0.5, 0.0, uniforms.halfHeight);//uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);

                Matrix4.multiplyByPoint(matrix42, uniforms.halfWidth, uniforms.halfWidth);//uniforms.halfWidth.applyMatrix4(matrix42);
                Matrix4.multiplyByPoint(matrix42, uniforms.halfHeight, uniforms.halfHeight);//uniforms.halfHeight.applyMatrix4(matrix42);

                // TODO (abelnation): RectAreaLight distance?
                // uniforms.distance = distance;

                state.rectArea[rectAreaLength] = uniforms;

                rectAreaLength++;

            } else if (light.isPointLight) {

                var uniforms = cache.get(light);

                Matrix4.getTranslation(light.modelMatrix, uniforms.position); //uniforms.position.setFromMatrixPosition(light.matrixWorld);
                Matrix4.multiplyByPoint(viewMatrix, uniforms.position, uniforms.position); //uniforms.position.applyMatrix4(viewMatrix);

                // uniforms.position.setFromMatrixPosition(light.matrixWorld);
                // uniforms.position.applyMatrix4(viewMatrix);

                Color.multiplyByScalar(color, intensity, uniforms.color); //uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                uniforms.distance = light.distance;
                uniforms.decay = light.decay;

                uniforms.shadow = light.castShadow;
                uniforms.visible = light._exVisible ? 1 : 0;

                var extension = extensionState.point;
                extension.positions[pointLength] = uniforms.position
                extension.colors[pointLength] = uniforms.color
                extension.decalDists[pointLength] = uniforms.decalDist
                uniforms.decalDist.x = light.decay;
                uniforms.decalDist.y = light.distance;
                extension.visibles[pointLength] = uniforms.visible;

                if (light.castShadow) {

                    var shadow = light.shadow;

                    const shadowUniforms = shadowCache.get(light);

                    shadowUniforms.shadowBias = shadow.bias;
                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                    shadowUniforms.shadowRadius = shadow.radius;
                    shadowUniforms.shadowMapSize.copy(shadow.mapSize);
                    shadowUniforms.shadowCameraNear = shadow.camera.near;
                    shadowUniforms.shadowCameraFar = shadow.camera.far;

                    state.pointShadow[pointLength] = shadowUniforms;
                    state.pointShadowMap[pointLength] = shadowMap;

                    let shadowMatrix = light.shadow.matrix
                    state.pointShadowMatrix[pointLength] = Matrix4.clone(shadowMatrix.elements || shadowMatrix, state.pointShadowMatrix[pointLength]);

                    numPointShadows++;

                }

                state.point[pointLength] = uniforms;

                pointLength++;

            } else if (light.isHemisphereLight) {

                var uniforms = cache.get(light);

                Matrix4.getTranslation(light.modelMatrix, uniforms.direction); //uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                transformDirection(uniforms.direction, viewMatrix);//uniforms.direction.transformDirection(viewMatrix);
                Cartesian3.normalize(uniforms.direction, uniforms.direction);// uniforms.direction.normalize();

                Color.multiplyByScalar(color, intensity, uniforms.skyColor);// uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
                Color.multiplyByScalar(light.groundColor, intensity, uniforms.groundColor);//uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);

                state.hemi[hemiLength] = uniforms;

                hemiLength++;

            }

        }

        state.ambient.red = r;
        state.ambient.green = g;
        state.ambient.blue = b;

        var hash = state.hash;

        if (hash.directionalLength !== directionalLength ||
            hash.pointLength !== pointLength ||
            hash.spotLength !== spotLength ||
            hash.rectAreaLength !== rectAreaLength ||
            hash.hemiLength !== hemiLength ||
            hash.numDirectionalShadows !== numDirectionalShadows ||
            hash.numPointShadows !== numPointShadows ||
            hash.numSpotShadows !== numSpotShadows) {

            state.directional.length = directionalLength;
            state.spot.length = spotLength;
            state.rectArea.length = rectAreaLength;
            state.point.length = pointLength;
            state.hemi.length = hemiLength;

            state.directionalShadowMap.length = numDirectionalShadows;
            state.pointShadowMap.length = numPointShadows;
            state.spotShadowMap.length = numSpotShadows;
            state.directionalShadowMatrix.length = numDirectionalShadows;
            state.pointShadowMatrix.length = numPointShadows;
            state.spotShadowMatrix.length = numSpotShadows;

            hash.directionalLength = directionalLength;
            hash.pointLength = pointLength;
            hash.spotLength = spotLength;
            hash.rectAreaLength = rectAreaLength;
            hash.hemiLength = hemiLength;

            hash.numDirectionalShadows = numDirectionalShadows;
            hash.numPointShadows = numPointShadows;
            hash.numSpotShadows = numSpotShadows;

            state.version = nextVersion++;

        }

        updateMap(frameState, 1);
        updateMap(frameState, 2);
    }

    /**
     * 
     * @param {Cesium.FrameState} frameState 
     */
    function updateMap(frameState) {
        var pointLights = extensionState.point;
        /**
         * @type {Cesium.Texture}
         */
        var map = pointLights['map'];
        var array = pointLights['array'];
        var num = state.hash.pointLength

        if (!frameState || !num) return;

        if (!map || pointLights.length != num) {
            if (map && !map.isDestroyed) map.destroy();
            pointLights.length = num;
            var context = frameState.context;
            var _Cesium = Cesium
            map = new Texture({
                context: context,
                width: num * 2,
                height: 6,
                pixelDatatype: PixelDatatype.FLOAT,
                pixelFormat: PixelFormat.RGBA,
                sampler: new _Cesium.Sampler({
                    wrapS: _Cesium.TextureWrap.CLAMP_TO_EDGE,
                    wrapT: _Cesium.TextureWrap.CLAMP_TO_EDGE,
                    magnificationFilter: _Cesium.TextureMagnificationFilter.LINEAR,
                    minificationFilter: _Cesium.TextureMinificationFilter.LINEAR
                })
            });
            pointLights['map'] = map;
            array = new Float32Array(map.width * map.height * 4);
            pointLights['array'] = array;
        }

        num *= 2;
        for (let i = 0; i < num; i += 2) {
            var pos = pointLights.positions[i / 2];
            var decalDist = pointLights.decalDists[i / 2];
            var color = pointLights.colors[i / 2];
            var visible = pointLights.visibles[i / 2];
            //position+decay
            for (let j = 0; j < 2; j++) {
                for (let k = 0; k < 2; k++) {
                    var ptr = (num * j + i + k) * 4;
                    array[ptr] = pos.x
                    array[ptr + 1] = pos.y
                    array[ptr + 2] = pos.z
                    array[ptr + 3] = decalDist.x;
                }
            }
            //color&distance
            for (let j = 2; j < 4; j++) {
                for (let k = 0; k < 2; k++) {
                    var ptr = (num * j + i + k) * 4;
                    array[ptr] = color.red
                    array[ptr + 1] = color.green
                    array[ptr + 2] = color.blue
                    array[ptr + 3] = decalDist.y;
                }
            }
            //visible
            for (let j = 4; j < 6; j++) {
                for (let k = 0; k < 2; k++) {
                    var ptr = (num * j + i + k) * 4;
                    array[ptr] = visible
                    array[ptr + 1] = visible
                    array[ptr + 2] = visible
                    array[ptr + 3] = visible;
                }
            }
        }

        map.copyFrom({
            width: map.width,
            height: map.height,
            arrayBufferView: array
        })
    }

    this.setup = setup
    this.state = state
    this.uniforms = {
        ambientLightColor: { value: state.ambient },
        directionalLights: { value: state.directional },
        spotLights: { value: state.spot },
        rectAreaLights: { value: state.rectArea },
        pointLights: { value: state.point },
        hemisphereLights: { value: state.hemi },
        directionalShadowMap: { value: state.directionalShadowMap },
        directionalShadowMatrix: { value: state.directionalShadowMatrix },
        spotShadowMap: { value: state.spotShadowMap },
        spotShadowMatrix: { value: state.spotShadowMatrix },
        pointShadowMap: { value: state.pointShadowMap },
        pointShadowMatrix: { value: state.pointShadowMatrix },
        lightProbe: { value: state.probe }

    };

    this.extensionState = extensionState

}

function UniformsCache() {

    var lights = {};
    const { Cartesian2, Cartesian3, Color } = Cesium;
    return {

        get: function (light) {

            if (lights[light.id] !== undefined) {

                return lights[light.id];

            }

            var uniforms;

            switch (light.type) {

                case 'DirectionalLight':
                    uniforms = {
                        direction: new Cartesian3(),
                        color: new Color(),

                        shadow: false,
                        // shadowBias: 0,
                        // shadowRadius: 1,
                        // shadowMapSize: new Cesium.Cartesian2()
                    };
                    break;

                case 'SpotLight':
                    uniforms = {
                        position: new Cartesian3(),
                        direction: new Cartesian3(),
                        color: new Color(),
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0,

                        shadow: false,
                        // shadowBias: 0,
                        // shadowRadius: 1,
                        // shadowMapSize: new Cesium.Cartesian2()
                    };
                    break;

                case 'PointLight':
                    uniforms = {
                        position: new Cartesian3(),
                        color: new Color(),
                        distance: 0,
                        decay: 0,

                        shadow: false,
                        // shadowBias: 0,
                        // shadowRadius: 1,
                        // shadowMapSize: new Cesium.Cartesian2(),
                        // shadowCameraNear: 1,
                        // shadowCameraFar: 1000

                        //extension
                        decalDist: new Cartesian2(),
                        visible: 1
                    };
                    break;

                case 'HemisphereLight':
                    uniforms = {
                        direction: new Cartesian3(),
                        skyColor: new Color(),
                        groundColor: new Color()
                    };
                    break;

                case 'RectAreaLight':
                    uniforms = {
                        color: new Color(),
                        position: new Cartesian3(),
                        halfWidth: new Cartesian3(),
                        halfHeight: new Cartesian3()
                        // TODO (abelnation): set RectAreaLight shadow uniforms
                    };
                    break;

            }

            lights[light.id] = uniforms;

            return uniforms;

        }

    };

}

function ShadowUniformsCache() {

    const lights = {};

    const { Cartesian3, Color, Cartesian2 } = Cesium;
    return {

        get: function (light) {

            if (lights[light.id] !== undefined) {

                return lights[light.id];

            }

            let uniforms;

            switch (light.type) {

                case 'DirectionalLight':
                    uniforms = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Cartesian2()
                    };
                    break;

                case 'SpotLight':
                    uniforms = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Cartesian2()
                    };
                    break;

                case 'PointLight':
                    uniforms = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Cartesian2(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1000
                    };
                    break;

                // TODO (abelnation): set RectAreaLight shadow uniforms

            }

            lights[light.id] = uniforms;

            return uniforms;

        }

    };

}

var nextVersion = 0;

function shadowCastingLightsFirst(lightA, lightB) {

    return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);

}

function transformDirection(p, m) {

    // input: THREE.Matrix4 affine matrix
    // vector interpreted as a direction

    var x = p.x, y = p.y, z = p.z;
    var e = m;

    p.x = e[0] * x + e[4] * y + e[8] * z;
    p.y = e[1] * x + e[5] * y + e[9] * z;
    p.z = e[2] * x + e[6] * y + e[10] * z;

    return Cesium.Cartesian3.normalize(p, p);

}

export default WebGLLights;

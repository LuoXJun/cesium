
import ConstantMap from "./ConstantMap.js";
import WebGLRenderer from "./WebGLRenderer.js";

/**
 * 渲染状态工具，使用内置的材质或者threejs材质，生成Cesium的RenderState
 * @param {WebGLRenderer} renderer 
 */
export default function CesiumRenderStates(renderer) {
    const {
        RenderState
    } = Cesium;

    var _renderStateCache = new Map();

    /**
     * 
     * @param {THREE.Material} material 
     * @param {THREE.Mesh|THREE.Line|THREE.Points|THREE.Sprite} object 
     * @param {boolean} fromCache 
     * @return {Cesium.RenderState}
     */
    this.create = function (material, object, fromCache) {


        var rs;
        if (fromCache) {
            rs = _renderStateCache.get(material)
            if (!rs) {
                rs = getRenderState(material, object);

                _renderStateCache.set(material, rs);
                material.material3js.addEventListener('dispose', () => {
                    _renderStateCache.delete(material, rs);
                })
            }
        }
        else {
            rs = getRenderState(material, object);
        }
        return rs;
    }

    // this.update = function (object) {
    //     return getRenderState(material, object);
    // }

    function enableOrDisable(gl, glEnum, enable) {
        if (enable) {
            gl.enable(glEnum);
        } else {
            gl.disable(glEnum);
        }
    }
    function applyBlendingColor(gl, color) {
        gl.blendColor(color.red, color.green, color.blue, color.alpha);
    }
    /**
     * 
     * @param {WebGL2RenderingContext} gl 
     * @param {*} renderState 
     * @param {*} passState 
     */
    function applyBlending(gl, renderState, passState) {
        var blending = renderState.blending;
        var enabled = Cesium.defined(passState.blendingEnabled)
            ? passState.blendingEnabled
            : blending.enabled;

        enableOrDisable(gl, gl.BLEND, enabled);

        if (enabled) {
            // applyBlendingColor(gl, blending.color);
            // gl.blendEquationSeparate(blending.equationRgb, blending.equationAlpha);
            // gl.blendFuncSeparate(
            //     blending.functionSourceRgb,
            //     blending.functionDestinationRgb,
            //     blending.functionSourceAlpha,
            //     blending.functionDestinationAlpha
            // );
            //    gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA ); 

            // gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
            // gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);

            gl.blendEquation(gl.FUNC_REVERSE_SUBTRACT);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        }
    }

    var scratchViewport;

    function applyViewport(gl, renderState, passState) {
        var viewport = Cesium.defaultValue(renderState.viewport, passState.viewport);
        if (!Cesium.defined(viewport)) {
            if (!scratchViewport) scratchViewport = new Cesium.BoundingRectangle();

            viewport = scratchViewport;
            viewport.width = passState.context.drawingBufferWidth;
            viewport.height = passState.context.drawingBufferHeight;
        }

        passState.context.uniformState.viewport = viewport;
        gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
    }

    // Cesium.RenderState.__apply = Cesium.RenderState.apply;
    // Cesium.RenderState.apply = function (gl, renderState, passState) {
    //     Cesium.RenderState.__apply(gl, renderState, passState);

    //     applyBlending(gl, renderState, passState);
    //     applyViewport(gl, renderState, passState);
    // }


    // Cesium.RenderState.__partialApply = Cesium.RenderState.partialApply
    // Cesium.RenderState.partialApply = function (
    //     gl,
    //     previousRenderState,
    //     renderState,
    //     previousPassState,
    //     passState,
    //     clear
    // ) {

    //     Cesium.RenderState.__partialApply(gl,
    //         previousRenderState,
    //         renderState,
    //         previousPassState,
    //         passState,
    //         clear);
    //     applyBlending(gl, renderState, passState);
    //     applyViewport(gl, renderState, passState);
    // }

    /**
     * 
     * @param {THREE.Material} material3js 
     * @param {boolean} frontFaceCW 
     * @return {Cesium.RenderState}
     * @private
     */
    function getRenderStateOptions(material3js, frontFaceCW) {

        const capabilities = renderer._capabilities,
            extensions = renderer._extensions;

        const equationToGL = ConstantMap.equationMap;
        const {
            WebGLConstants,
            StencilFunction,
            StencilOperation,
            StencilConstants,
            defined,
            defaultValue,
            CullFace,
            BlendingState
        } = Cesium;
        const { MinEquation, MaxEquation, DoubleSide, BackSide,
            NoBlending, MultiplyBlending, NormalBlending,
            CustomBlending, AdditiveBlending, SubtractiveBlending
        } = THREE;

        const factorToGL = ConstantMap.factorMap;
        const depthFuncMap = ConstantMap.depthFuncMap;

        // const gl = WebGLConstants;
        //const { MIN, MAX, ZERO, ONE, ONE_MINUS_SRC_ALPHA, SRC_ALPHA, SRC_COLOR, DST_ALPHA, DST_COLOR, ONE_MINUS_SRC_COLOR } = gl;

        //

        var material = material3js;
        var flipSided = (material.side === BackSide);
        if (frontFaceCW) flipSided = !flipSided;

        if (capabilities.isWebGL2) {
            equationToGL[MinEquation] = WebGLConstants.MIN;
            equationToGL[MaxEquation] = WebGLConstants.MAX;
        } else {

            var extension = extensions.get('EXT_blend_minmax');

            if (extension !== null) {

                equationToGL[MinEquation] = extension.MIN_EXT;
                equationToGL[MaxEquation] = extension.MAX_EXT;

            }

        }

        if (!defined(material.side)) {
            material.side = THREE.DoubleSide;
        }

        // if (flipSided&&frontFaceCW) debugger
        // if (material.polygonOffset) debugger

        if (material.onCreateRenderState) {
            var rs = material.onCreateRenderState();
            if (rs) return rs;
        }
        return {

            frontFace: frontFaceCW && flipSided ? Cesium.WindingOrder.CLOCKWISE : Cesium.WindingOrder.COUNTER_CLOCKWISE,
            cull: {
                enabled: material.side != DoubleSide,// defaultValue(cull.enabled, false),
                face: material.side == BackSide ? CullFace.FRONT : CullFace.BACK,// WebGLConstants.BACK|WebGLConstants.FRONT|WebGLConstants.FRONT_AND_BACK //defaultValue(cull.face, WebGLConstants.BACK),
            },

            lineWidth: 1,
            polygonOffset: {
                enabled: material.polygonOffset,
                factor: material.polygonOffsetFactor,
                units: material.polygonOffsetUnits
            },
            depthRange: material.depthRange || {
                near: 0,
                far: 1
            },
            depthTest: {
                enabled: material.depthTest,
                func: defaultValue(depthFuncMap[material.depthFunc], WebGLConstants.LEQUAL)
            },
            colorMask: {
                red: material.colorWrite,
                green: material.colorWrite,
                blue: material.colorWrite,
                alpha: material.colorWrite
            },
            depthMask: defaultValue(material.depthWrite, true),
            blending: (function () {

                if (material.blending == NoBlending) {
                    return BlendingState.DISABLED;
                }

                const blendEquation = material.blendEquation;
                const blendEquationAlpha = material.blendEquationAlpha || material.blendEquation;

                if (material.blending !== CustomBlending) {
                    if (material.premultipliedAlpha) {

                        // return Cesium.BlendingState.ALPHA_BLEND;

                        switch (material.blending) {

                            case NormalBlending:

                                return {
                                    enabled: true,
                                    equationRgb: equationToGL[blendEquation],
                                    equationAlpha: equationToGL[blendEquationAlpha],

                                    functionSourceRgb: WebGLConstants.ONE,
                                    functionSourceAlpha: WebGLConstants.ONE,

                                    functionDestinationRgb: WebGLConstants.ONE_MINUS_SRC_ALPHA,
                                    functionDestinationAlpha: WebGLConstants.ONE_MINUS_SRC_ALPHA
                                }
                                // gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
                                break;

                            case AdditiveBlending:
                                return {
                                    enabled: true,
                                    equationRgb: equationToGL[blendEquation],
                                    equationAlpha: equationToGL[blendEquationAlpha],

                                    functionDestinationAlpha: 1,
                                    functionDestinationRgb: 1,
                                    functionSourceAlpha: 1,
                                    functionSourceRgb: 770
                                }
                                // gl.blendFunc( gl.ONE, gl.ONE );
                                break;

                            case SubtractiveBlending:
                                return {
                                    enabled: true,
                                    equationRgb: equationToGL[blendEquation],
                                    equationAlpha: equationToGL[blendEquationAlpha],

                                    functionSourceRgb: WebGLConstants.ZERO,
                                    functionSourceAlpha: WebGLConstants.ONE_MINUS_SRC_COLOR,

                                    functionDestinationRgb: WebGLConstants.ZERO,
                                    functionDestinationAlpha: WebGLConstants.ONE_MINUS_SRC_ALPHA
                                }
                                // gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );
                                break;

                            case MultiplyBlending:
                                return {
                                    enabled: true,
                                    equationRgb: equationToGL[blendEquation],
                                    equationAlpha: equationToGL[blendEquationAlpha],

                                    functionSourceRgb: WebGLConstants.ZERO,
                                    functionSourceAlpha: WebGLConstants.ZERO,

                                    functionDestinationRgb: WebGLConstants.SRC_COLOR,
                                    functionDestinationAlpha: WebGLConstants.SRC_ALPHA
                                }
                                // gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );
                                break;

                            default:
                                console.error('RenderSateUtils: Invalid blending: ', material.blending);
                                break;

                        }

                    } else {

                        switch (material.blending) {

                            case NormalBlending:

                                return {
                                    enabled: true,
                                    // color: new Color(1,1,1,1.),
                                    equationRgb: equationToGL[blendEquation],
                                    equationAlpha: equationToGL[blendEquationAlpha],

                                    functionSourceRgb: WebGLConstants.SRC_ALPHA,
                                    functionSourceAlpha: WebGLConstants.ONE,
                                    functionDestinationRgb: WebGLConstants.ONE_MINUS_SRC_ALPHA,
                                    functionDestinationAlpha: WebGLConstants.ONE_MINUS_SRC_ALPHA
                                }

                                // gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
                                break;

                            case AdditiveBlending:
                                return BlendingState.ADDITIVE_BLEND;
                                break;

                            // case THREE.SubtractiveBlending:
                            //     return Cesium.BlendingState.PRE_MULTIPLIED_ALPHA_BLEND; 
                            // 	// gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );
                            // 	break;

                            // case THREE.MultiplyBlending:
                            //     return Cesium.BlendingState.PRE_MULTIPLIED_ALPHA_BLEND; 
                            //     return;
                            // 	// gl.blendFunc( gl.ZERO, gl.SRC_COLOR );
                            // 	break;

                            default:
                                console.error('RenderSateUtils: Invalid blending: ', material.blending);
                                break;

                        }

                    }

                    // ADDITIVE_BLEND
                    // ALPHA_BLEND
                    // DISABLED: {enabled: false}
                    // PRE_MULTIPLIED_ALPHA_BLEND: 

                } else {

                    return {
                        enabled: material.blending == NoBlending,
                        // color: //Color
                        equationRgb: equationToGL[blendEquation],
                        equationAlpha: equationToGL[blendEquationAlpha],
                        functionSourceRgb: factorToGL[material.blendSrc],
                        functionSourceAlpha: factorToGL[material.blendSrcAlpha],
                        functionDestinationRgb: factorToGL[material.blendDst],
                        functionDestinationAlpha: factorToGL[material.blendDstAlpha]
                    }
                }
            })(),
            stencilMask:
                material.stencilWrite ?
                    material.stencilWriteMask ://如果材质设定了开启模板测试，则使用threejs材质设置的模版测试参数
                    StencilConstants.CESIUM_3D_TILE_MASK,//否则使用3dtiles模板测试参数
            stencilTest:
                material.stencilWrite ? {//如果材质设定了开启模板测试，则使用threejs材质设置的模版测试参数
                    enabled: material.stencilWrite,
                    frontFunction: material.stencilFunc,
                    backFunction: material.stencilFunc,
                    reference: defaultValue(material.stencilRef, 0),
                    mask: defaultValue(material.stencilFuncMask, ~0),
                    frontOperation: {
                        fail: material.stencilFail,
                        zFail: material.stencilZFail,
                        zPass: material.stencilZPass
                    },
                    backOperation: {
                        fail: material.stencilFail,
                        zFail: material.stencilZFail,
                        zPass: material.stencilZPass
                    }
                } :
                    {//否则使用3dtiles模板测试参数
                        backFunction: 519,
                        backOperation: { fail: 7680, zFail: 7680, zPass: 7681 },
                        enabled: true,
                        frontFunction: 519,
                        frontOperation: { fail: 7680, zFail: 7680, zPass: 7681 },
                        mask: 128,
                        reference: 128
                    }

        }
    }

    /**
    *
    *@param {MeshMaterial}material
    *@param {THREE.Mesh|THREE.Line|THREE.Points|THREE.Sprite}object 
    *@return {Cesium.RenderState}frameState
    *@private
    */
    function getRenderState(material, object) {

        var frontFaceCW =
            object.matrixWorld.determinant() < 0;
        // determinant(mesh.matrixWorld.elements) < 0 //(mesh.isMesh && object.matrixWorld.determinant() < 0);
        let renderStateOpts = getRenderStateOptions(material, frontFaceCW);

        material._renderStateOptions = renderStateOpts;

        var renderState = RenderState.fromCache(renderStateOpts);
        // var renderState = new RenderState(renderStateOpts);

        return renderState;
    }

}

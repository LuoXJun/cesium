import MeshVisualizer from "../MeshVisualizer.js";
import ConstantMap from "./ConstantMap.js";
import TextureUtils from "./TextureUtils.js";

/**
 * 处理Threejs RenderTarget
 * @param {MeshVisualizer} visualizer 
 */
export default function WebGLRenderTargets(visualizer) {

    const { WebGLConstants, Sampler, RenderbufferFormat, Renderbuffer, Framebuffer } = Cesium;
    /**
    * @type {Map<THREE.WebGLRenderTarget|THREE.WebGLCubeRenderTarget,Cesium.Framebuffer>}
    * @private
    */
    let fbs = new Map();

    /**
     * 
     * @param {THREE.WebGLRenderTarget} renderTarget  
     * @param {Cesium.Texture} colorTexture  
     * @returns {Cesium.Framebuffer}
     * @private
     */
    function createFramebuffer(renderTarget, colorTexture) {

        const frameState = visualizer.frameState,
            context = frameState.context;

        var width = renderTarget.width || context.drawingBufferWidth,
            height = renderTarget.height || context.drawingBufferHeight;
        if (!colorTexture) {
            var texParams = TextureUtils.fromTexure3js(renderTarget.texture)

            colorTexture = TextureUtils.createTexture({
                target: WebGLConstants.TEXTURE_2D,
                width: width,
                height: height,
                format: texParams.format,
                flipY: texParams.flipY,
                type: texParams.type,
                sampler: new Sampler(texParams.sampler),
                preMultiplyAlpha: texParams.preMultiplyAlpha
            }, context);

            colorTexture.name = renderTarget.texture.name;
        }

        var depthTexture;
        if (renderTarget.depthTexture) {

            let texParams = TextureUtils.fromTexure3js(renderTarget.depthTexture)

            depthTexture = TextureUtils.createTexture({
                target: WebGLConstants.TEXTURE_2D,
                width: width,
                height: height,
                format: texParams.format,
                flipY: texParams.flipY,
                type: texParams.type,
                sampler: new Sampler(texParams.sampler),
                preMultiplyAlpha: texParams.preMultiplyAlpha
            }, context);
        }

        var depthRenderbuffer, stencilBuffer;
        if (renderTarget.stencilBuffer) {
            stencilBuffer = new Renderbuffer({
                context: context,
                format: RenderbufferFormat.DEPTH_STENCIL,
                width: width,
                height: height
            });
        }
        else if (renderTarget.depthBuffer) {

            depthRenderbuffer = new Renderbuffer({
                context: context,
                format: RenderbufferFormat.DEPTH_COMPONENT16,
                width: width,
                height: height
            });
        }

        let framebuffer = new Framebuffer({
            context: context,
            colorTextures: [colorTexture],
            destroyAttachments: false,
            depthTexture: depthTexture,
            depthRenderbuffer: depthRenderbuffer,
            depthStencilRenderbuffer: stencilBuffer
        });
        return framebuffer;
    }

    /**
     * 
     * @param {THREE.WebGLRenderTarget|THREE.WebGLCubeRenderTarget} renderTarget
     */
    this.set = function (renderTarget) {

        const frameState = visualizer.frameState,
            context = frameState.context;

        if (fbs.has(renderTarget)) {
            return;
        }

        let texture = renderTarget.texture,
            depthTexture = renderTarget.depthTexture,
            framebuffers = [];

        if (renderTarget.isWebGLCubeRenderTarget) {

            let format = ConstantMap.formatsMap[texture.format]

            var face = {
                width: renderTarget.width,
                height: renderTarget.height,
                arrayBufferView: new Uint8Array(4 * renderTarget.width * renderTarget.height),
            };

            let cubeMap = new Cesium.CubeMap({
                context: context,
                source: {
                    positiveX: face,
                    negativeX: face,
                    positiveY: face,
                    negativeY: face,
                    positiveZ: face,
                    negativeZ: face
                },
                width: renderTarget.width,
                height: renderTarget.height,
                pixelDatatype: ConstantMap.typesMap[texture.type],
                pixelFormat: format,
                flipY: texture.flipY,
                preMultiplyAlpha: texture.premultiplyAlpha
            });
            visualizer._textureCache[texture.uuid] = cubeMap;

            let cubeFaces = [cubeMap.positiveX, cubeMap.negativeX, cubeMap.positiveY, cubeMap.negativeY, cubeMap.positiveZ, cubeMap.negativeZ]
            for (let i = 0; i < 6; i++) {
                var framebuffer = createFramebuffer(renderTarget, cubeFaces[i]);
                framebuffers.push(framebuffer);
            }
        } else {
            let framebuffer = createFramebuffer(renderTarget);
            visualizer._textureCache[texture.uuid] = framebuffer.getColorTexture(0);

            if (depthTexture) {
                debugger
                visualizer._textureCache[depthTexture.uuid] = framebuffer.depthTexture;
            }

            framebuffers.push(framebuffer);
        }

        fbs.set(renderTarget, framebuffers);

        function onDispose() {

            framebuffers.forEach(function (framebuffer) {
                framebuffer.destroy();
            });
            fbs.delete(renderTarget);
            var textureCesium = visualizer._textureCache[texture.uuid] //= framebuffer.getColorTexture(0);
            if (textureCesium) {//&& ()) {
                if (!textureCesium.isDestroyed || !textureCesium.isDestroyed()) textureCesium.destroy();
                delete visualizer._textureCache[texture.uuid]
            }
            renderTarget.removeEventListener('dispose', onDispose);
        }
        renderTarget.__onDispose = onDispose
        renderTarget.addEventListener('dispose', onDispose);
    }

    /**
     * 
     * @param {THREE.WebGLRenderTarget|THREE.WebGLCubeRenderTarget} renderTarget  
     * @returns {Cesium.Framebuffer|Cesium.Framebuffer[]}
     */
    this.get = function (renderTarget) {
        if (!fbs.has(renderTarget)) {
            this.set(renderTarget)
        }
        var framebuffers = fbs.get(renderTarget);
        return framebuffers;
    }

    this.dispose = function () {

        fbs.forEach((val, key) => {
            if (key.__onDispose) {
                key.__onDispose()
                delete key.__onDispose
            }
        })

        fbs.clear();
    }

}


function WebGLGeometries() { }

function arrayMax(array) {

    if (array.length === 0) return - Infinity;

    var max = array[0];

    for (var i = 1, l = array.length; i < l; ++i) {

        if (array[i] > max) max = array[i];

    }

    return max;

}

/**
 * @param {THREE.BufferGeometry}geometry
 * @returns {THREE.BufferAttribute}
 */
WebGLGeometries.getWireframeAttribute = (function () {

    var wireframeAttributes = new WeakMap();

    function updateWireframeAttribute(geometry) {

        var indices = [];

        var geometryIndex = geometry.index;
        var geometryPosition = geometry.attributes.position;
        var version = 0;

        if (geometryIndex !== null) {

            var array = geometryIndex.array;
            version = geometryIndex.version;

            for (var i = 0, l = array.length; i < l; i += 3) {

                var a = array[i + 0];
                var b = array[i + 1];
                var c = array[i + 2];

                indices.push(a, b, b, c, c, a);

            }

        } else {

            var array = geometryPosition.array;
            version = geometryPosition.version;

            for (var i = 0, l = (array.length / 3) - 1; i < l; i += 3) {

                var a = i + 0;
                var b = i + 1;
                var c = i + 2;

                indices.push(a, b, b, c, c, a);

            }

        }

        const { Uint32BufferAttribute, Uint16BufferAttribute } = THREE;
        var attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
        attribute.version = version;

        // attributes.update( attribute, 34963 );

        //

        var previousAttribute = wireframeAttributes.get(geometry);

        if (previousAttribute) previousAttribute.onGeometryDispose(); //attributes.remove( previousAttribute );

        //

        function onGeometryDispose() {
            wireframeAttributes.delete(geometry);
            geometry.addEventListener('dispose', onGeometryDispose);
        }
        attribute.onGeometryDispose = onGeometryDispose;
        geometry.addEventListener('dispose', onGeometryDispose);

        wireframeAttributes.set(geometry, attribute);

    }

    /**
     * @param {THREE.BufferGeometry}geometry
     * @returns {THREE.BufferAttribute}
     * @private
     */
    function getWireframeAttribute(geometry) {

        var currentAttribute = wireframeAttributes.get(geometry);

        if (currentAttribute) {

            var geometryIndex = geometry.index;

            if (geometryIndex !== null) {

                // if the attribute is obsolete, create a new one

                if (currentAttribute.version < geometryIndex.version) {

                    updateWireframeAttribute(geometry);

                }

            }

        } else {

            updateWireframeAttribute(geometry);

        }

        return wireframeAttributes.get(geometry);

    }
    return getWireframeAttribute;
})()

/**
 * 
 * @param {THREE.Geometry|THREE.BufferGeometry|THREE.LineSegments|THREE.Points|Cesium.Geometry} geometry 
 * @return {THREE.BufferGeometry|Cesium.Geometry}
 */
WebGLGeometries.get = (function () {
    var geometries = new WeakMap();

    /**
     * 
     * @param {THREE.Geometry|THREE.BufferGeometry|THREE.LineSegments|THREE.Points} geometry
     * @param {THREE.Material[]}[materials]
     * @return {THREE.BufferGeometry}
     * @private
     */
    function get(geometry, materials) {
        var bufferGeometry;
        if (geometry.isBufferGeometry || geometry instanceof Cesium.Geometry) {
            bufferGeometry = geometry;
        }
        else {
            bufferGeometry = geometries.get(geometry);
            if (!bufferGeometry) {

                bufferGeometry = new THREE.BufferGeometry()
                bufferGeometry.fromGeometry(geometry)

                function onGeometryDispose() {
                    bufferGeometry.dispose();
                    geometries.delete(geometry);
                    bufferGeometry.removeEventListener('dispose', onGeometryDispose)
                }
                bufferGeometry.addEventListener('dispose', onGeometryDispose)

                geometries.set(geometry, bufferGeometry);
            }
        }

        //
        const BoundingSphere = Cesium.BoundingSphere;
        if (!bufferGeometry.boundingSphere) {

            if (bufferGeometry.computeBoundingSphere) {
                bufferGeometry.computeBoundingSphere();
            } else {
                var posAttr = bufferGeometry.attributes.position
                geometry.boundingSphere = BoundingSphere.fromVertices(posAttr.values || posAttr.array);
            }

        }

        if (!bufferGeometry.boundingVolume) {
            bufferGeometry.boundingVolume = BoundingSphere.clone(bufferGeometry.boundingSphere)
        }

        //

        const groups = bufferGeometry.groups;

        if (
            // materials &&
            groups && groups.length > 0 && !bufferGeometry.groupsOptimized) {

            var groupsOptimized = [], tempDic = {};
            var materialIndicesUsed = [];
            groups.forEach((g, groupIndex) => {
                var materialIndex = g.materialIndex;

                if (!tempDic[materialIndex]) {
                    materialIndicesUsed.push(materialIndex);
                }
                else {
                    // var material = materials[materialIndex]
                    // if (!material.transparent)  
                    return;
                }

                groupsOptimized.push({ materialIndex, groupIndex });
                tempDic[materialIndex] = true;
            })
            bufferGeometry.groupsOptimized = groupsOptimized;
            bufferGeometry.materialIndicesUsed = materialIndicesUsed;
        }

        return bufferGeometry;
    }

    return get;
})()
export default WebGLGeometries;
 
import WebGLGeometries from "./WebGLGeometries.js";
import WebGLRenderer from "./WebGLRenderer.js";

function numericalSort(a, b) {

	return a[0] - b[0];

}

function absNumericalSort(a, b) {

	return Math.abs(b[1]) - Math.abs(a[1]);

}


/**
 * 
 * @param {WebGLRenderingContext} gl 
 * @param {WebGLRenderer} renderer 
 * @returns 
 */
function WebGLMorphtargets(gl,renderer) {

	const cesiumVertextArrays=renderer._cesiumVertextArrays
	const influencesList = {};
	// const morphInfluences = new Float32Array( 8 );

	const workInfluences = [];

	for (let i = 0; i < 8; i++) {

		workInfluences[i] = [i, 0];

	}

	function update(object, geometry, material, program) {

		geometry = WebGLGeometries.get(geometry);

		let uniforms = getUniforms(object);
		const morphInfluences = uniforms.morphTargetInfluences;

		let objectInfluences = object.morphTargetInfluences;

		// When object doesn't have morph target influences defined, we treat it as a 0-length array
		// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

		const length = objectInfluences === undefined ? 0 : objectInfluences.length;

		let influences = influencesList[geometry.id];

		if (influences === undefined) {

			// initialise list

			influences = [];

			for (let i = 0; i < length; i++) {

				influences[i] = [i, 0];

			}

			influencesList[geometry.id] = influences;

		}

		// Collect influences

		for (let i = 0; i < length; i++) {

			const influence = influences[i];

			influence[0] = i;
			influence[1] = objectInfluences[i];

		}

		influences.sort(absNumericalSort);

		for (let i = 0; i < 8; i++) {

			if (i < length && influences[i][1]) {

				workInfluences[i][0] = influences[i][0];
				workInfluences[i][1] = influences[i][1];

			} else {

				workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
				workInfluences[i][1] = 0;

			}

		}

		workInfluences.sort(numericalSort);

		let morphTargets = material.morphTargets && geometry.morphAttributes.position;
		let morphNormals = material.morphNormals && geometry.morphAttributes.normal;

		let morphInfluencesSum = 0;

		for (let i = 0; i < 8; i++) {

			const influence = workInfluences[i];
			const index = influence[0];
			const value = influence[1];

			if (index !== Number.MAX_SAFE_INTEGER && value) {

				if (morphTargets && geometry.getAttribute('morphTarget' + i) !== morphTargets[index]) {
					morphTargets[index].id = index

					geometry.setAttribute('morphTarget' + i, morphTargets[index]);

				}

				if (morphNormals && geometry.getAttribute('morphNormal' + i) !== morphNormals[index]) {

					geometry.setAttribute('morphNormal' + i, morphNormals[index]);

				}

				morphInfluences[i] = value;
				morphInfluencesSum += value;

			} else {

				if (morphTargets && geometry.getAttribute('morphTarget' + i) !== undefined) {

					geometry.deleteAttribute('morphTarget' + i);

				}

				if (morphNormals && geometry.getAttribute('morphNormal' + i) !== undefined) {

					geometry.deleteAttribute('morphNormal' + i);

				}

				morphInfluences[i] = 0;

			}

		}

		// GLSL shader uses formula baseinfluence * base + sum(target * influence)
		// This allows us to switch between absolute morphs and relative morphs without changing shader code
		// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
		const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

		uniforms.morphTargetBaseInfluence = morphBaseInfluence;
		uniforms.morphTargetInfluences = morphInfluences;

		updateMorphAttribute(uniforms, geometry);

		// program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
		// program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );
	}

	var uniformsCache = new WeakMap();
	var objectCache = new WeakMap();

	function updateMorphAttribute(uniforms, geometry) {
		var objects = objectCache.get(uniforms);

		var attributes = geometry.attributes;
		for (const name in attributes) {
			const attribute = attributes[name];
			if (name.includes('morphTarget') || name.includes('morphNormal')) {

				objects.forEach(object => {
					cesiumVertextArrays.updateVerexBuffer(object, name, attribute);
				})
			}
		}
	}

	function setObjectCache(uniforms, object) {
		var objects = objectCache.get(uniforms);
		if (!objects) {
			objects = [];
			objectCache.set(uniforms, objects);
		}
		if (!objects.includes(object)) {
			objects.push(object);
			object.geometry.addEventListener('dispose', () => {
				var id = objects.indexOf(object);
				if (id >= 0) {
					objects.splice(id, 1)
				}
			})
		}
	}
	function getUniforms(object) {

		var uniforms = uniformsCache.get(object);
		if (!uniforms) {
			uniforms = {
				morphTargetBaseInfluence: 1,
				morphTargetInfluences: new Float32Array(8)
			}
			object.geometry.addEventListener('dispose', () => {
				uniformsCache.delete(object);
			})
			uniformsCache.set(object, uniforms);
			setObjectCache(uniforms, object)
		}
		return uniforms;
	}
	function setUniforms(object, uniforms) {
		if (uniforms && object) {
			if (uniformsCache.get(object) == uniforms) {
				return;
			}
			object.geometry.addEventListener('dispose', () => {
				uniformsCache.delete(object);
			})
			uniformsCache.set(object, uniforms);
			setObjectCache(uniforms, object)
		}
	}

	return {
		setUniforms: setUniforms,
		getUniforms: getUniforms,
		update: update

	};

}


export default WebGLMorphtargets;

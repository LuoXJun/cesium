
import RendererUtils from './RendererUtils.js'; 
import WebGLRenderer from './webgl/WebGLRenderer.js';
import TextureUtils from './webgl/TextureUtils.js';
import CameraUtils from './CameraUtils.js';
import WebGLRenderItem from './webgl/WebGLRenderItem.js';
import WebGLRenderStates from './webgl/WebGLRenderStates.js';
import WebGLRenderState from './webgl/WebGLRenderState.js';
import WebGLRenderItems from './webgl/WebGLRenderItems.js';
import WebGLGeometries from './webgl/WebGLGeometries.js';
import WebGLLights from './webgl/WebGLLights.js';
import IEffect from './IEffect.js';
import IRenderable from './IRenderable.js';
import polyfill from './polyfill.js';

//Cesium classes
var Matrix4;
var Matrix3;
var Matrix2;
var defaultValue;
var defined;
var Texture;
var PixelFormat;
var PixelDatatype;
var Cartesian3;
var Color;
var Ray;
var Transforms;
var Event;
var CubeMap;
var PrimitiveType;
var Intersect, BoundingSphere;
var Renderbuffer, Framebuffer, RenderbufferFormat;
//

var world2localMatrix;
var surfacePointLocal;
var rayDir;
var pos;
var rayOriginLocal;
var scratchRay;

var constantsHasInit$2 = false;
var _projScreenMatrix, _vector3;

function initConstants$2() {
    if (constantsHasInit$2) return;
    constantsHasInit$2 = true;

    const _Cesium = Cesium;
    Matrix4 = _Cesium.Matrix4;
    Matrix3 = _Cesium.Matrix3;
    Matrix2 = _Cesium.Matrix2;
    defaultValue = _Cesium.defaultValue;
    defined = _Cesium.defined;
    Texture = _Cesium.Texture;
    PixelFormat = _Cesium.PixelFormat;
    PixelDatatype = _Cesium.PixelDatatype;
    Cartesian3 = _Cesium.Cartesian3;
    Color = _Cesium.Color;
    Ray = _Cesium.Ray;
    Transforms = _Cesium.Transforms;
    Event = _Cesium.Event;
    PrimitiveType = _Cesium.PrimitiveType;
    CubeMap = Cesium.CubeMap;

    Renderbuffer = _Cesium.Renderbuffer;
    Framebuffer = _Cesium.Framebuffer;
    RenderbufferFormat = _Cesium.RenderbufferFormat;
    Intersect = _Cesium.Intersect;
    BoundingSphere = _Cesium.BoundingSphere;

    polyfill()

    world2localMatrix = new Matrix4();
    surfacePointLocal = new Cartesian3();
    rayDir = new Cartesian3();
    pos = new Cartesian3();
    rayOriginLocal = new Cartesian3();
    scratchRay = new Ray();

    _projScreenMatrix = new Matrix4();
    _vector3 = new Cartesian3();

}


function endFrame(object) {
    var material = object.material;

    object.needsUpdate = false;
    object.modelMatrixNeedsUpdate = false;

    if (object.instances) {
        object.instances.forEach((instance) => {
            instance.modelMatrixNeedsUpdate = false;
        });
    }

    if (material.needsUpdate == true)
        material.needsUpdate = false;
}


/**
*
*
*@param {Object}options
*@param {Cesium.Matrix4}[options.modelMatrix=Cesium.Matrix4.IDENTITY]
*@param {Cesium.Cartesian3}[options.position=Cesium.Cartesian3.ZERO] eastNorthUpToFixedFrame
*@param {Boolean}[options.show=true]
* 
*@constructor 
*@extends Cesium.Primitive
*/
function MeshVisualizer(options) {
    initConstants$2();
    options = options || {};
    if (!options.modelMatrix && options.position) {
        options.modelMatrix = Transforms.eastNorthUpToFixedFrame(options.position);
    }
    const scope = this;
    // Object3D.call(scope, options);
    scope._modelMatrix = options.modelMatrix ? options.modelMatrix : Matrix4.IDENTITY.clone();
    scope._children = [];

    scope.isMeshVisualizer = true;

    scope._actualModelMatrix = Matrix4.clone(scope._modelMatrix);
    scope._actualModelMatrixYup = new Matrix4();
    scope._actualModelMatrixXup = new Matrix4();

    scope._actualModelMatrixInverse = new Matrix4()
    scope._actualModelMatrixYupInverse = new Matrix4();
    scope._actualModelMatrixXupInverse = new Matrix4();

    scope._modelMatrixNeedsUpdate = true;

    scope._ready = true;

    scope._isWireframe = false;
    scope._debug = false;
    scope._show = defaultValue(options.show, true);

    scope._center = Matrix4.getTranslation(scope._modelMatrix, new Cartesian3());

    scope._textureCache = {};
    // scope._uniformMaps = new WeakMap();


    //for picking and postprocessing
    scope._pickIds = [];

    scope.beforeUpdate = new Event();
    scope.afterUpdate = new Event();
    scope.beforeDestroy = new Event();
    scope._scene = options.scene;

    scope.optimizeCommandInit = defaultValue(options.optimizeCommandInit, false);
    scope.optimizeInitCount = defaultValue(options.optimizeInitCount, 10);

    //   
    const _THREE = THREE;
    scope._defaultAmbientLight = new _THREE.AmbientLight('white', 1.);
    const sunLight = new _THREE.DirectionalLight(Color.WHITE.clone(), 2);
    sunLight.castShadow = true;
    sunLight.name = 'sunLight'
    scope._sunLight = sunLight;

    this.sunLightShadowRange = options.sunLightShadowRange || 500;
    this.sunLightShadowFar = options.sunLightShadowFar || 10000;
    this.sunLightShadowSize = options.sunLightShadowSize || 2048;

    scope._sunPositionLC = new Cartesian3();
    scope._sunTargetPositionLC = new Cartesian3();
    scope._sunTargetPositionWC = new Cartesian3();
    scope._sunDirectionLC = new Cartesian3();

    scope.useSunLight = defaultValue(options.useSunLight, false);

    // scope.occlusionCulling = new OcclusionCulling()

    //for threejs 
    scope.renderer = new WebGLRenderer(scope);
    scope._lights = new WebGLLights();

    scope.maxChangingCount = 10;

    scope.useEncodedPosition = defaultValue(options.useEncodedPosition, false);

    scope.defaultTexture = null;
    scope.defaultCubeMap = null;
    scope.defaultShadowMap = null;
 
    scope._environment = null;
    scope._environmentChanged = false;
    scope.environment = options.environment;
    scope._backgroundMesh = null;
    scope._background = null;
    scope._backgroundSize = 1;
    scope.backgroundIsSkybox = false
    scope.backgroundVisibleDistance = 1e4;
    /**
     * @type {IEffect[]}
     */
    scope.effects = [];
    /**
     * @type {THREE.PointLight[]}
     */
    scope.fixedLights = []
    /**
     * @type {THREE.PointLight[]}
     */
    scope.partialLights = [];
    scope._fixedWebGLLights = new WebGLLights();
    scope._partialWebGLLights = new WebGLLights()

    scope._minRange = defaultValue(options.minRange, 8);
    scope.isMoonVisible = defaultValue(options.isMoonVisible, true);
    scope.isSunVisible = defaultValue(options.isSunVisible, true);
    scope.initBackground();

    scope.updateModelMatrix();
}

//MeshVisualizer方法
MeshVisualizer.prototype = {

    //公开接口

    /**
     * 
     * @param {Cesium.FrameState|Cesium.Scene} frameState 
     * @public
     */
    init(frameState) {

        frameState = frameState.frameState || frameState;
        this.renderer.init(frameState);

        if (!this._scene) {
            this._scene = frameState.camera._scene;
        }

        if (!this._onCameraChanged) {

            var timer = null
            this._onCameraChanged = () => {
                this._cameraChanged = true;

                if (timer) timer = clearTimeout(timer);
                timer = setTimeout(() => {
                    this._cameraChanged = false;
                }, 2000);
            }
            frameState.camera.changed.addEventListener(this._onCameraChanged);

        }

        if (!this.frameState) this._frameState = frameState;


        if (!this.defaultTextureImage) {
            var cv = document.createElement("canvas");
            this.defaultTextureImage = cv
            cv.width = 2;
            cv.height = 2;
            var ctx = cv.getContext('2d')
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, 2, 2);
        }

        if (!this.defaultCubeMap) {

            let defaultTextureImage = this.defaultTextureImage
            if (!defaultTextureImage) {

                defaultTextureImage = document.createElement("canvas");
                defaultTextureImage.width = 2;
                defaultTextureImage.height = 2;
                this.defaultTextureImage = defaultTextureImage
            }

            this.defaultCubeMap = new CubeMap({
                context: frameState.context,
                source: {
                    positiveX: defaultTextureImage,
                    negativeX: defaultTextureImage,
                    positiveY: defaultTextureImage,
                    negativeY: defaultTextureImage,
                    positiveZ: defaultTextureImage,
                    negativeZ: defaultTextureImage
                }
            });
        }

        if (!this.defaultTexture) {
            this.defaultTexture = new Texture({
                context: frameState.context,
                source: this.defaultTextureImage
            });
        }
        if (this.defaultShadowMap == null) {
            var cv = document.createElement('canvas')
            cv.width = 256; cv.height = 256;
            this.defaultShadowMap = new Texture({
                context: frameState.context,
                source: cv
            });
        }

        if (!this.defaultFramebuffer) {
            const width = 256, height = 256, context = frameState.context;
            var colorTexture = new Texture({
                context, width, height
            });
            var depthRenderbuffer = new Renderbuffer({
                context,
                width,
                height,
                format: RenderbufferFormat.DEPTH_COMPONENT16
            });
            this.defaultFramebuffer = new Framebuffer({
                context: context,
                colorTextures: [colorTexture],
                depthRenderbuffer: depthRenderbuffer
            })
        }

        this.initBackground();
        this.updateEnvironment()
    },
    initBackground() {
        if (typeof THREE != 'undefined' && !this._backgroundMesh) {
            const _THREE = THREE;
            const renderer = this.renderer;
            var defaultTextureImage = this.defaultTextureImage
            if (!defaultTextureImage) {

                defaultTextureImage = document.createElement("canvas");
                defaultTextureImage.width = 2;
                defaultTextureImage.height = 2;
                this.defaultTextureImage = defaultTextureImage
            }

            const backgroundMesh = new _THREE.Mesh(
                new _THREE.BoxBufferGeometry(2, 2, 2),
                new _THREE.ShaderMaterial({
                    name: 'BackgroundCubeMaterial',
                    uniforms: _THREE.UniformsUtils.clone(_THREE.ShaderLib.cube.uniforms),
                    vertexShader: _THREE.ShaderLib.cube.vertexShader,
                    fragmentShader: _THREE.ShaderLib.cube.fragmentShader,
                    side: _THREE.BackSide,
                    depthTest: false,
                    depthWrite: false,
                    fog: false
                })
            );

            backgroundMesh.geometry.deleteAttribute('normal');
            backgroundMesh.geometry.deleteAttribute('uv');

            backgroundMesh.pass = Cesium.Pass.ENVIRONMENT;

            backgroundMesh.frustumCulled = false;


            Object.defineProperty(backgroundMesh.material, 'envMap', {
                get: function () {
                    return this.uniforms.envMap.value;
                },
                set(background) {
                    if (background) {
                        background = renderer._cubemaps.get(background);
                        this.uniforms.envMap.value = background;
                        this.uniforms.flipEnvMap.value = (background.isCubeTexture && background._needsFlipEnvMap) ? - 1 : 1;

                    }
                }
            });

            backgroundMesh.material.uniforms.flipEnvMap.value = 1;
            var background = this.background || new _THREE.CubeTexture([
                this.defaultTextureImage, this.defaultTextureImage, this.defaultTextureImage,
                this.defaultTextureImage, this.defaultTextureImage, this.defaultTextureImage
            ]);
            backgroundMesh.material.uniforms.envMap.value = background
            backgroundMesh.material.uniforms.flipEnvMap.value = (background.isCubeTexture && background._needsFlipEnvMap) ? - 1 : 1;

            backgroundMesh.scale.setScalar(this._backgroundSize)
            backgroundMesh.visible = !!this.background;

            this._backgroundMesh = backgroundMesh;
            this._background = null;

        }
    },
    updateEnvironment(frameState) {
        frameState = frameState || this._frameState;
        if (!frameState) {
            console.warn('frameState  is required,this function will be called in the next frame');
            return
        };

        if (this._environmentChanged && this._environment && this._environment.isTexture) {
            let uuid = this._environment.uuid;
            let envMap = this._textureCache[uuid];

            if (!envMap) {
                let texUniform = TextureUtils.fromTexure3js(this._environment)//, texUniform);

                var createNew = false
                if (this._environment.isCubeTexture) {
                    envMap = TextureUtils.createCubeTexture(texUniform, frameState.context)
                    createNew = true;
                } else if (!texUniform.isEmptyTextureUniform) {
                    texUniform.target = Cesium.WebGLConstants.TEXTURE_2D
                    envMap = TextureUtils.createTexture(texUniform, frameState.context);
                    createNew = true;
                }

                if (createNew) {
                    texUniform.onDispose(() => {
                        if (!envMap.isDestroyed()) envMap.destroy()
                        delete this._textureCache[uuid]
                    })
                    envMap.__createByVisualizer = true;
                    this._textureCache[uuid] = envMap;
                }

            }
        }
    },

    /**
    * 
    *@param {IRenderable|THREE.Object3D}object
    */
    add(object) {
        object.visualizer = this;
        this._children.push(object);
        if (object.isIRenderable) {
            object.onAdded(this);
        }
    },
    /**
     * 移除mesh，释放由MeshVisualizer创建的内部资源
     * @param {THREE.Object3D|IRenderable}object
     * @param {boolean}dispose
     * @public
     */
    remove(object, dispose) {

        const { Pass, destroyObject } = Cesium;

        for (var i = 0; i < this._children.length; i++) {
            if (this._children[i] == object) {

                this._children.splice(i, 1);
            }
        }

        //release drawCommands & pickIds
        traverseObject3D(object, (object) => {

            if (object.isObject3D) {

                var geometry = object.geometry, material = object.material;
                if (material && geometry) {
                    if (dispose) {
                        var materials = Array.isArray(material) ? material : [material];
                        materials.forEach(material => material.dispose())
                        geometry.dispose();
                        object.dispatchEvent({ type: 'dispose' }, object);
                    } else {
                        this.renderer._cesiumVertextArrays.delete(geometry);
                    }
                }

            }
            else {
                if (dispose && object.isRuntimeMesh) {
                    object.destroy && object.destroy()
                }

                if (object.renderItems) {

                    var renderItems = Array.isArray(object.renderItems) ? object.renderItems : [object.renderItems];
                    renderItems.forEach((renderItem) => {
                        if (renderItem.destroy) renderItem.destroy()
                        renderItem.material = null;
                    });
                    delete object.renderItems;

                }
            }

            if (object.pickId || object.pickObject) {
                let pickId = object.pickId || object.pickObject.pickId;
                if (pickId) {
                    let i = this._pickIds.indexOf(pickId)
                    if (i >= 0) {
                        this._pickIds.splice(i, 1);
                    }
                    delete object.pickId;
                    pickId.destroy && pickId.destroy()
                }
                if (object.pickObject) {
                    delete object.pickObject.pickId
                    delete object.pickObject
                }
            }

        });

        //remove drawCommands 
        const cesiumScene = this._scene;
        const frustumCommandsList = cesiumScene._view.frustumCommandsList
        const passes = [Pass.ENVIRONMENT, Pass.OPAQUE, Pass.TRANSLUCENT, Pass.CESIUM_3D_TILE];

        frustumCommandsList.forEach(frustumCommands => {
            passes.forEach(pass => {
                let commandList = frustumCommands.commands[pass];
                let newCommandList = [];
                commandList.forEach(command => {
                    if (command.isDestroyed && command.isDestroyed()) {
                        return;
                    }
                    if (!command.vertexArray.isDestroyed()) newCommandList.push(command)
                })

                commandList.length = 0;
                newCommandList.forEach(command => {
                    commandList.push(command);
                })
            })
        });

        //Destroy released shaders and textures
        cesiumScene._shaderFrameCount = 199;

        if (object.isIRenderable) {
            object.onRemoved(this);
        }
    },
    /**
    *
    *拾取点，用局部坐标系表达。内部使用Cesium.Scene.pickPosition和MeshVisualizer.worldCoordinatesToLocal实现。
    * @param {Cesium.Cartesian2}windowPosition
    * @param {Cesium.Cartesian3}[result]
    * @return {Cesium.Cartesian3}
    * @public
    */
    pickPosition(windowPosition, result) {
        if (!this._scene) {
            return undefined;
        }
        surfacePointLocal = this._scene.pickPosition(windowPosition, surfacePointLocal);

        if (!surfacePointLocal) {
            return undefined;
        }

        this.worldCoordinatesToLocal(surfacePointLocal, surfacePointLocal);
        Cartesian3.clone(surfacePointLocal, result);
        return result;
    },
    /**
    *
    *创建一条射线，用局部坐标系表达
    * @param {Cesium.Cartesian2}windowPosition
    * @param {Cesium.Ray}[result]
    * @param {Cesium.Cartesian3}[up]
    * @return {Cesium.Ray}
    * @public
    */
    getPickRay(windowPosition, result, up) {
        if (!this._scene) {
            return undefined;
        }
        const { Cartesian3, Ray } = Cesium;
        if (!result) {
            result = Ray();
        }
        this._scene.camera.getPickRay(windowPosition, scratchRay);//ray用于计算小球发射点位置，这里射线的起始点是世界坐标，不能像Threejs那样直接拿来计算，需要转成局部坐标
        surfacePointLocal = this._scene.pickPosition(windowPosition, surfacePointLocal);//射线和局部场景的交点

        if (!surfacePointLocal) {
            return undefined;
        }

        Cartesian3.clone(scratchRay.direction, rayDir);

        //世界坐标转局部坐标
        this.worldCoordinatesToLocal(scratchRay.origin, rayOriginLocal, up);
        this.worldCoordinatesToLocal(surfacePointLocal, surfacePointLocal, up);

        Cartesian3.add(rayOriginLocal, rayDir, pos);
        //计算发射方向
        Cartesian3.subtract(surfacePointLocal, pos, rayDir);
        Cartesian3.clone(surfacePointLocal, result.origin);
        Cartesian3.clone(rayDir, result.direction);
        return result;
    },
    /**
    *世界坐标到局部坐标
    * @param {Cesium.Cartesian3}worldCoordinates
    * @param {Cesium.Cartesian3}[result]
    * @param {Cesium.Cartesian3}[up]
    * @return {Cesium.Cartesian3}
    * @public
    */
    worldCoordinatesToLocal(worldCoordinates, result, up) {
        if (!result) {
            result = new Cartesian3();
        }
        var modelMatrix = this._actualModelMatrix;
        if (up) {
            if (up.y) {//y up
                modelMatrix = this._actualModelMatrixYup;
            }
            else if (up.x) {
                modelMatrix = this._actualModelMatrixXup;
            }
        }

        Matrix4.inverseTransformation(modelMatrix, world2localMatrix)
        Matrix4.multiplyByPoint(world2localMatrix, worldCoordinates, result);
        return result;
    },
    /**
     *局部坐标到世界坐标
    * @param {Cesium.Cartesian3}localCoordinates
    * @param {Cesium.Cartesian3}[result]
    * @param {Cesium.Cartesian3}[up]
    * @return {Cesium.Cartesian3}
    * @public
    */
    localToWorldCoordinates(localCoordinates, result, up) {
        if (!result) {
            result = new Cartesian3();
        }

        var modelMatrix = this._actualModelMatrix;
        if (up) {
            if (up.y) {//y up
                modelMatrix = this._actualModelMatrixYup;
            }
            else if (up.x) {
                modelMatrix = this._actualModelMatrixXup;

            }
        }

        Matrix4.multiplyByPoint(modelMatrix, localCoordinates, result);
        return result;
    },


    //私有方法

    /**
     * 
     * @private
     */
    computeModelMatrix(object) {

        const needsUpdate = object.modelMatrixNeedsUpdate

        if (needsUpdate) {

            const matrixWorld = object.matrixWorld.elements;
            const modelMatrix = object.modelMatrix;
            const scope = this;

            if (object.up.y) {//y up
                Matrix4.multiply(scope._actualModelMatrixYup, matrixWorld, modelMatrix);
            }
            else if (object.up.x) {
                Matrix4.multiply(scope._actualModelMatrixXup, matrixWorld, modelMatrix);

            } else {//z up
                Matrix4.multiply(scope._actualModelMatrix, matrixWorld, modelMatrix);
            }

            if (object.forward && object.forward.z) {
                // glTF 2.0 has a Z-forward convention that must be adapted here to X-forward.
                Matrix4.multiplyTransformation(
                    modelMatrix,
                    Cesium.Axis.Z_UP_TO_X_UP,
                    modelMatrix
                );
            }

        }

    },
    /**
     * @private
     */
    updateModelMatrix() {
        const scope = this;
        const actualModelMatrix = scope._actualModelMatrix
        const actualModelMatrixYup = scope._actualModelMatrixYup
        const actualModelMatrixXup = scope._actualModelMatrixXup
        //z up
        // Matrix4.multiply(scope.modelMatrix, scope.matrixWorld, actualModelMatrix);
        Matrix4.clone(scope.modelMatrix, actualModelMatrix)
        //y up
        RendererUtils.yUp2Zup(actualModelMatrix, actualModelMatrixYup);
        //x up
        Matrix4.multiplyTransformation(
            actualModelMatrix,
            Cesium.Axis.X_UP_TO_Z_UP,
            actualModelMatrixXup
        );

        //z up
        Matrix4.inverse(actualModelMatrix, scope._actualModelMatrixInverse);
        //y up
        Matrix4.inverse(actualModelMatrixYup, scope._actualModelMatrixYupInverse);
        //x up
        Matrix4.inverse(actualModelMatrixXup, scope._actualModelMatrixXupInverse);

        Matrix4.getTranslation(actualModelMatrix, scope._center)
    },

    //实现Cesium Primitive接口 

    /**
     * 
     * @param {THREE.Object3D} object 
     * @param {Cesium.FrameState} frameState 
     * @param {boolean} cameraChanged 
     * @private
     */
    computeObjectVisibility(object, frameState, cameraChanged) {

        const { INSIDE, OUTSIDE, INTERSECTING } = Intersect;

        if (object.frustumCulled == false) {

            if (object.isCustomInstancedMesh) {

                const availableInstances = object._availableInstances || [];
                object._availableInstances = availableInstances
                availableInstances.length = 0;
                object.instances.forEach(function (instance) {
                    availableInstances.push(instance);
                });
            }

            object.mvis_visibility = INTERSECTING;

            return;
        } else if (object.isInstancedMesh || !object.geometry) {
            debugger
            return;
        }

        var modelMatrixNeedsUpdate = object.modelMatrixNeedsUpdate;
        if (!modelMatrixNeedsUpdate && !cameraChanged) return;

        const { camera, cullingVolume } = frameState;

        const geometry = WebGLGeometries.get(object.geometry);
        const boundingSphere = geometry.boundingSphere
        const boundingVolume = geometry.boundingVolume;

        if (object.isCustomInstancedMesh) {
            const instances = object.instances;

            const availableInstances = object._availableInstances || [];
            object._availableInstances = availableInstances;
            availableInstances.length = 0;

            instances.forEach(function (instance) {

                if (!instance.show) return;

                const insBs = instance.boundingSphere
                insBs.radius = boundingSphere.radius * instance.scale;

                var modelMatrixNeedsUpdate = instance.modelMatrixNeedsUpdate
                if (modelMatrixNeedsUpdate) {
                    Matrix4.getTranslation(instance.modelMatrix, insBs.center)
                }

                instance.mvis_distanceToCamera = camera.distanceToBoundingSphere(insBs)

                instance.mvis_visibility = INSIDE;
                if (object.maxVisibleDistance && instance.mvis_distanceToCamera > object.maxVisibleDistance) {
                    instance.mvis_visibility = OUTSIDE;
                    return;
                }

                instance.mvis_visibility = cullingVolume.computeVisibility(insBs)

                if (instance.mvis_visibility != OUTSIDE) {
                    availableInstances.push(instance)
                }
            });

        }
        else {

            if (modelMatrixNeedsUpdate) {
                const modelMatrix = object.modelMatrix
                Matrix4.multiplyByPoint(modelMatrix, boundingSphere.center, boundingVolume.center);
                boundingVolume.radius = boundingSphere.radius * Matrix4.getMaximumScale(object.modelMatrix)

            }

            object.mvis_distanceToCamera = camera.distanceToBoundingSphere(boundingVolume)
            object.mvis_visibility = INSIDE;

            const range = RendererUtils.computeRange(object.mvis_distanceToCamera, boundingVolume.radius, frameState)

            if (range < this.minRange) {
                object.mvis_visibility = OUTSIDE;
            }
            else if (object.maxVisibleDistance && object.mvis_distanceToCamera > object.maxVisibleDistance) {
                object.mvis_visibility = OUTSIDE;
            }

            if (object.mvis_visibility != OUTSIDE) {
                object.mvis_visibility = cullingVolume.computeVisibility(boundingVolume);
            }

        }

    },

    /**
     * 
     * @param {WebGLRenderItem} renderItem 
     * @param {Cesium.FrameState} frameState  
     * @private
     */
    isRenderItemVisible(renderItem, frameState) {

        if (!renderItem.frustumCulled) return true;

        const boundingVolume = renderItem.boundingVolume;
        const distanceToCamera =
            // renderItem.z;
            frameState.camera.distanceToBoundingSphere(boundingVolume);
        var range = RendererUtils.computeRange(distanceToCamera, boundingVolume.radius, frameState)
        renderItem.distanceToCamera = distanceToCamera;

        if (range < this.minRange) {
            return false;
        }

        if (renderItem.object.mvis_visibility == Intersect.INTERSECTING) {
            var visibility = frameState.cullingVolume.computeVisibility(boundingVolume)
            if (visibility == Intersect.OUTSIDE) {
                return false;
            }
        }

        return true;
    },

    /**
     * 
     * @param {THREE.Light} light 
     * @param {Cesium.FrameState} frameState 
     * @private
     */
    isLightVisible(light, frameState) {
        var bs = light.boundingSphere
        if (light.modelMatrixNeedsUpdate || !bs) {
            if (!bs) {
                bs = new BoundingSphere();
                light.boundingSphere = bs
            }
            Matrix4.getTranslation(light.modelMatrix, bs.center);
            bs.radius = light.distance;
        }
        if (this._cameraChanged || light.modelMatrixNeedsUpdate) {
            light._exVisible = frameState.cullingVolume.computeVisibility(bs) != Intersect.OUTSIDE
        }
        return light._exVisible;
    },
    /**
     * 
     * @param {THREE.Light} light 
     * @param {Cesium.FrameState} frameState 
     * @private
     */
    updateExtensionLight(light, frameState) {
        if (light.matrixAutoUpdate) {
            light.updateMatrixWorld();
        }
        if (light.modelMatrixNeedsUpdate || !light.boundingSphere) {
            this.computeModelMatrix(light);
        }
        this.isLightVisible(light, frameState);
        light.modelMatrixNeedsUpdate = false
    },
    /**
     * 
     * @param {THREE.Object3D} object  
     * @param {Cesium.FrameState} frameState 
     * @param {THREE.PerspectiveCamera} camera3jsLocal 
     * @param {WebGLRenderState} currentWebglRenderState
     * @param {THREE.Frustum}[frustum3js]
     * @private
     */
    projectObject(object, frameState, camera3jsLocal, currentWebglRenderState, frustum3js) {

        if (!object.isObject3D) return;

        if (!object.show && !object.visible) return;

        if (object.isGroup || object.isScene) {

            const children = object.children;
            for (let i = 0; i < children.length; i++) {

                this.projectObject(children[i], frameState, camera3jsLocal, currentWebglRenderState, frustum3js);

            }

        } else {

            if (object.isLOD) {

                if (object.autoUpdate === true)
                    object.update(camera3jsLocal);

            }
            else if (object.isLight) {//light

                if (object.isPointLight) {
                    this.updateExtensionLight(object, frameState);
                }
                else {
                    this.computeModelMatrix(object);
                }

                currentWebglRenderState.pushLight(object);

                if (object.target) {//更新灯光锁定目标的模型矩阵，来实现改变光照方向
                    if (object.target.matrixAutoUpdate) {
                        object.target.updateMatrixWorld();
                    }

                    this.computeModelMatrix(object.target);
                }

                if (object.castShadow) {
                    currentWebglRenderState.pushShadow(object);
                }

            } else if (object.isMesh || object.isLine || object.isPoints || object.Sprite) {

                if (!object.isCustomInstancedMesh) this.computeModelMatrix(object);

                //计算mesh和实例的可见性 
                this.computeObjectVisibility(object, frameState, this._cameraChanged, frustum3js);
                var visible = object.mvis_visibility != Intersect.OUTSIDE;

                // if (visible && frustum3js && object.isRuntimeMesh != true) {
                //     var geometry = WebGLGeometries.get(object.geometry);
                //     var bs = geometry.boundingSphere;
                //     if (!frustum3js.intersectsSphere(bs)) {
                //         visible = false
                //     }
                // }

                if (!visible || (frameState.passes.pick && (object.allowPick == false || object.material.allowPick == false))) {

                    object.modelMatrixNeedsUpdate = false;

                } else {
                    currentWebglRenderState.pushRenderable(object);
                }

            }

            const children = object.children;
            for (let i = 0; i < children.length; i++) {

                this.projectObject(children[i], frameState, camera3jsLocal, currentWebglRenderState, frustum3js);

            }

        }

    },

    /**
     * 
     * @param {Cesium.FrameState} frameState 
     * @param {THREE.PerspectiveCamera} camera3jsLocal 
     * @param {WebGLRenderState} currentRenderState 
     * @private
     */
    updateBackground(frameState, camera3jsLocal, currentRenderState) {
        const backgroundMesh = this._backgroundMesh;
        if (backgroundMesh && backgroundMesh.visible) {

            if (this.backgroundIsSkybox) {

                backgroundMesh.scale.setScalar(1);
                backgroundMesh.updateMatrixWorld();
                backgroundMesh.matrixWorld.copyPosition(camera3jsLocal.matrixWorld);
                var distance = Cartesian3.distance(frameState.camera.positionWC, this._center)
                if (distance > this.backgroundVisibleDistance) {
                    backgroundMesh.material.uniforms.opacity.value = 1.0 - (distance - this.backgroundVisibleDistance) / this.backgroundVisibleDistance;
                } else {
                    backgroundMesh.material.uniforms.opacity.value = 1;
                }
            } else {
                backgroundMesh.updateMatrixWorld();
            }

            this.computeModelMatrix(backgroundMesh);
            this.renderer._webglRenderItems.getAndUpdate(backgroundMesh, frameState, false, currentRenderState, camera3jsLocal);

        }
    },

    /**
     * 
     * @param {Cesium.FrameState} frameState 
     * @private
     */
    updateSunLight(frameState) {

        if (!this._sunLight) return;
        const scope = this;
        var scene = scope._scene
        var sunLightCesium = scene.light;
        var sunLight = scope._sunLight;

        var sunLightShadow = sunLight.shadow
        var shadowCamera = sunLightShadow.camera;
        var shadowState = frameState.shadowState;
        var uniformState = frameState.context.uniformState;
        const sunPositionWC = uniformState._sunPositionWC,
            sunDirectionWC = uniformState._sunDirectionWC,
            sunPositionLC = scope._sunPositionLC,
            sunTargetPositionLC = scope._sunTargetPositionLC,
            sunTargetPositionWC = scope._sunTargetPositionWC,
            sunDirectionLC = scope._sunDirectionLC;
        this.worldCoordinatesToLocal(sunPositionWC, sunPositionLC, { y: 1 });
        Cartesian3.subtract(sunPositionWC, sunDirectionWC, sunTargetPositionWC);
        this.worldCoordinatesToLocal(sunTargetPositionWC, sunTargetPositionLC, { y: 1 });
        Cartesian3.subtract(sunPositionLC, sunTargetPositionLC, sunDirectionLC);

        if (!sunLight) return;

        var sunLightTarget = sunLight.target;
        Color.clone(sunLight.color, sunLightCesium.color);
        sunLight.intensity = sunLightCesium.intensity;

        //position,direction
        var sunLightShadowFar = this.sunLightShadowFar;
        var sunLightShadowRange = this.sunLightShadowRange;
        var sunLightShadowSize = this.sunLightShadowSize;
        sunLight.position.copy(sunPositionLC).normalize().multiplyScalar(sunLightShadowFar);//shadowState.farPlane)

        sunLight.updateMatrixWorld();
        sunLightTarget.updateMatrixWorld();
        this.computeModelMatrix(sunLight)
        this.computeModelMatrix(sunLightTarget);

        //shadow,camera
        if (sunLightShadowSize != sunLightShadow.mapSize.x) {
            sunLightShadow.mapSize.set(sunLightShadowSize, sunLightShadowSize)
            sunLightShadow.__mapVersion = 0;
        }
        shadowCamera.left = -sunLightShadowRange;
        shadowCamera.right = sunLightShadowRange;
        shadowCamera.top = sunLightShadowRange;
        shadowCamera.bottom = -sunLightShadowRange;
        shadowCamera.far = sunLightShadowFar * 2;// shadowState.farPlane ;
        shadowCamera.near = 0.1//shadowState.nearPlane;
        shadowCamera.updateProjectionMatrix();
    },

    /**
     * 
     * @param {THREE.Scene|MeshVisualizer} scene  
     * @param {Cesium.FrameState} frameState 
     * @param {THREE.Camera} camera3jsLocal 
     * @param {WebGLRenderState} currentWebglRenderState
     * @param {THREE.Frustum}[frustum3js]
     * @private
     */
    projectObjects(scene, frameState, camera3jsLocal, currentWebglRenderState, frustum3js) {

        const dynamicRenderables = currentWebglRenderState.dynamicRenderables;
        //level1
        scene.children.forEach(object => {

            //IRenderable
            if (typeof object.render == 'function') {
                object.render(frameState, dynamicRenderables, this.renderer, camera3jsLocal, currentWebglRenderState);
            }

            if (!object.visible && !object.show) return;

            if (object.isObject3D) {
                if (object.matrixAutoUpdate || object.modelMatrixNeedsUpdate) {
                    object.updateMatrixWorld();
                    this.computeModelMatrix(object);
                }
            }

        });

        // this.updateBackground(frameState, camera3jsLocal);
        //

        if (scene.isMeshVisualizer) {

            const children = scene.children;
            for (let i = 0; i < children.length; i++) {
                this.projectObject(children[i], frameState, camera3jsLocal, currentWebglRenderState, frustum3js);
            }

        } else {
            this.projectObject(scene, frameState, camera3jsLocal, currentWebglRenderState, frustum3js);

        }

        if (this.useSunLight && this._sunLight) {
            var sunLight = this._sunLight;
            var children = sunLight.children;
            for (let i = 0; i < children.length; i++) {
                this.projectObject(children[i], frameState, camera3jsLocal, currentWebglRenderState, frustum3js);
            }
            this.projectObject(sunLight.shadow.camera, frameState, camera3jsLocal, currentWebglRenderState, frustum3js);

        }

        for (let i = 0; i < dynamicRenderables.length; i++) {

            this.projectObject(dynamicRenderables[i], frameState, camera3jsLocal, currentWebglRenderState, frustum3js);

        }

    },

    /**
     *  
     * @param {Cesium.FrameState} frameState 
     * @param {WebGLRenderState} currentRenderState 
     * @param {THREE.Camera}[camera3js]
     * @param {THREE.Frustum}[frustum3js]
     * @private 
     */
    createOrUpdateCommands(frameState, currentRenderState, camera3js, frustum3js) {

        var wireframeChanged = false;
        var sysWireframe = frameState.camera._scene._globe._surface.tileProvider._debug.wireframe;

        if (sysWireframe != this._sysWireframe) wireframeChanged = true;
        this._sysWireframe = sysWireframe;

        const camera = frameState.camera, frustum = camera.frustum, cameraChanged = this._cameraChanged;

        Matrix4.multiply(frustum.projectionMatrix, camera.viewMatrix, _projScreenMatrix);

        const webGLRenderList = currentRenderState.renderList,
            renderables = currentRenderState.renderables;
        /**
         * @type {WebGLRenderItems}
         */
        const webglRenderItems = this.renderer._webglRenderItems;
        const optimizeInitCount = this.optimizeInitCount, optimizeCommandInit = this.optimizeCommandInit;

        var loadingCommands = [];

        for (var i = 0, l = renderables.length; i < l; i++) {

            const object = renderables[i];

            //
            if (optimizeCommandInit && loadingCommands.length >= optimizeInitCount) continue;

            //three.js's object


            const renderItems = webglRenderItems.getAndUpdate(object, frameState, sysWireframe, currentRenderState, camera3js);

            const modelMatrixNeedsUpdate = object.modelMatrixNeedsUpdate || this.modelMatrixNeedsUpdate;
            var visibilityNeedsUpdate = modelMatrixNeedsUpdate || cameraChanged;

            if (renderItems.length == 1) {
                renderItems[0].visible = true;
                visibilityNeedsUpdate = false;
            }

            for (let j = 0, lj = renderItems.length; j < lj; j++) {

                const renderItem = renderItems[j];
                const boundingVolume = renderItem.boundingVolume;
                Matrix4.multiplyByPoint(_projScreenMatrix, boundingVolume.center, _vector3);
                renderItem.z = _vector3.z;

                if (renderItem.material.visible == false) continue;

                if (visibilityNeedsUpdate || renderItem.visible == undefined) {
                    renderItem.visible = this.isRenderItemVisible(renderItem, frameState, frustum3js);
                }

                if (renderItem.visible == false) {
                    continue;
                }

                // if (frustum3js) {
                //     if (!frustum3js.intersectsSphere(renderItem.boundingSphere)) {
                //         continue;
                //     }
                // }

                //

                if (!renderItem.loaded) {
                    if (optimizeCommandInit && loadingCommands.length >= optimizeInitCount) return;

                    loadingCommands.push(renderItem);
                    renderItem.loaded = true;
                }

                //

                if (object == this._backgroundMesh) continue;
                webGLRenderList.push(renderItem);
            }

        }

        webGLRenderList.sort();

    },

    //for shadowMap
    /**
     * 
     * @param {*} scene 
     * @param {*} frameState 
     * @param {*} camera3js  
     * @returns {WebGLRenderState}
     * @private
     */
    getAndUpdateRenderState(scene, frameState, camera3js, frustum3js) {

        const webglRenderStates = this.renderer._webglRenderStates;
        const currentRenderState = webglRenderStates.get(scene, frameState.camera);
        currentRenderState.init();

        this.updateSunLight(frameState);
        this.updateBackground(frameState, camera3js, currentRenderState);
        this.projectObjects(scene, frameState, camera3js, currentRenderState, frustum3js);
        // this.createOrUpdateCommands(frameState,  currentRenderState);
        return currentRenderState;
    },

    /**
    *Cesium Primitive接口方法，渲染程序入口，必须实现才能最终渲染到cesium场景
    * @param {Cesium.FrameState}frameState
    * @param {Object3D}[scene]  
    * @param {Cesium.DrawCommand[]}[renderList]
    */
    update(frameState, scene, renderList) {
        if (frameState.mode !== Cesium.SceneMode.SCENE3D) return;
        this.init(frameState);

        if (!this._ready || (!scene && !this.show)) {//如果未准备好则不加入渲染队列
            return;
        }

        scene = scene || this;
        if (!scene.geometry && scene.children.length == 0) return;

        const isRenderToRenderTarget = !!renderList;
        const currentCamera = frameState.camera;

        this.updateSunLight(frameState);
        if (!isRenderToRenderTarget && frameState.passes.render) {
            this.mainCamera = currentCamera;
            this.beforeUpdate.raiseEvent(frameState);
        }

        /**
         * @type {WebGLRenderer}
         * @private
         */
        const renderer = this.renderer;
        const webgglShadowMap = renderer.shadowMap;
        /**
         * @type {WebGLRenderStates}
         */
        const webglRenderStates = renderer._webglRenderStates;
        const currentWebglRenderState = webglRenderStates.get(scene, currentCamera);
        const currentWebglRenderList = currentWebglRenderState.renderList;
        const backgroundMesh = this._backgroundMesh;
        const commandList = isRenderToRenderTarget ? renderList : frameState.commandList;

        //
        if (frameState.passes.offscreen || frameState.passes.depth || frameState.passes.pick) {
            if (this.mainCamera) webglRenderStates.get(scene, this.mainCamera).getDrawCommands(commandList, frameState);
            else currentWebglRenderList.getDrawCommands(commandList, frameState);
            return;
        };

        currentWebglRenderState.lights = this._lights;
        currentWebglRenderState.init();
        renderer._webglRenderItems.changingState.maxChangingCount = this.maxChangingCount;

        if (this._modelMatrixNeedsUpdate) {
            if (this._backgroundMesh) {
                this._backgroundMesh.modelMatrixNeedsUpdate = true
            }
            this.updateModelMatrix();
        }

        //

        var camera3js;
        var referenceFrame = currentCamera._referenceFrame || {
            matrix: this._actualModelMatrixYup,
            inverseMatrix: this._actualModelMatrixYupInverse
        };

        var _localClippingEnabled = false, _clippingEnabled = false;
        const clipping = renderer._clipping;


        if (currentCamera.isOrthographicCamera) {
            camera3js = CameraUtils.toOrthographicCamera3js(currentCamera, null, referenceFrame);
        }
        else {
            camera3js = CameraUtils.toPerspectiveCamera3js(currentCamera, null, referenceFrame);
        }
        if (!currentCamera._referenceFrame)
            camera3js._referenceFrame = referenceFrame;

        _localClippingEnabled = renderer.localClippingEnabled;
        _clippingEnabled = clipping.init(renderer.clippingPlanes, _localClippingEnabled, camera3js);

        currentWebglRenderState.clippingEnabled = _clippingEnabled
        currentWebglRenderState.localClippingEnabled = _localClippingEnabled

        //
        if (!isRenderToRenderTarget && frameState.passes.render) {
            scene.children.forEach(object => {
                //IRenderable
                if (object.isIRenderable && object.onBeforeRender) {
                    object.onBeforeRender(frameState, this.renderer, camera3js, currentWebglRenderState);
                }
            })
        }


        //

        const frustum3js = isRenderToRenderTarget ? CameraUtils.getFrustum3js(camera3js) : null;
        this.projectObjects(scene, frameState, camera3js, currentWebglRenderState, frustum3js);

        const dynamicRenderables=currentWebglRenderState.dynamicRenderables
        const renderables = currentWebglRenderState.renderables;
        const shadowsArray = currentWebglRenderState.shadowsArray;
        const lightsArray = currentWebglRenderState.lightsArray

        //onBeforeRender  

        if (_clippingEnabled === true) clipping.beginShadows();

        var camera3js2 = null, oldReferenceFrame = currentCamera._referenceFrame

        if (currentCamera.isOrthographicCamera)
            camera3js2 = CameraUtils.toOrthographicCamera3js(currentCamera, null, referenceFrame);
        else
            camera3js2 = CameraUtils.toPerspectiveCamera3js(currentCamera, null, referenceFrame)

        for (let i = 0; i < renderables.length; i++) {
            const object = renderables[i];

            if (!object.visible || !object.onBeforeRender || object.onBeforeRender == THREE.Object3D.prototype.onBeforeRender) {
                continue;
            }

            var referenceFrame = oldReferenceFrame || {
                matrix: this._actualModelMatrixYup,
                inverseMatrix: this._actualModelMatrixYupInverse
            };

            camera3js2._referenceFrame = referenceFrame;

            object.onBeforeRender(renderer, scene, camera3js2, this._scene);

            camera3js2._referenceFrame = oldReferenceFrame;

        }

        if (this.useSunLight && this._sunLight) {
            if (this._sunLight.castShadow && !frameState.shadowState.shadowsEnabled) {
                currentWebglRenderState.pushShadow(this._sunLight);
            }
        }
        //shadowMap 
        if (!webgglShadowMap.enabled) {
            shadowsArray.length = 0;
        }
        if (webgglShadowMap.autoUpdate) {
            webgglShadowMap.render(shadowsArray, scene, frameState, this);
        }

        //

        //更新灯光  
        if (lightsArray.length == 0) currentWebglRenderState.pushLight(this._defaultAmbientLight);
        if (this.useSunLight && this._sunLight) {
            currentWebglRenderState.pushLight(this._sunLight);
        }
        currentWebglRenderState.setupLights(currentCamera);
        //light extension:point lights 
        this.fixedLights.forEach(light => {
            this.updateExtensionLight(light, frameState);
        });
        this.partialLights.forEach(light => {
            this.updateExtensionLight(light, frameState);
        });
        this._fixedWebGLLights.setup(this.fixedLights, null, currentCamera, frameState);
        this._partialWebGLLights.setup(this.partialLights, null, currentCamera, frameState);

        //
        if (_clippingEnabled === true) clipping.endShadows();

        //

        this.createOrUpdateCommands(frameState, currentWebglRenderState, camera3js, frustum3js);

        //background
        var backgroundRenderItems;
        if (backgroundMesh) {
            this.updateBackground(frameState, camera3js, currentWebglRenderState);
            backgroundRenderItems = backgroundMesh.renderItems;
            if (!this.backgroundIsSkybox && backgroundRenderItems) {
                currentWebglRenderList.push(backgroundRenderItems[0]);
            }
        }

        currentWebglRenderList.getDrawCommands(commandList, frameState);

        //effect passes
        for (let i = 0; i < this.effects.length; i++) {
            const effect = this.effects[i];
            if (!effect.enabled || (!effect.preUpdate && !effect.preUpdate)) continue;
            if (!effect.name) effect.name = 'effect-' + Cesium.createGuid();

            effect.preUpdate(scene, camera3js, frameState, currentWebglRenderState);

            //render effect
            const effectSelected = effect.selected ? effect.selected : renderables;
            for (let j = 0; j < effectSelected.length; j++) {
                const object = effectSelected[j];
                if (object.isRuntimeMesh) continue;

                const renderItems = object.renderItems;
                const geometry = WebGLGeometries.get(object.geometry);
                const objectMaterial = object.material;
                const isMultiMaterial = Array.isArray(objectMaterial);
                for (let k = 0; k < renderItems.length; k++) {
                    const renderItem = renderItems[k];
                    const materialIndex = renderItem.materialIndex;
                    const material = isMultiMaterial ? objectMaterial[materialIndex] : objectMaterial;

                    if (object.onBeforeRender) object.onBeforeRender(renderer, scene, camera3js, geometry, material);

                    const drawCommand = renderer._webglRenderItems.getAndUpdateDerived(
                        object, geometry, material, renderItem, effect.name, frameState, currentWebglRenderState, camera3js
                    );
                    if (!drawCommand) continue;

                    if (object.onAfterRender) object.onAfterRender(renderer, scene, camera3js, geometry, material);

                    commandList.push(drawCommand);
                }
            }
            if (effect.postUpdate) effect.postUpdate(scene, camera3js, frameState, currentWebglRenderState);
        }

        // 
        const environmentState = this._scene._environmentState;
        const backgroundIsSkybox = this.backgroundIsSkybox && backgroundMesh
            && backgroundMesh.visible && backgroundMesh.renderItems;

        //BeforeFinalRender
        if (isRenderToRenderTarget) {

            if (environmentState.isMoonVisible && this.isMoonVisible)
                commandList.unshift(environmentState.moonCommand)

            if (environmentState.isSunVisible && this.isSunVisible)
                commandList.unshift(environmentState.sunDrawCommand)

            if (backgroundIsSkybox) {
                var skyboxCommand = backgroundRenderItems[0].drawCommand;
                commandList.unshift(skyboxCommand);
            }

            if (this.mainCamera != currentCamera)
                currentWebglRenderState.init()


        } else {

            for (let i = 0; i < renderables.length; i++) {
                var object = renderables[i]
                if (object.onBeforeFinalRender) {
                    object.onBeforeFinalRender(renderer, scene, camera3js2, this._scene)
                }
                endFrame(renderables[i]);
            }
            for (let i = 0; i < lightsArray.length; i++) {
                lightsArray[i].modelMatrixNeedsUpdate = false;
            }

            if (environmentState.skyAtmosphereCommand && backgroundIsSkybox) {
                var skyboxCommand = backgroundRenderItems[0].drawCommand;
                environmentState.isSkyAtmosphereVisible = true;
                if (backgroundMesh.material.uniforms.opacity.value > 0.5)
                    environmentState.skyAtmosphereCommand = skyboxCommand;
            }

            this.afterUpdate.raiseEvent(frameState);
            
            //清空渲染对象数组和光影数组
            renderables.length = 0;
            dynamicRenderables.length = 0;
            lightsArray.length = 0
            shadowsArray.length = 0
        }

        this._modelMatrixNeedsUpdate = false;
        this.frameNumber = frameState.frameNumber;

        this._environmentChanged = false;
    },
    /**
    *释放资源
    */
    destroy() {
        this.beforeDestroy.raiseEvent(this);
        this._ready = false;
        MeshVisualizer.traverseObject3D(this, (object) => {
            this.remove(object);
            object.dispose && object.dispose();
            object.destroy && object.destroy();
        }, false);

        this.renderer.dispose()

        for (var i in this._textureCache) {
            if (this._textureCache.hasOwnProperty(i)) {
                delete this._textureCache[i];
            }
        }

        this._textureCache = {};

        if (this._pickIds) {
            for (i = 0; i < this._pickIds.length; ++i) {
                this._pickIds[i].destroy && this._pickIds[i].destroy();
            }
        }
        this._pickIds.splice(0);
    },
    traverse(callback) {
        traverseObject3D(this, callback)
    }
};
 
/**
*
*遍历节点
*@param {Object3D}root
*@param {MeshVisualizer~TraverseCallback}traverseFunc 访问每个节点时回调该函数，进行相关操作。回调函数包含一个参数，traverseArgs，其中封装了一个属性cancelCurrent，可以通过改变此属性达到终止遍历当前节点的子节点
*@param {Boolean}visibleOnly visibleOnly为true时仅遍历可见的节点，如果父级节点不可见则不再访问其子节点
*@private
*/
MeshVisualizer.traverse = function (node, traverseFunc, visibleOnly, scratchTraverseArgs) {
    if (!node) {
        return;
    }
    if (!scratchTraverseArgs) {
        scratchTraverseArgs = {
            cancelCurrent: false,
            cancelAll: false
        };
    }
    scratchTraverseArgs.cancelCurrent = false;
    if (visibleOnly && (!node.show && !node.visible)) {
        return;
    }

    // if (node.isMeshVisModel && !node.visible) return;

    if (!(node instanceof MeshVisualizer)
        && ((node.geometry && node.material)
            || node.isLight || node.isGroup
            || node.isObject3D || node.isScene)
    ) {

        traverseFunc(node, scratchTraverseArgs);
    }

    // if (node.isMeshVisModel && node.root) node = node.root;

    const children = node.children;
    if (children) {
        for (var i = 0; i < children.length; i++) {
            if (scratchTraverseArgs.cancelCurrent) {
                continue;
            }
            if (scratchTraverseArgs.cancelAll) {
                break;
            }
            MeshVisualizer.traverse(node.children[i], traverseFunc, visibleOnly, scratchTraverseArgs);
        }
    } else if (node.scene) {
        MeshVisualizer.traverse(node.scene, traverseFunc, visibleOnly, scratchTraverseArgs);
    }
}


function traverseObject3D(node, callback, parent) {
    if (node.length) {
        for (let i = 0; i < node.length; i++) {
            const child = node[i];
            traverseObject3D(child, callback, node);
        }
    }
    else {
        callback(node, parent);
        const children = node.children;
        if (!children) return;
        const l = children.length;
        for (let i = 0; i < l; i++) {
            const child = children[i];
            traverseObject3D(child, callback, node);
        }
    }
}
MeshVisualizer.prototype.traverseObject3D = traverseObject3D

/**
*
*@MeshVisualizer~TraverseCallback
*@param {Mesh|LOD|MeshVisualizer|Object}node
*@param {Object}traverseArgs
*@param {Boolean}traverseArgs.cancelCurrent 为true时终止遍历当前节点的子节点
*@param {Boolean}traverseArgs.cancelAll 为true时终止遍历，退出遍历循环
*/


//MeshVisualizer属性
Object.defineProperties(MeshVisualizer.prototype, {
    children: {
        get() {
            return this._children;
        }
    },
    /**
    * @readonly
    * @type {Cesium.Matrix4}
    */
    modelMatrix: {
        get() {
            return this._modelMatrix;
        },
        set(val) {
            if (val) {
                this._modelMatrix = val;
                // this._matrixWorld.elements = this._modelMatrix
            }
        }
    },
    sunPositionLC: {
        get() {
            return this._sunPositionLC;
        }
    },
    sunDirectionLC: {
        get() {
            return this._sunDirectionLC;
        }
    },

    background: {
        get() {
            return this._background
        },
        set(background) {
            if (background && background.isColor) return;
            this._background = background;

            const backgroundMesh = this._backgroundMesh;
            if (backgroundMesh) {
                if (background) {
                    const material = backgroundMesh.material;
                    if (material.envMap != background) {
                        material.needsUpdate = true;
                    }
                    material.envMap = background;
                    backgroundMesh.visible = true;
                } else {
                    backgroundMesh.visible = false;
                }
            }
        }
    },
    backgroundSize: {
        get() {
            return this._backgroundSize;
        },
        set(backgroundSize) {
            backgroundSize = backgroundSize || 1;
            this._backgroundSize = backgroundSize;
            const backgroundMesh = this._backgroundMesh;
            if (backgroundMesh) {
                backgroundMesh.scale.setScalar(backgroundSize)
            }
        }
    },
    backgroundMesh: {
        get() {
            return this._backgroundMesh;
        }
    },

    /**
     * @type {THREE.CubeTexture}
     * @memberof MeshVisualizer.prototype
     */
    environment: {
        get() {
            return this._environment;
        },
        set(val) {
            const scope = this;
            const environment = scope._environment;
            if (val && val.isTexture) {
                scope._environment = val;
                scope._environmentChanged = true;
            } else if (environment) {
                let uuid = environment.uuid;
                let envMap = scope._textureCache[uuid];
                if (envMap && envMap._createByMeshVisualizer) {
                    envMap.destroy();
                    delete scope._textureCache[uuid];
                }
                scope._environment = val;
                scope._environmentChanged = true;
            }

        }
    },
    pickIds: {
        get() {
            return this._pickIds;
        }
    },
    /**
     * @type {Cesium.Scene}
     */
    scene: {
        set: function (val) {
            this._scene = val;
        },
        get: function () {
            return this._scene;
        }
    },
    /**
     * @type {Cesium.FrameState}
     */
    frameState: {
        get: function () {
            if (!this._scene) {
                return undefined;
            }
            return this._frameState;
        }
    },

    /**
     * @type {Boolean}
     */
    show: {
        get: function () {
            return this._show;
        },
        set: function (val) {
            this._show = val;
        }
    },

    /**
     * @type {Boolean}
     */
    ready: {
        get: function () {
            return this._ready;
        }
    },
    minRange: {
        get: function () {
            return this._minRange;
        },
        set: function (val) {
            const scope = this;
            if (scope._minRange != val) {
                scope._minRange = val
                scope._cameraChanged = true;
                requestAnimationFrame(() => {
                    scope._cameraChanged = false;
                })
            }
        }
    }
});

export default MeshVisualizer;
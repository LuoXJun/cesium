import Cesium from "@mesh-3d/cesium";
import * as THREE from '@mesh-3d/three'

export default class GeometryUtils {
    /**
     * 
     * @param {THREE.BufferGeometry} bufferGeometry3js 
     * @param {number}materialIndexOrGroupIndex
     * @param {boolean}[groupOptimized]
     * @returns {THREE.BufferGeometry}
     */
    static extractGeometry(bufferGeometry3js: THREE.BufferGeometry, materialIndexOrGroupIndex: number, groupOptimized?: boolean)
    /**
    * 
    * @param {THREE.BufferGeometry} bufferGeometry3js 
    * @param {number}materialIndexOrGroupIndex
    * @param {boolean}[groupOptimized]
    * @returns {number[]}
    */
    static genGeometryIndices(bufferGeometry3js: THREE.BufferGeometry, materialIndexOrGroupIndex: number, groupOptimized?: boolean): number[]

    /**
     * 
     * @param {THREE.BufferGeometry} bufferGeometry3js 
     * @param {number}materialIndexOrGroupIndex
     * @param {boolean}[groupOptimized]
     * @param {Cesium.BoundingSphere}[boundingSphere]
     * @returns {{boundingSphere:Cesium.BoundingSphere,indices:number[]}}
     */
    static computeBoundingSphereAndIndices(bufferGeometry3js: THREE.BufferGeometry, materialIndexOrGroupIndex: number, groupOptimized?: boolean, boundingSphere?: Cesium.BoundingSphere): { boundingSphere: Cesium.BoundingSphere, indices: number[] }

    /**
    *点绕x轴旋转，修改顶点坐标
    *@param {Cesium.Cartesian3}point
    *@param {Number}angle 弧度
    */
    static pointRotateX(point: Cesium.Cartesian3, angle: number): void

    /**
    *点绕y轴旋转，修改顶点坐标
    *@param {Cesium.Cartesian3}point
    *@param {Number}angle 弧度
    */
    static pointRotateY(point: Cesium.Cartesian3, angle: number): void
    /**
    *点绕z轴旋转，修改顶点坐标
    *@param {Cesium.Cartesian3}point
    *@param {Number}angle 弧度
    */
    static pointRotateZ(point: Cesium.Cartesian3, angle: number): void


    /**
    *绕x轴旋转，修改顶点坐标
    *@param {Cesium.Geometry}geometry
    *@param {Number}angle 弧度
    */
    static rotateX(geometry: Cesium.Geometry, angle: number): void
    /**
    *绕y轴旋转，修改顶点坐标
    *@param {Cesium.Geometry}geometry
    *@param {Number}angle 弧度
    */
    static rotateY(geometry: Cesium.Geometry, angle: number): void
    /**
    *绕z轴旋转，修改顶点坐标
    *@param {Cesium.Geometry}geometry
    *@param {Number}angle 弧度
    */
    static rotateZ(geometry: Cesium.Geometry, angle: number): void



    /**
     * 
     * @param {number[]} positions 
     * @param {number} index 
     * @returns {boolean}
     */
    static isValidVertex(positions: number[], index: number): boolean

    /**
     * 
     * @param {number[]} positions 
     * @param {number} a 
     * @param {number} b 
     * @param {number} c
     * @returns {boolean}
     */
    static isValidTriangle(positions: number[], a: number, b: number, c: number): boolean

    /**
     * 删除位置坐标有NaN的顶点，返回新的几何体
     * @param {THREE.BufferGeometry} geometry 
     * @returns {THREE.BufferGeometry} newGeometry
     */
    static removeInvalidVertices(geometry: THREE.BufferGeometry): THREE.BufferGeometry

    /**
     * 将几何体强制使用索引，以期减少几何内存占用，如果几何体的groups.length大于1，则返回undefined
     * @param {THREE.BufferGeometry} geometry 
     * @param {boolean}[removeUv2=false]
     * @param {boolean}[removeUv3=true]
     * @returns {undefined|THREE.BufferGeometry} newGeometry
     */
    static forceIndices(geometry: THREE.BufferGeometry, removeUv2: boolean, removeUv3: boolean): undefined | THREE.BufferGeometry


    /**
     * 
     * @param {THREE.BufferGeometry} geometry 
     * @returns {THREE.BufferGeometry}geometry
     */
    static clampToIndices(geometry: THREE.BufferGeometry): THREE.BufferGeometry

    /**
     * 
     * @param {Cesium.Geometry|THREE.BufferGeometry} geometry 
     * @returns {boolean}
     */
    static computeSurfaceArea(geometry: Cesium.Geometry | THREE.BufferGeometry): boolean


    /**
     * 比较两个几何体的顶点，如果所有顶点属性及其数值完全相同，则返回true，否则返回false。
     * @param {THREE.BufferGeometry} a 
     * @param {THREE.BufferGeometry} b 
     * @returns {boolean}
     */
    static geometryEquals(a: THREE.BufferGeometry, b: THREE.BufferGeometry): boolean

    /**
     * 
     * @param {(Cesium.Cartesian2|THREE.Vector2)[]} vertices 
     */
    static triangulate(vertices): Triangle[]


    /**
     * 
     * @param {Cesium.Cartesian3} p1 
     * @param {Cesium.Cartesian3} p2 
     * @param {Cesium.Cartesian3} p3 
     * @param {Cesium.Cartesian3} [result] 
     * @param {boolean} [normalized] 
     */
    static computeNormal(pA: Cesium.Cartesian3, pB: Cesium.Cartesian3, pC: Cesium.Cartesian3, result: Cesium.Cartesian3, normalized?: boolean): Cesium.Cartesian3


    /**
    *
    *@param {Cesium.Geometry}geometry
    */
    static computeVertexNormals(geometry: Cesium.Geometry)


    /**
    *合并两个或两个以上图形类型（primitiveType），属性数量、名称以及属性值的类型（GeometryAttribute的componentDatatype、componentsPerAttribute等）都一致的几何体
    *@param {Array<Cesium.Geometry>}geometries 
    *@return {Cesium.Geometry}
    */
    static mergeGeometries(geometries: Cesium.Geometry[]): Cesium.Geometry


    /**
     * 
     * @param {Cesium.Geometry[]} geometries 
     * @returns {Cesium.Geometry}
     */
    static mergeGroupedGeometries(geometries: Cesium.Geometry[]): Cesium.Geometry

    /**
     * 
     * @param {THREE.BufferGeometry[]} geometries 
     * @returns {THREE.BufferGeometry}
     */
    static mergeGeometries3js(geometries: THREE.BufferGeometry[]): THREE.BufferGeometry

    /**
    *
    *@param {Cesium.Geometry}geometry
    *@param {Cesium.Cartesian3}offset
    */
    static translate(geometry: Cesium.Geometry, offset: Cesium.Cartesian3)

    /**
    *
    *@param {TypeArray} array
    *@return {Cesium.ComponentDatatype}  
    */
    static getAttributeComponentType(array: Uint8Array | Uint32Array | Uint16Array | Float32Array): Cesium.ComponentDatatype

    /**
     * 
     * @param {{[key:string]:Cesium.GeometryAttribute|THREE.BufferAttribute}} srcAttributes 
     * @returns {{[key:string]:Cesium.GeometryAttribute|THREE.BufferAttribute}} newAttributes
     */
    static cloneGeometryAttributes(srcAttributes: { [key: string]: Cesium.GeometryAttribute | THREE.BufferAttribute }): { [key: string]: Cesium.GeometryAttribute | THREE.BufferAttribute }

    /**
     * 
     * @param {Cesium.Geometry} geometry 
     * @returns {Cesium.Geometry}
     */
    static cloneGeometry(geometry: Cesium.Geometry): Cesium.Geometry

    /**
    *
    *@param {Object}geometry
    *@return {Boolean}
    */
    static isGeometry3js(geometry): boolean

    /**
    *
    *@param {THREE.Geometry|THREE.BufferGeometry}geometry3js
    *@param {THREE.Mesh|THREE.Line|THREE.Points|THREE.Sprite}object
    *@param {boolean}[useCesiumNormal]
    *@return {Cesium.Geometry} 
    */
    static fromGeometry3js(geometry3js:  THREE.BufferGeometry, object: THREE.Mesh | THREE.Line | THREE.Points | THREE.Sprite, useCesiumNormal?: boolean)

    /**
     * 
     * @param {Cesium.Geometry} geometry 
     * @param {THREE.BufferGeometry} [result]
     * @returns {THREE.BufferGeometry} result
     */
    static toBufferGeometry3js(geometry: Cesium.Geometry, result?: THREE.BufferGeometry): THREE.BufferGeometry

    /**
    *@param {Cesium.Geometry|THREE.BufferGeometry}geometry
    *@param {Cesium.Cartesian3}[offset]
    *@return {CSG}
    */
    static toCSG(geometry: Cesium.Geometry | THREE.BufferGeometry, offset: Cesium.Cartesian3): Object

    /**
    *@param {CSG}csg_model
    *@param {Boolean}[toGeometry3js=false]
    *@return {Cesium.Geometry|THREE.BufferGeometry}
    */
    static fromCSG(csg_model: Object, toGeometry3js?: boolean): Cesium.Geometry | THREE.BufferGeometry

    /**
     * 
     * @param {THREE.Vec2[]} contour 
     * @param {THREE.Vec2[][]} holes 
     * @param {THREE.Vec2[]} outVertices 
     * @param {number[]} outIndices 
     */
    static triangulateShape(contour: THREE.Vec2[], holes: THREE.Vec2[][], outVertices: THREE.Vec2[], outIndices: THREE.Vec2[]): THREE.Vec2[]

    /**
     * 
     * @param {THREE.BufferGeometry} geometry 
     * @returns {number[]}
     */
    static genGeometryIndicesAll(geometry: THREE.BufferGeometry): number[]

    /**
     * 
     * @param {THREE.BufferGeometry} geometry3js 
     * @param {object}[options]
     * @param {object}[options.angleEpsilon=1] in degrees
     * @param {object}[options.removeCoplanar=true] 
     * @return {THREE.BufferGeometry} 
     */
    static toOutlineGeometry3js(geometry3js: THREE.BufferGeometry, options?: {
        /**
         * @default 1
         */
        angleEpsilon: number
        /**
         * @default true
         */
        removeCoplanar: boolean
    }): THREE.BufferGeometry

}

interface Triangle {
    a: number;
    b: number;
    c: number;

    // If the points of the triangle are collinear, then just find the
    // extremes and use the midpoint as the center of the circumcircle.
    x: number;
    y: number;
    r: number
}
 

let _polyfilled = false
/**
 * 处理cesium和threejs的部分差异，增加一些辅助属性。
 * @returns 
 * @private
 */
export default function polyfill() {
    if (_polyfilled) return;
    _polyfilled = true;

    const {
        Matrix4, Matrix3, Matrix2, Cartesian3, Cartesian2, Quaternion, OrthographicFrustum, Camera, ShaderProgram, defined, createUniform
    } = Cesium;

    Cartesian3.prototype.set = function (x, y, z) {
        this.x = x; this.y = y; this.z = z;
        return this
    }
    Cartesian3.prototype.copy = function (src) {
        this.x = src.x; this.y = src.y; this.z = src.z;
        return this
    }

    Cartesian2.prototype.set = function (x, y) {
        this.x = x; this.y = y;
        return this
    }
    Cartesian2.prototype.copy = function (src) {
        this.x = src.x; this.y = src.y;
        return this
    }
    Quaternion.prototype.set = function (x, y, z, w) {
        this.x = x; this.y = y; this.z = z; this.w = w;
        return this
    }
    Quaternion.prototype.copy = function (src) {
        this.x = src.x; this.y = src.y; this.z = src.z; this.w = src.w;
        return this
    }

    if (!OrthographicFrustum.prototype.isOrthographicFrustum) {
        OrthographicFrustum.prototype.isOrthographicFrustum = true;
        Object.defineProperties(Camera.prototype, {
            isOrthographicCamera: {
                get: function () {
                    return this.frustum && this.frustum.isOrthographicFrustum == true
                }
            }
        })
    }

    // 修改Cesium.ShaderProgram.prototype._setUniforms：使cesium支持元素为自定义类型的uniform数组

    ShaderProgram.prototype._setUniforms = function (
        uniformMap,
        uniformState,
        validate
    ) {
        var len;
        var i;

        if (defined(uniformMap)) {

            if (!this._makeSupportStructureUniformsDone) {
                modifyUniforms(this);
                this._makeSupportStructureUniformsDone = true;
            }

            var manualUniforms = this._manualUniforms;

            len = manualUniforms.length;
            for (i = 0; i < len; ++i) {

                var mu = manualUniforms[i];
                //>>includeStart('debug', pragmas.debug);
                if (!uniformMap[mu.name]) {
                    console.error('uniform ' + mu.name + " is undefined");
                    debugger
                }
                //>>includeEnd('debug');
                mu.value = uniformMap[mu.name]();

            }
        }

        var automaticUniforms = this._automaticUniforms;
        len = automaticUniforms.length;
        for (i = 0; i < len; ++i) {
            var au = automaticUniforms[i];
            au.uniform.value = au.automaticUniform.getValue(uniformState);
        }

        ///////////////////////////////////////////////////////////////////

        // It appears that assigning the uniform values above and then setting them here
        // (which makes the GL calls) is faster than removing this loop and making
        // the GL calls above.  I suspect this is because each GL call pollutes the
        // L2 cache making our JavaScript and the browser/driver ping-pong cache lines.
        var uniforms = this._uniforms;
        len = uniforms.length;
        for (i = 0; i < len; ++i) {
            uniforms[i].set();
        }

        if (validate) {
            var gl = this._gl;
            var program = this._program;

            gl.validateProgram(program);
            //>>includeStart('debug', pragmas.debug);
            // if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {
            //     throw new _Cesium.DeveloperError(
            //         "Program validation failed.  Program info log: " +
            //         gl.getProgramInfoLog(program)
            //     );
            // }
            //>>includeEnd('debug');
        }
    }; 
    function modifyUniforms(shaderProgram) {

        var sp = shaderProgram, gl = sp._gl;
        var uniformsByName = sp._uniformsByName;//先获取所有已经定义的uniform，触发内部逻辑，才能取到program
        var program = sp._program;
        var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

        for (var i = 0; i < numUniforms; i++) {
            var info = gl.getActiveUniform(program, i);
            var uniformName = info.name;
            var indexOfBracket = uniformName.indexOf("[");
            if (indexOfBracket >= 0) {
                var uniformArray = uniformsByName[uniformName.slice(0, indexOfBracket)];
                if (defined(uniformArray)) {
                    continue;
                }

                if (!uniformsByName[info.name]) {
                    var loc = gl.getUniformLocation(program, info.name);
                    var uniform = createUniform(
                        gl, info, info.name, loc
                    );
                    sp._uniformsByName[info.name] = uniform;
                    sp._uniforms.push(uniform);
                    sp._manualUniforms.push(uniform);

                }
            }
        }
    }

    //给Cesium的矩阵加上elements，使其能参与threejs的矩阵运算
    if (!Matrix4.prototype.__patched__) {
        Matrix4.prototype.__patched__ = true;
        Object.defineProperties(Matrix4.prototype, {
            elements: {
                get() {
                    return this;
                }
            }
        })

        Object.defineProperties(Matrix3.prototype, {
            elements: {
                get() {
                    return this;
                }
            }
        })

        Object.defineProperties(Matrix2.prototype, {
            elements: {
                get() {
                    return this;
                }
            }
        })
    }

    if (typeof THREE != 'undefined' && !THREE.Material.prototype.__patched__) {

        const { Material, Color, Object3D } = THREE;
        Material.prototype.__patched__ = true

        //给threejs 的Material加上一些辅助属性
        Object.defineProperties(Material.prototype, {
            renderStateNeedsUpdate: {
                set() {
                    this.renderStateVersion++;
                }
            },
            renderStateVersion: {
                get() {
                    if (this._renderStateVersion == undefined) this._renderStateVersion = 0;
                    return this._renderStateVersion;
                },
                set(val) {
                    this._renderStateVersion = val
                }
            },
            autoRefresh: {
                get() {
                    if (this._autoRefresh == undefined) this._autoRefresh = true;
                    return this._autoRefresh;
                },
                set(val) {
                    this._autoRefresh = val;
                }
            },
            translucent: {
                get() {
                    if (this._translucent == undefined) this._translucent = false;
                    return this._translucent;
                },
                set(val) {
                    if (this._translucent != val) {
                        this._translucent = val;
                        this.needsUpdate = true;
                    }
                }
            }
        })

        //给threejs的Color加上red,green,blue,alpha，使其能参与Cesium Color的运算
        Object.defineProperties(Color.prototype, {
            red: {
                get() {
                    return this.r;
                },
                set(val) {
                    this.r = val;
                }
            },
            green: {
                get() {
                    return this.g;
                },
                set(val) {
                    this.g = val;
                }
            },
            blue: {
                get() {
                    return this.b;
                },
                set(val) {
                    this.b = val;
                }
            },
            alpha: {
                get() {
                    return 1;
                },
                set(val) { }
            }
        })

        //给Object3D加上一些辅助属性(如modelMatrix等)
        const emptyInstances = [], emptyInstancedAttributes = [];
        Object.defineProperties(Object3D.prototype, {
            modelMatrixNeedsUpdate: {
                get() {
                    if (this._modelMatrixNeedsUpdate == undefined) this._modelMatrixNeedsUpdate = true;
                    return this._modelMatrixNeedsUpdate;
                },
                set(val) {
                    this._modelMatrixNeedsUpdate = val;
                }
            },
            modelMatrix: {
                get() {
                    if (this._modelMatrix == undefined) this._modelMatrix = Matrix4.IDENTITY.clone();
                    return this._modelMatrix;
                },
                set(val) {
                    this._modelMatrix = val;
                }
            },
            maxVisibleDistance: {
                get() {
                    if (!this._maxVisibleDistance) this._maxVisibleDistance = Infinity;
                    return this._maxVisibleDistance;
                },
                set(val) {
                    if (this._maxVisibleDistance != val) {
                        this._maxVisibleDistance = val;
                        var len = this.children
                        for (var i = 0; i < len; i++) {
                            const child = this.children[i];
                            if (child._maxVisibleDistance == Infinity) child.maxVisibleDistance = val;
                        }
                    }
                }
            },

            instances: {
                get() {
                    if (!this._instances) this._instances = emptyInstances;
                    return this._instances;
                },
                set(val) {
                    if (this._instances != val) {
                        this._instances = val;
                        var len = this.children.length;
                        for (var i = 0; i < len; i++) {
                            const child = this.children[i];
                            if (child._instances == emptyInstances) child.instances = val;
                        }
                        if (val && val.length > 0) {
                            this._isCustomInstancedMesh = true;
                        } else {
                            this._isCustomInstancedMesh = false;
                        }
                    }

                }
            },
            instancedAttributes: {
                get() {
                    if (!this._instancedAttributes) this._instancedAttributes = emptyInstancedAttributes;
                    return this._instancedAttributes;
                },
                set(val) {
                    if (this._instancedAttributes != val) {
                        this._instancedAttributes = val;
                        var len = this.children;
                        for (var i = 0; i < len; i++) {
                            const child = this.children[i];
                            if (child._instancedAttributes == emptyInstancedAttributes) child.instancedAttributes = val;
                        }
                    }
                }
            },
            isCustomInstancedMesh: {
                get() {
                    if (this._isCustomInstancedMesh == undefined) this._isCustomInstancedMesh = false;
                    return this._isCustomInstancedMesh;
                }
            }

        });


        //修改updateMatrixWorld方法，通知对象更新modelMatrix
        Object3D.prototype._updateMatrixWorld = Object3D.prototype.updateMatrixWorld;
        Object3D.prototype.updateMatrixWorld = function (force) {

            if (this.matrixAutoUpdate) this.updateMatrix();

            if (this.matrixWorldNeedsUpdate || force) {

                if (this.parent === null) {

                    this.matrixWorld.copy(this.matrix);

                } else {

                    this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);

                }

                this.matrixWorldNeedsUpdate = false;

                force = true;

                //

                this.modelMatrixNeedsUpdate = true;
            }

            // update children

            const children = this.children;

            for (let i = 0; i < children.length; i++) {

                children[i].updateMatrixWorld(force);

            }

        }

    }

}


import {
    MathUtils,
    Euler,
    AmbientLight,
    PerspectiveCamera,
    Scene,
    WebGLRenderer,
    Color,
    EventDispatcher,
    Object3D,
    Vector2,
    Vector3,
    Sphere,
    Box3,
    MOUSE,
    TOUCH,
    LinearInterpolant,
    QuaternionLinearInterpolant,
    Matrix4,
    Frustum
} from '@mesh-3d/three';
import { OrbitControls, MapControls } from '@mesh-3d/three/examples/jsm/controls/OrbitControls.js';
import { EffectComposer } from '@mesh-3d/three/examples/jsm/postprocessing/EffectComposer';
import { RenderPass } from '@mesh-3d/three/examples/jsm/postprocessing/RenderPass';
import Stats from '@mesh-3d/three/examples/jsm/libs/stats.module.js';

let _sizeVec2 = new Vector2()
let _vector3 = new Vector3()
let _sphere = new Sphere()
let _box3 = new Box3()
let _euler = new Euler()

const _frustum = new Frustum();
const _projScreenMatrix = new Matrix4();

/**
 * 
 * @param {OrbitControls} controls 
 * @param {*} type 
 * @private
 */
function setControlType(controls, type) {
    let { mouseButtons, touches } = controls;
    if (type == 'map') {
        controls.screenSpacePanning = false;

        mouseButtons.LEFT = MOUSE.PAN;
        mouseButtons.RIGHT = MOUSE.ROTATE;

        touches.ONE = TOUCH.PAN;
        touches.TWO = TOUCH.DOLLY_ROTATE;

        controls.maxAzimuthAngle = Math.PI * 2
        controls.maxPolarAngle = Math.PI * 2
        controls.minPolarAngle = -Math.PI * 2

        controls.enableDamping = false; // an animation loop is required when either damping or auto-rotation are enabled
        controls.dampingFactor = 0.05;

    } else {
        controls.screenSpacePanning = true;

        mouseButtons.LEFT = MOUSE.ROTATE;
        mouseButtons.RIGHT = MOUSE.PAN;

        touches.ONE = TOUCH.ROTATE;
        touches.TWO = TOUCH.DOLLY_PAN;
    }
}

/**
 * 
 * @param {PerspectiveCamera} camera 
 * @param {Object3D|{boundingSphere:Sphere,[prop:string]:any}} object 
 * @param {*} options 
 * @returns 
 * @private
 */
function _lookAt(camera, object, options) {
    options = options || {}
    const DEG2RAD = MathUtils.DEG2RAD;
    let { heading, pitch, range } = options;
    range = range || 0; pitch = pitch || 0; heading = heading || 0;

    if (object.boundingSphere) {
        _sphere.copy(object.boundingSphere)
    } else {
        _box3.setFromObject(object);
        _sphere.setFromPoints([_box3.min, _box3.max])
    }

    let r = _sphere.radius, d = 0;
    if (r == 0 || isNaN(r)) return;

    const fovRad = DEG2RAD * camera.fov,
        tanFov = Math.tan(fovRad),
        sinFov = Math.sin(fovRad);

    if (!tanFov) return;

    // let h = r - sinFov * r;
    // d = 2 * (r + h / tanFov) + range;
    d = 2 * r * (1 + (1 - sinFov) / tanFov) + range;

    _vector3.set(0, 1, 0);
    _euler.set(pitch * DEG2RAD, 0, -heading * DEG2RAD);
    _vector3.applyEuler(_euler)
    _vector3.multiplyScalar(d).add(_sphere.center)

    return {
        eyePosition: _vector3,
        target: _sphere.center,
        distance: d,
        radius: _sphere.radius
    }

}

/**
 * 
 * @param {PerspectiveCamera} camera 
 * @param {Vector3} target 
 * @param {*} options 
 * @returns 
 */
function _lookAtPosition(camera, target, options) {
    options = options || {}
    const DEG2RAD = MathUtils.DEG2RAD;
    let { heading, pitch, range } = options;
    range = range || 1; pitch = pitch || 0; heading = heading || 0;

    let r = 0, d = range;

    const fovRad = DEG2RAD * camera.fov,
        tanFov = Math.tan(fovRad),
        sinFov = Math.sin(fovRad);

    if (!tanFov) return;

    r = d / (2 * (1 + (1 - sinFov) / tanFov));

    _vector3.set(0, 1, 0);
    _euler.set(pitch * DEG2RAD, 0, -heading * DEG2RAD);
    _vector3.applyEuler(_euler)
    _vector3.multiplyScalar(d).add(target)

    return {
        eyePosition: _vector3,
        target: target,
        distance: d,
        radius: r
    }

}


function updateTimeUniform(material) {
    if (material.uniforms && material.uniforms.datetime) {
        material.uniforms.datetime.value = performance.now();
    }
}

function updateTimeMaterial(object) {
    object.traverseVisible(obj => {
        let material = obj.material
        if (!material) return;
        if (Array.isArray(material)) {
            material.forEach(updateTimeUniform)
        } else {
            updateTimeUniform(material);
        }
    })
}

export default class MeBaseViewer extends EventDispatcher {

    constructor(options) {

        options = options || {};

        super()

        this.defaultCameraPosition=options.defaultCameraPosition;

        /**
         * @type {HTMLElement}
         * @private
         */
        this._container = null;
        /**
         * @type {Scene}
         * @private
         */
        this._scene = null;
        /**
         * @type {PerspectiveCamera}
         * @private
         */
        this._camera = null;
        /**
         * @type {WebGLRenderer}
         * @private
         */
        this._renderer = null;
        /**
         * @type {MapControls|OrbitControls}
         * @private
         */
        this._controls = null;
        /**
         * @type {'orbit'|'map'}
         * @private
         */
        this._controlType = options.controlType || 'orbit';

        this._controlType0 = this._controlType;

        this._autoRender = typeof options.autoRender == 'boolean' ? options.autoRender : true;

        this._stats = options.stats || false;
        this._pixelRatio = options.pixelRatio || devicePixelRatio;
        this._logarithmicDepthBuffer = options.logarithmicDepthBuffer;
        this._ambient = null;
        this._background = options.background || null;
        this._environment = null
        this.modelMatrix = new Matrix4().identity()
        this._actualModelMatrixYup = new Matrix4().identity()
        this._actualModelMatrixXup = new Matrix4().identity()
        this._actualModelMatrix = new Matrix4().identity()
        this._frameState = {
            frameNumber: 0
        }

        this.visible = typeof options.visible == 'boolean' ? options.visible : true;

        /**
         * @type {Mesh3D.IRenderable}
         * @private
         */
        this._renderables = [];

        this._ready = false;

        let container = options.container;
        if (container) {
            container = typeof container == 'string' ? document.querySelector('#' + container) : container
            this.init(container)
        }
    }

    //readonly

    get ambient() {
        return this._ambient;
    }
    get ready() {
        return this._ready;
    }
    get container() {
        return this._container;
    }
    get camera() {
        return this._camera;
    }
    get scene() {
        return this._scene;
    }
    get renderer() {
        return this._renderer;
    }
    get controls() {
        return this._controls;
    }

    //read&write

    set controlType(type) {
        if (this._controlType !== type) {
            this._controlType = type;
            this.controls && setControlType(this.controls, type)
            this._controlType0 = this._controlType;
        }
    }
    get controlType() {
        return this._controlType
    }

    get background() {
        return this._background
    }
    set background(val) {
        if (this._background != val) {
            this._background = val;
            if (this.ready) {
                this.scene.background = val
            }
        }
    }

    get environment() {
        return this._environment
    }
    set environment(val) {
        if (this._environment != val) {
            this._environment = val;
            if (this.ready) {
                this.scene.environment = val
            }
        }
    }

    get composer() {
        if (!this.ready) {
            throw new Error('Mesh3D.MeBaseViewer:显示器未初始化，无法获取composer属性。')
        }
        return this._composer;
    }

    get pixelRatio() {
        if (!this.ready) {
            throw new Error('Mesh3D.MeBaseViewer:显示器未初始化，无法获取pixelRatio属性。')
        }
        return this.renderer.getPixelRatio()
    }

    get size() {
        this.renderer.getSize(_sizeVec2);
        return {
            width: _sizeVec2.x,
            height: _sizeVec2.y
        }
    }

    //methods

    init(pContainer) {
        if (this.ready) return this;

        let scope = this, container = pContainer, scene, renderer, camera, controls, ambient, composer, renderableRoot, stats;
        const width = container.clientWidth, height = container.clientHeight;

        //scene
        scene = new Scene();
        scene.matrixAutoUpdate=false;
        
        if (this._background) scene.background = this._background;
        renderableRoot = new Object3D();
        renderableRoot.matrixAutoUpdate=false
        renderableRoot.frustumCulled=false
        scene.add(renderableRoot)

        //lights
        ambient = new AmbientLight('#fff', 1);
        scene.add(ambient);

        //camera
        camera = new PerspectiveCamera(60, width / height, 0.001, 1000000)
        camera.position.set(height, height, height)
        if(this.defaultCameraPosition){
            camera.position.copy(this.defaultCameraPosition)
        }
        camera.lookAt(0, 0, 0)

        //renderer
        renderer = new WebGLRenderer({
            alpha: !this._background || this._background.isColor,
            antialias: true,
            premultipliedAlpha: true,
            preserveDrawingBuffer: true,
            logarithmicDepthBuffer: this._logarithmicDepthBuffer
        })
        renderer.setSize(width, height);
        renderer.setPixelRatio(this._pixelRatio)

        let setPixelRatio = renderer.setPixelRatio;
        renderer.setPixelRatio = (pixelRatio) => {
            setPixelRatio.call(renderer, pixelRatio)
            this._pixelRatio = pixelRatio
        }

        //postprocess
        composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));

        //stats
        if (typeof this._stats == 'boolean' && this._stats) {
            stats = new Stats();
            container.appendChild(stats.dom);
        }

        //controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.minDistance = 0.001
        function onControlsChange() {
            if (!scope || scope._autoRender) return
            scope.render()
        }
        controls.addEventListener('change', onControlsChange);

        //resize
        function onWindowResize() {
            if (!scope) return;
            scope.resize()
        }
        window.addEventListener('resize', onWindowResize);

        //dispose
        this.addEventListener('dispose', function () {
            controls.removeEventListener('change', onControlsChange);
            window.removeEventListener('resize', onWindowResize);

            container.removeChild(renderer.domElement)
            if (stats) container.removeChild(stats.dom)

            scope = ambient = renderer = camera = controls = scene = container = null;
        })

        //animate
        function animate() {
            if (!scope) return;
            requestAnimationFrame(animate)
            if (scope._autoRender) {
                scope.update()
            }
        }

        container.appendChild(renderer.domElement);

        this._renderer = renderer;
        this._scene = scene;
        this._ambient = ambient;
        this._camera = camera;
        this._controls = controls;
        this._container = container;
        this._composer = composer;
        this._renderableRoot = renderableRoot;
        this._stats = stats || false;
        this._ready = true

        setControlType(controls, this.controlType);

        animate();

        requestAnimationFrame(() => {
            this.dispatchEvent({
                type: 'ready'
            });
        })

        return this;
    }

    resize() {
        if (!this.ready) return;
        const { container, camera, renderer, _autoRender, composer } = this;
        const width = container.clientWidth, height = container.clientHeight;
        const aspect = width / height;

        const frustumHeight = camera.top - camera.bottom;

        camera.left = - frustumHeight * aspect / 2;
        camera.right = frustumHeight * aspect / 2;

        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
        composer.setSize(width, height);

        if (_autoRender) this.render();
    }

    render(deltaTime) {
        if (!this.ready) return;

        const { renderer, scene, camera, composer, _renderableRoot, _stats } = this

        if (_stats) _stats.begin();
        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        _frustum.setFromProjectionMatrix(_projScreenMatrix);

        this.dispatchEvent({
            type: 'prerender'
        })

        //for IRenderable

        _renderableRoot.clear()

        let renderables = this._renderables;
        let renderList = [], fs = {
            renderer: renderer,
            camera: camera,
            frustum: _frustum,
            projScreenMatrix: _projScreenMatrix,
            frameNumber: this._frameState.frameNumber++
        };
        for (let i = 0; i < renderables.length; i++) {
            const renderable = renderables[i];
            renderable.render(fs, renderList)
        }
        for (let i = 0; i < renderList.length; i++) {
            const renderableObject3d = renderList[i];
            _renderableRoot.add(renderableObject3d);
        }

        //render

        updateTimeMaterial(scene)

        if (composer.passes.length > 1) {
            composer.render(deltaTime)
        } else {
            renderer.render(scene, camera);
        }

        this.dispatchEvent({
            type: 'postrender'
        })

        if (_stats) _stats.end();
    }

    update() {
        if (!this.ready || !this.visible) return;
        if (!this._flying) this.controls.update()
        this.render();
    }

    pause() {
        this._autoRender = false;
        return this;
    }

    play() {
        this._autoRender = true;
        return this;
    }

    dispose() {

        this.removeAll(true);
        this.remove(this.ambient);

        if (this.renderer) {
            this.renderer.clear()
        }

        this.dispatchEvent({
            type: 'dispose'
        });

        this._autoRender = false;
        this._renderer = null;
        this._camera = null;
        this._controls = null;
        this._scene = null;
        this._container = null;
        this._ambient = null;
        this._background = null;
        this._environment = null
    }
 
    //

    /**
     * 添加对象
     * @param {Object3D|Mesh3D.IRenderable} object 
     */
    add(object) {
        if (object.isObject3D) {
            this.scene.add(object)
        } else {
            let renderables = this._renderables
            if (renderables.indexOf(object) == -1) {
                renderables.push(object)
            }
            object.visualizer = this;
            if (object.onAdded) object.onAdded();
        }
        return this;
    }

    /**
     * 移除对象
     * @param {Object3D|Mesh3D.IRenderable} object 
     * @param {boolean} [dispose=false]
     */
    remove(object, dispose) {
        if (object.isObject3D) {//移除Object3D

            if (dispose) {
                object.traverse(child => {
                    let { geometry, material } = child
                    if (geometry) {
                        geometry.dispose()
                    }
                    if (material) {
                        var materials = Array.isArray(material) ? material : [material]
                        for (let j = 0; j < materials.length; j++) {
                            materials[j].dispose();
                        }
                    }

                    child.dispatchEvent({
                        type: 'dispose'
                    })

                })
            }

            this.scene.remove(object);
        }
        else {//移除IRenderable

            let renderables = this._renderables
            var idx = renderables.indexOf(object)
            if (idx >= 0) {
                renderables.splice(idx, 1)
            }
            if (!object.onRemoved) {
                var renderList = [];
                object.render({}, renderList);
                for (let i = 0; i < renderList.length; i++) {
                    const renderableObject3d = renderList[i];
                    this.remove(renderableObject3d, dispose);
                }
            }
            else {
                object.onRemoved(this);
            }

        }
        return this
    }

    /**
     * 
     * @param {boolean} [dispose=false] 
     * @returns 
     */
    removeAll(dispose) {
        if (!this.ready) return;

        this.environment = null;
        this.background = null;

        var objs = this.scene.children.slice(), l = objs.length
        for (let i = 0; i < objs.length; i++) {
            const obj = objs[i];
            this.remove(obj, dispose);
        }
        objs = this._renderables.slice(), l = objs.length;
        for (let i = 0; i < l; i++) {
            const obj = objs[i];
            this.remove(obj, dispose);
        }
        this.add(this.ambient)
        this.update();
        return this
    }

    /**
     * 将视野锁定到目标对象
     * @param {Object3D|Vector3|{boundingSphere:Sphere,[prop:string]:any}null|} object  
     * @param {{ 
     * heading:number
     * pitch:number
     * range:number
     * }} [options] 
     */
    lookAt(object, options) {

        const { camera, controls, _autoRender, _controlType0 } = this;

        if (!object) {
            this._controlType = _controlType0;
            setControlType(controls, _controlType0);
            if (!_autoRender) {
                this.update()
            }
            return
        }

        let lookAtParams
        if (object.isObject3D || object.boundingSphere) {
            lookAtParams = _lookAt(camera, object, options);
        } else {
            lookAtParams = _lookAtPosition(camera, object, options);
        }
        if (!lookAtParams) {
            return;
        }

        let { eyePosition, radius, distance, target } = lookAtParams;
        camera.position.copy(eyePosition);
        var panOffset = new Vector3()
        panOffset.subVectors(target, controls.target0)
        controls.position0.copy(eyePosition)
        controls.target0.copy(target)
        controls.target.copy(target)

        // controls.update()
        controls.reset()

        if (!_autoRender) {
            this.update()
        }

        this._controlType = 'orbit';

        setControlType(controls, 'orbit');

        return {
            radius: radius,
            distance: distance,
            eyePosition,
            target
        }

    }

    /**
     * 将视野锁定到目标对象
     * @param {Object3D|Vector3|{boundingSphere:Sphere,[prop:string]:any}null|} object  
     * @param {{ 
     * heading:number
     * pitch:number
     * range:number
     * }} [options] 
     */
    setView(object, options) {

        this.lookAt(object, options);
        requestAnimationFrame(() => {
            setControlType(this.controls, this._controlType0);
        })

    }

    /**
     * 从相机当前位置飞行到目标对象
     * @param {Object3D|Vector3|null} object 
     * @param {{ 
     * heading?:number
     * pitch?:number
     * range?:number
     * duration?:number
     * complete?:()=>void
     * }} [options] 
     */
    flyTo(object, options) {

        let scope = this;
        if (scope._flying || !object) return;

        options = options || {};
        var onDone = options.complete;
        const duration = options.duration || 3000;
        let camera = scope.camera, controls = scope.controls,
            { position, quaternion } = camera;

        var positions = [], quaternions = [], times = [0, duration];
        position.toArray(positions)
        quaternion.toArray(quaternions)

        let lookAtParams
        if (object.isObject3D || object.boundingSphere) {
            lookAtParams = _lookAt(camera, object, options);
        } else {
            lookAtParams = _lookAtPosition(camera, object, options);
        }

        if (!lookAtParams) {
            return
        }
        const { eyePosition, radius, distance, target } = lookAtParams
        position.copy(eyePosition)
        camera.lookAt(target)

        position.toArray(positions, 3)
        quaternion.toArray(quaternions, 4)

        //restore
        position.fromArray(positions);
        quaternion.fromArray(quaternions);

        //LinearInterpolant
        var positionInterp = new LinearInterpolant(times, positions, 3);
        var quaternionInterp = new QuaternionLinearInterpolant(times, quaternions, 4);

        let _autoRender = scope._autoRender;
        scope._autoRender = false;

        scope._flying = true;

        var time = 0, timeStep = 1000 / 60;
        function animate() {

            time += timeStep;
            if (time >= duration) {
                time = duration;
            } else {
                requestAnimationFrame(animate);
            }

            var tempPosition = positionInterp.evaluate(time)
            var tempQuaternion = quaternionInterp.evaluate(time)
            position.fromArray(tempPosition);
            quaternion.fromArray(tempQuaternion);

            scope.update();

            if (time == duration) {
                controls.target.copy(target)
                scope._flying = false;
                scope._autoRender = _autoRender;
                camera = positionInterp = quaternionInterp = null;
                positions = [], quaternions = [], times = [];

                if (onDone) {
                    requestAnimationFrame(onDone)
                }
                scope = controls = null
            }
        }

        animate();

        return {
            radius: radius,
            distance: distance,
            eyePosition,
            target
        }
    }
}
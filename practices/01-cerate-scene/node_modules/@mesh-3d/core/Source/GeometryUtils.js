
// import { CSG } from '../util/CSG.js' 
// import { simplify_three } from './MeshEditor/ThirdParty/modify.js';
// import subdivUVNormalized from './TexturePacker.js';

/**
 * 
 * @param {Cesium.Cartesian3} pa 
 * @param {Cesium.Cartesian3} pb 
 * @param {Cesium.Cartesian3} pc 
 * @returns {number}
 */
function computeArea(pa, pb, pc) {

    if (!pa || !pb || !pc) {
        console.warn(pa, pb, pc);
        return 0;
    }
    const Cartesian3 = Cesium.Cartesian3
    let a = Cartesian3.distance(pa, pb);
    let b = Cartesian3.distance(pb, pc);
    let c = Cartesian3.distance(pa, pc);

    let p = (a + b + c) / 2, S = Math.sqrt(p * (p - a) * (p - b) * (p - c))
    return S;
}

/**
*
*@constructor 
*/
function GeometryUtils() { }

function getAttrs(geo) {
    var attrNames = [];

    for (var name in geo.attributes) {
        if (geo.attributes.hasOwnProperty(name) && geo.attributes[name]) {
            attrNames.push(name);
        }
    }
    return attrNames
}

var Matrix3, Matrix4, Cartesian3, Cartesian2, BoundingSphere, GeometryAttribute, ComponentDatatype;

var scratchPosition;//= new Cesium.Cartesian3();
var scratchMatrix4;//= new Cesium.Matrix4();
var scratchRotation;//= new Cesium.Matrix3();
var scratchOffset;//= new Cesium.Cartesian3();
var _scratchCB, _scratchAB;
var constantsHasInit = false;
function initConstants$GeometryUtils() {
    if (constantsHasInit) return;
    constantsHasInit = true;

    const _Cesium = Cesium;
    Matrix3 = _Cesium.Matrix3;
    Matrix4 = _Cesium.Matrix4;
    Cartesian3 = _Cesium.Cartesian3;
    Cartesian2 = _Cesium.Cartesian2;
    BoundingSphere = _Cesium.BoundingSphere;
    GeometryAttribute = _Cesium.GeometryAttribute;
    ComponentDatatype = _Cesium.ComponentDatatype;

    scratchPosition = new Cartesian3();
    scratchMatrix4 = new Matrix4();
    scratchRotation = new Matrix3();
    scratchOffset = new Cartesian3();
    _scratchCB = new Cartesian3();
    _scratchAB = new Cartesian3();

}
/**
 * 
 * @param {THREE.BufferGeometry} bufferGeometry3js 
 * @param {number}materialIndexOrGroupIndex
 * @param {boolean}[groupOptimized]
 * @returns {THREE.BufferGeometry}
 */
function extractGeometry(bufferGeometry3js, materialIndexOrGroupIndex, groupOptimized) {
    const geometry = bufferGeometry3js;
    const srcAttributes = geometry.attributes;
    const newGeometry = new THREE.BufferGeometry();

    var indices = genGeometryIndices(bufferGeometry3js, materialIndexOrGroupIndex, groupOptimized);

    for (const name in srcAttributes) {
        const attribute = srcAttributes[name];
        const itemSize = attribute.itemSize;
        const srcArray = attribute.array;
        const normalized = attribute.normalized;
        const dstArray = new srcArray.constructor(indices.length * itemSize);
        var idx = 0;
        for (let i = 0; i < indices.length; i++) {
            const ptr = indices[i] * itemSize;
            for (let j = 0; j < itemSize; j++) {
                dstArray[idx++] = srcArray[ptr + j];
            }
        }
        const newAttribute = new THREE.BufferAttribute(dstArray, itemSize, normalized)
        newGeometry.setAttribute(name, newAttribute);
    }

    indices = null;

    return newGeometry;

}
GeometryUtils.extractGeometry = extractGeometry

/**
 * 
 * @param {THREE.BufferGeometry} bufferGeometry3js 
 * @param {number}materialIndexOrGroupIndex
 * @param {boolean}[groupOptimized]
 * @returns {number[]}
 */
function genGeometryIndices(bufferGeometry3js, materialIndexOrGroupIndex, groupOptimized) {
    const geometry = bufferGeometry3js;
    const position = geometry.attributes.position;
    const groups = geometry.groups;
    const drawRange = geometry.drawRange;

    var index = geometry.index, indices = [], vertCount = position.count;

    if (index) {
        // indexed buffer geometry

        if (groups && groups.length > 0) {

            for (let i = 0, il = groups.length; i < il; i++) {

                const group = groups[i];
                if (!groupOptimized) {
                    if (i != materialIndexOrGroupIndex) continue;
                }
                else if (group.materialIndex != materialIndexOrGroupIndex) continue;

                const start = Math.max(group.start, drawRange.start);
                const end = Math.min(index.count, (group.start + group.count), (drawRange.start + drawRange.count));

                for (let j = start, jl = end; j < jl; j += 3) {

                    const a = index.getX(j);
                    const b = index.getX(j + 1);
                    const c = index.getX(j + 2);

                    indices.push(a, b, c);
                }

            }

        } else {

            const start = Math.max(0, drawRange.start);
            const end = Math.min(index.count, (drawRange.start + drawRange.count));

            for (let i = start, il = end; i < il; i += 3) {

                const a = index.getX(i);
                const b = index.getX(i + 1);
                const c = index.getX(i + 2);

                indices.push(a, b, c);
            }

        }

    } else {
        // non-indexed buffer geometry

        if (groups && groups.length > 0) {

            for (let i = 0, il = groups.length; i < il; i++) {

                const group = groups[i];
                if (!groupOptimized) {
                    if (i != materialIndexOrGroupIndex) continue;
                }
                else if (group.materialIndex != materialIndexOrGroupIndex) continue;

                const start = Math.max(group.start, drawRange.start);
                const end = Math.min(position.count, (group.start + group.count), (drawRange.start + drawRange.count));

                for (let j = start, jl = end; j < jl; j += 3) {

                    const a = j;
                    const b = j + 1;
                    const c = j + 2;

                    indices.push(a, b, c);
                }

            }

        } else {

            const start = Math.max(0, drawRange.start);
            const end = Math.min(position.count, (drawRange.start + drawRange.count));

            for (let i = start, il = end; i < il; i += 3) {

                const a = i;
                const b = i + 1;
                const c = i + 2;

                indices.push(a, b, c);

            }

        }

    }

    if (vertCount > 65535) indices = new Uint32Array(indices);
    else if (vertCount > 255) indices = new Uint16Array(indices);
    else indices = new Uint8Array(indices);

    return indices;
}
GeometryUtils.genGeometryIndices = genGeometryIndices;

/**
 * 
 * @param {THREE.BufferGeometry} bufferGeometry3js 
 * @param {number}materialIndexOrGroupIndex
 * @param {boolean}[groupOptimized]
 * @param {Cesium.BoundingSphere}[boundingSphere]
 * @returns {{boundingSphere:Cesium.BoundingSphere,indices:number[]}}
 */
function computeBoundingSphereAndIndices(bufferGeometry3js, materialIndexOrGroupIndex, groupOptimized, boundingSphere) {
    initConstants$GeometryUtils();
    const geometry = bufferGeometry3js;
    const position = geometry.attributes.position;
    const positions = position.array;
    const PositionTypeCtor = positions.constructor;
    const groups = geometry.groups;
    const drawRange = geometry.drawRange;

    var index = geometry.index, indices = [], vertCount = position.count;

    if (!groups || groups.length <= 1 || typeof materialIndexOrGroupIndex != 'number') {

        if (!geometry.boundingSphere) geometry.computeBoundingSphere();
        boundingSphere = BoundingSphere.clone(geometry.boundingSphere, boundingSphere);
        indices = index && index.array;
    }
    else {

        indices = []

        if (index) {
            // indexed buffer geometry

            for (let i = 0, il = groups.length; i < il; i++) {

                const group = groups[i];
                if (!groupOptimized) {
                    if (i != materialIndexOrGroupIndex) continue;
                }
                else if (group.materialIndex != materialIndexOrGroupIndex) continue;

                const start = Math.max(group.start, drawRange.start);
                const end = Math.min(index.count, (group.start + group.count), (drawRange.start + drawRange.count));

                for (let j = start, jl = end; j < jl; j++) {

                    indices.push(index.getX(j));
                }

            }

            var points = [];
            for (let i = 0; i < indices.length; i++) {
                var index = indices[i];
                var p = Cartesian3.unpack(position.array, index * 3)
                points.push(p);
            }
            boundingSphere = BoundingSphere.fromPoints(points, boundingSphere);
        }
        else {
            // non-indexed buffer geometry 

            var boundingSpheres = [];

            for (let i = 0, il = groups.length; i < il; i++) {

                const group = groups[i];
                if (!groupOptimized) {
                    if (i != materialIndexOrGroupIndex) continue;
                }
                else if (group.materialIndex != materialIndexOrGroupIndex) continue;

                const start = Math.max(group.start, drawRange.start);
                const end = Math.min(position.count, (group.start + group.count), (drawRange.start + drawRange.count));

                const byteOffset = start * position.itemSize * PositionTypeCtor.BYTES_PER_ELEMENT;
                const arrayLength = (end - start) * position.itemSize;
                const vertices = new PositionTypeCtor(positions.buffer, byteOffset, arrayLength);

                var groupBoundingSphere = BoundingSphere.fromVertices(vertices)
                boundingSpheres.push(groupBoundingSphere)

                for (let j = start, jl = end; j < jl; j++) {
                    indices.push(j);
                }

            }

            if (boundingSpheres.length > 0) {

                if (boundingSpheres.length == 1) boundingSphere = BoundingSphere.clone(boundingSpheres[0], boundingSphere)
                else {
                    boundingSphere = BoundingSphere.fromBoundingSpheres(boundingSpheres, boundingSphere);
                }
            }

        }

    }

    if (indices && !indices.buffer) {

        if (vertCount > 65535) indices = new Uint32Array(indices);
        else if (vertCount > 255) indices = new Uint16Array(indices);
        else indices = new Uint8Array(indices);

    }

    return { indices, boundingSphere };
}
GeometryUtils.computeBoundingSphereAndIndices = computeBoundingSphereAndIndices

/**
*点绕x轴旋转，修改顶点坐标
*@param {Cesium.Cartesian3}point
*@param {Number}angle 弧度
*/
GeometryUtils.pointRotateX = function (point, angle) {
    initConstants$GeometryUtils();
    // const { Matrix3, Matrix4, Cartesian3 } = Cesium;
    Matrix3.fromRotationX(angle, scratchRotation);
    Matrix4.fromRotationTranslation(scratchRotation, Cartesian3.ZERO, scratchMatrix4);
    Matrix4.multiplyByPoint(scratchMatrix4, point, point);
}

/**
*点绕y轴旋转，修改顶点坐标
*@param {Cesium.Cartesian3}point
*@param {Number}angle 弧度
*/
GeometryUtils.pointRotateY = function (point, angle) {
    initConstants$GeometryUtils();

    Matrix3.fromRotationY(angle, scratchRotation);
    Matrix4.fromRotationTranslation(scratchRotation, Cartesian3.ZERO, scratchMatrix4);
    Matrix4.multiplyByPoint(scratchMatrix4, point, point);
}

/**
*点绕z轴旋转，修改顶点坐标
*@param {Cesium.Cartesian3}point
*@param {Number}angle 弧度
*/
GeometryUtils.pointRotateZ = function (point, angle) {
    initConstants$GeometryUtils();

    Matrix3.fromRotationZ(angle, scratchRotation);
    Matrix4.fromRotationTranslation(scratchRotation, Cartesian3.ZERO, scratchMatrix4);
    Matrix4.multiplyByPoint(scratchMatrix4, point, point);
}

/**
*绕x轴旋转，修改顶点坐标
*@param {Cesium.Geometry}geometry
*@param {Number}angle 弧度
*/
GeometryUtils.rotateX = function (geometry, angle) {
    initConstants$GeometryUtils();

    var positions = geometry.attributes.position.values;

    Matrix3.fromRotationX(angle, scratchRotation);
    Matrix4.fromRotationTranslation(scratchRotation, Cartesian3.ZERO, scratchMatrix4);

    for (var i = 0; i < positions.length; i += 3) {
        scratchPosition.x = positions[i];
        scratchPosition.y = positions[i + 1];
        scratchPosition.z = positions[i + 2];
        Matrix4.multiplyByPoint(scratchMatrix4, scratchPosition, scratchPosition);
        positions[i] = scratchPosition.x;
        positions[i + 1] = scratchPosition.y;
        positions[i + 2] = scratchPosition.z;
    }

}
/**
*绕y轴旋转，修改顶点坐标
*@param {Cesium.Geometry}geometry
*@param {Number}angle 弧度
*/
GeometryUtils.rotateY = function (geometry, angle) {
    initConstants$GeometryUtils();

    var positions = geometry.attributes.position.values;

    Matrix3.fromRotationY(angle, scratchRotation);
    Matrix4.fromRotationTranslation(scratchRotation, Cartesian3.ZERO, scratchMatrix4);

    for (var i = 0; i < positions.length; i += 3) {
        scratchPosition.x = positions[i];
        scratchPosition.y = positions[i + 1];
        scratchPosition.z = positions[i + 2];
        Matrix4.multiplyByPoint(scratchMatrix4, scratchPosition, scratchPosition);
        positions[i] = scratchPosition.x;
        positions[i + 1] = scratchPosition.y;
        positions[i + 2] = scratchPosition.z;
    }

}

/**
*绕z轴旋转，修改顶点坐标
*@param {Cesium.Geometry}geometry
*@param {Number}angle 弧度
*/
GeometryUtils.rotateZ = function (geometry, angle) {
    initConstants$GeometryUtils();

    var positions = geometry.attributes.position.values;

    Matrix3.fromRotationZ(angle, scratchRotation);
    Matrix4.fromRotationTranslation(scratchRotation, Cartesian3.ZERO, scratchMatrix4);

    for (var i = 0; i < positions.length; i += 3) {
        scratchPosition.x = positions[i];
        scratchPosition.y = positions[i + 1];
        scratchPosition.z = positions[i + 2];
        Matrix4.multiplyByPoint(scratchMatrix4, scratchPosition, scratchPosition);
        positions[i] = scratchPosition.x;
        positions[i + 1] = scratchPosition.y;
        positions[i + 2] = scratchPosition.z;
    }

}

/**
 * 
 * @param {number[]} positions 
 * @param {number} index 
 * @returns {boolean}
 */
GeometryUtils.isValidVertex = function (positions, index) {
    index = index * 3;
    return !isNaN(positions[index])//x
        && !isNaN(positions[index + 1])//y
        && !isNaN(positions[index + 2])//z
}

/**
 * 
 * @param {number[]} positions 
 * @param {number} a 
 * @param {number} b 
 * @param {number} c
 * @returns {boolean}
 */
GeometryUtils.isValidTriangle = function (positions, a, b, c) {
    let result = this.isValidVertex(positions, a)
        && this.isValidVertex(positions, b)
        && this.isValidVertex(positions, c);

    a = Cartesian3.unpack(positions, a * 3);
    b = Cartesian3.unpack(positions, b * 3);
    c = Cartesian3.unpack(positions, c * 3);
    var ba = Cartesian3.subtract(b, a, new Cartesian3())
    var ca = Cartesian3.subtract(c, a, new Cartesian3())
    var n = Cartesian3.cross(ba, ca, new Cartesian3())
    if (Cartesian3.equals(n, Cartesian3.ZERO)) {
        debugger
        result = false;
    }
    return result;
}

/**
 * 删除位置坐标有NaN的顶点，返回新的几何体
 * @param {THREE.BufferGeometry} geometry 
 * @returns {THREE.BufferGeometry} newGeometry
 */
GeometryUtils.removeInvalidVertices = function (geometry) {
    if (!geometry.isBufferGeometry) {
        console.warn('unsupport geometry type');
        return geometry
    }
    let newGeometry = geometry.clone(),
        srcAttributes = geometry.attributes,
        dstAttributes = newGeometry.attributes;

    let attrNames = [];

    for (const name in dstAttributes) {
        if (dstAttributes.hasOwnProperty(name) && dstAttributes[name]) {
            const att = dstAttributes[name];
            let srcType = att.array.constructor;
            att.array = [];
            att.array._srcType = srcType;
            attrNames.push(name);
        }
    }

    function addVertex(index) {
        attrNames.forEach(name => {
            let src = srcAttributes[name], dst = dstAttributes[name];
            let itemSize = src.itemSize,
                start = itemSize * index;

            for (let i = 0; i < itemSize; i++) {
                dst.array.push(src.array[start + i])
            }

        })
    }

    function addTriangle(a, b, c) {

        addVertex(a)
        addVertex(b)
        addVertex(c)
    }

    let positions = geometry.attributes.position, vertexCount = positions.count;

    positions = positions.array || positions.values;

    if (geometry.index) {
        let indices = geometry.index.array;
        for (let i = 0; i < indices.length; i += 3) {
            const a = indices[i], b = indices[i + 1], c = indices[i + 2];
            if (this.isValidTriangle(positions, a, b, c)) {
                addTriangle(a, b, c)
            }
        }

    } else {

        for (let i = 0; i < vertexCount; i += 3) {
            const a = i, b = i + 1, c = i + 2;
            if (this.isValidTriangle(positions, a, b, c)) {
                addTriangle(a, b, c)
            }
        }
    }

    for (const name in dstAttributes) {
        if (dstAttributes.hasOwnProperty(name) && dstAttributes[name]) {
            const att = dstAttributes[name];
            let srcType = att.array._srcType;
            att.array = new srcType(att.array);
            att.count = att.array.length / att.itemSize;
            delete att.array._srcType;

        }
    }

    return newGeometry;
}

/**
 * 将几何体强制使用索引，以期减少几何内存占用，如果几何体的groups.length大于1，则返回undefined
 * @param {THREE.BufferGeometry} geometry 
 * @param {boolean}[removeUv2=false]
 * @param {boolean}[removeUv3=true]
 * @returns {undefined|THREE.BufferGeometry} newGeometry
 */
GeometryUtils.forceIndices = function (geometry, removeUv2, removeUv3) {
    if (typeof THREE == 'undefined') {
        throw new Error('强制索引功能依赖threejs，但是上下文未找到THREE模块 ')
    }

    if (geometry.index) {
        console.warn('该几何已有索引');
        return
    }

    if (geometry.groups && geometry.groups.length > 1) {
        console.warn('该几何无法强制使用索引');
        return;
    }

    if (typeof removeUv3 == 'undefined') removeUv3 = true;

    let indices = [], map = new Map();
    let srcAttributes = geometry.attributes
    let positions = srcAttributes.position;
    let srcCount = positions.count;
    positions = positions.array;

    let newGeometry = geometry.clone(),
        dstAttributes = newGeometry.attributes,
        attrNames = [];


    for (const name in dstAttributes) {
        if ((removeUv3 && name == 'uv3')
            || (removeUv2 && name == 'uv2')) {
            delete dstAttributes[name]
            continue;
        }

        if (dstAttributes.hasOwnProperty(name) && dstAttributes[name]) {
            const att = dstAttributes[name];
            let srcType = att.array.constructor;
            att.array = [];
            att.array._srcType = srcType;
            attrNames.push(name);
        }
    }

    let newIndex = 0;
    function addVertex(index) {

        let code = [positions[index * 3], positions[index * 3 + 1], positions[index * 3 + 2]].join(',')
        if (dstAttributes.uv) {
            let uv = srcAttributes.uv.array;
            code += ',' + [uv[index * 2], uv[index * 2 + 1]].join(',')
        }
        if (dstAttributes.uv2) {
            let uv2 = srcAttributes.uv2.array;
            code += ',' + [uv2[index * 2], uv2[index * 2 + 1]].join(',')
        }

        if (!map.has(code)) {
            attrNames.forEach(name => {
                let src = srcAttributes[name], dst = dstAttributes[name];
                let itemSize = src.itemSize,
                    start = itemSize * index;

                for (let i = 0; i < itemSize; i++) {
                    dst.array.push(src.array[start + i])
                }

            });

            map.set(code, newIndex);
            newIndex++;
        }

        return map.get(code)
    }

    for (let i = 0; i < srcCount; i++) {
        let idx = addVertex(i);
        indices.push(idx);
    }
    if (newIndex > 65535) {
        indices = new Uint32Array(indices)
    } else if (newIndex > 255) {
        indices = new Uint16Array(indices)
    } else {
        indices = new Uint8Array(indices);
    }

    map.clear();

    newGeometry.groups = [{
        start: 0, count: Infinity, materialIndex: 0
    }];
    newGeometry.index = new THREE.BufferAttribute(indices, 1, false)

    for (const name in dstAttributes) {
        if (dstAttributes.hasOwnProperty(name) && dstAttributes[name]) {
            const att = dstAttributes[name];
            let srcType = att.array._srcType;
            att.array = new srcType(att.array);
            att.count = att.array.length / att.itemSize;
            delete att.array._srcType;

        }
    }
    return newGeometry

}

function minmax(arr, offset, stride) {
    offset = offset || 0;
    stride = stride || 1;
    let min = Number.MAX_VALUE, max = -Number.MAX_VALUE;
    for (let i = offset; i < arr.length; i += stride) {
        const v = arr[i];
        if (isNaN(v) || v == Infinity || v == -Infinity) continue;
        min = Math.min(min, v);
        max = Math.max(max, v);
    }
    return { min, max }
}

/**
 * 
 * @param {THREE.BufferGeometry} geometry 
 * @returns {THREE.BufferGeometry}geometry
 */
GeometryUtils.clampToIndices = function (geometry) {
    if (geometry.index) {
        // geometry = geometry.clone();
        let index = geometry.index.array;
        let { max } = minmax(index);

        let atts = geometry.attributes;
        for (const key in atts) {
            if (atts.hasOwnProperty(key)) {
                let { array, itemSize, count } = atts[key];
                if (count == max + 1) continue;

                let end = itemSize * (max + 1) * array.constructor.BYTES_PER_ELEMENT;
                let buffer = array.buffer.slice(0, end);
                array = new array.constructor(buffer);
                atts[key].array = array;
            }
        }
    }
    return geometry
}
/**
 * 
 * @param {Cesium.Geometry|THREE.BufferGeometry} geometry 
 * @returns {boolean}
 */
GeometryUtils.computeSurfaceArea = function (geometry) {
    if (!(geometry instanceof Cesium.Geometry) && !geometry.isBufferGeometry) {
        console.warn('unsupport geometry type');
        return -1;
    }
    let positions = geometry.attributes.position;
    let indices = geometry.indices || geometry.index;
    if (indices) indices = indices.array || indices;

    positions = positions.array || positions.values;
    positions = Cesium.Cartesian3.unpackArray(positions);

    let area = 0;
    if (indices) {

        for (let i = 0; i < indices.length; i += 3) {
            const a = indices[i], b = indices[i + 1], c = indices[i + 2];
            area += computeArea(positions[a], positions[b], positions[c])

        }
    } else {
        for (let i = 0; i < positions.length; i += 3) {
            const a = positions[i], b = positions[i + 1], c = positions[i + 2];
            area += computeArea(a, b, c)

        }
    }
    return area;
}

/**
 * 
 * @param {THREE.BufferGeometry} a 
 * @param {THREE.BufferGeometry} b 
 * @returns {boolean}
 */
GeometryUtils.geometryEquals = function (a, b) {
    a = a.attributes.position.array;
    b = b.attributes.position.array;

    let eq = a.length == b.length;
    if (eq) {
        let l = a.length;
        for (let i = 0; i < l; i++) {
            if (a[i] != b[i]) {
                eq = false;
                break;
            }
        }
    }

    return eq;
}

/**
 * 
 * @param {THREE.Geometry} geometry 
 * @param {number} simplifyFactor 
 * @param {{
        agressiveness: number,
        update: number,
        recompute: boolean
 * }}[options]
 */
GeometryUtils.simplify = function (geometry, simplifyFactor, options) {
    if (typeof THREE == 'undefined') {
        throw new Error('模型简化功能依赖threejs，但是上下文未找到THREE模块 ')
    }
    if (!simplifyFactor) {
        throw new Error('缺少参数simplifyFactor')
    }

    let srcCount = geometry.attributes.position.count;
    let target_count = simplifyFactor * srcCount;

    geometry = simplify_three(geometry, target_count, options)

    let dstCount = geometry.attributes.position.count;

    let delt = dstCount - srcCount
    if (delt < 0) {

        let positions = geometry.attributes.position.array;
        let isValid = true;
        for (let i = 0; i < dstCount; i++) {
            if (!this.isValidVertex(positions, i)) {
                isValid = false;
                break;
            }
        }
        if (!isValid) {
            geometry = GeometryUtils.removeInvalidVertices(geometry)
        }
    }

    return geometry;
}
// GeometryUtils.subdivUVNormalized = subdivUVNormalized;
var triangulate = (function () {
    //src:http://turfjs.org/docs/#tin

    var Triangle = /** @class */ (function () {
        function Triangle(a, b, c) {
            this.a = a;
            this.b = b;
            this.c = c;
            var A = b.x - a.x;
            var B = b.y - a.y;
            var C = c.x - a.x;
            var D = c.y - a.y;
            var E = A * (a.x + b.x) + B * (a.y + b.y);
            var F = C * (a.x + c.x) + D * (a.y + c.y);
            var G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));
            var dx;
            var dy;
            // If the points of the triangle are collinear, then just find the
            // extremes and use the midpoint as the center of the circumcircle.
            this.x = (D * E - B * F) / G;
            this.y = (A * F - C * E) / G;
            dx = this.x - a.x;
            dy = this.y - a.y;
            this.r = dx * dx + dy * dy;
        }
        return Triangle;
    }());
    function byX(a, b) {
        return b.x - a.x;
    }
    function dedup(edges) {
        var j = edges.length;
        var a;
        var b;
        var i;
        var m;
        var n;
        outer: while (j) {
            b = edges[--j];
            a = edges[--j];
            i = j;
            while (i) {
                n = edges[--i];
                m = edges[--i];
                if ((a === m && b === n) || (a === n && b === m)) {
                    edges.splice(j, 2);
                    edges.splice(i, 2);
                    j -= 2;
                    continue outer;
                }
            }
        }
    }
    /**
     * 
     * @param {(Cesium.Cartesian2|THREE.Vector2)[]} vertices 
     */
    function triangulate(vertices) {
        // Bail if there aren't enough vertices to form any triangles.
        if (vertices.length < 3) {
            return [];
        }
        // Ensure the vertex array is in order of descending X coordinate
        // (which is needed to ensure a subquadratic runtime), and then find
        // the bounding box around the points.
        vertices.sort(byX);
        var i = vertices.length - 1;
        var xmin = vertices[i].x;
        var xmax = vertices[0].x;
        var ymin = vertices[i].y;
        var ymax = ymin;
        var epsilon = 1e-12;
        var a;
        var b;
        var c;
        var A;
        var B;
        var G;
        while (i--) {
            if (vertices[i].y < ymin) {
                ymin = vertices[i].y;
            }
            if (vertices[i].y > ymax) {
                ymax = vertices[i].y;
            }
        }
        // Find a supertriangle, which is a triangle that surrounds all the
        // vertices. This is used like something of a sentinel value to remove
        // cases in the main algorithm, and is removed before we return any
        // results.
        // Once found, put it in the "open" list. (The "open" list is for
        // triangles who may still need to be considered; the "closed" list is
        // for triangles which do not.)
        var dx = xmax - xmin;
        var dy = ymax - ymin;
        var dmax = (dx > dy) ? dx : dy;
        var xmid = (xmax + xmin) * 0.5;
        var ymid = (ymax + ymin) * 0.5;
        var open = [
            new Triangle({
                __sentinel: true,
                x: xmid - 20 * dmax,
                y: ymid - dmax,
            }, {
                __sentinel: true,
                x: xmid,
                y: ymid + 20 * dmax,
            }, {
                __sentinel: true,
                x: xmid + 20 * dmax,
                y: ymid - dmax,
            })
        ];
        var closed = [];
        var edges = [];
        var j;
        // Incrementally add each vertex to the mesh.
        i = vertices.length;
        while (i--) {
            // For each open triangle, check to see if the current point is
            // inside it's circumcircle. If it is, remove the triangle and add
            // it's edges to an edge list.
            edges.length = 0;
            j = open.length;
            while (j--) {
                // If this point is to the right of this triangle's circumcircle,
                // then this triangle should never get checked again. Remove it
                // from the open list, add it to the closed list, and skip.
                dx = vertices[i].x - open[j].x;
                if (dx > 0 && dx * dx > open[j].r) {
                    closed.push(open[j]);
                    open.splice(j, 1);
                    continue;
                }
                // If not, skip this triangle.
                dy = vertices[i].y - open[j].y;
                if (dx * dx + dy * dy > open[j].r) {
                    continue;
                }
                // Remove the triangle and add it's edges to the edge list.
                edges.push(open[j].a, open[j].b, open[j].b, open[j].c, open[j].c, open[j].a);
                open.splice(j, 1);
            }
            // Remove any doubled edges.
            dedup(edges);
            // Add a new triangle for each edge.
            j = edges.length;
            while (j) {
                b = edges[--j];
                a = edges[--j];
                c = vertices[i];
                // Avoid adding colinear triangles (which have error-prone
                // circumcircles)
                A = b.x - a.x;
                B = b.y - a.y;
                G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));
                if (Math.abs(G) > epsilon) {
                    open.push(new Triangle(a, b, c));
                }
            }
        }
        // Copy any remaining open triangles to the closed list, and then
        // remove any triangles that share a vertex with the supertriangle.
        Array.prototype.push.apply(closed, open);
        i = closed.length;
        while (i--) {
            if (closed[i].a.__sentinel ||
                closed[i].b.__sentinel ||
                closed[i].c.__sentinel) {
                closed.splice(i, 1);
            }
        }
        return closed;
    }
    return triangulate;
})();
GeometryUtils.triangulate = triangulate;

/**
 * 
 * @param {Cesium.Cartesian3} p1 
 * @param {Cesium.Cartesian3} p2 
 * @param {Cesium.Cartesian3} p3 
 * @param {Cesium.Cartesian3} [result] 
 */
function computeNormal(pA, pB, pC, result, normalized) {
    initConstants$GeometryUtils();
    if (!result) {
        result = new Cartesian3()
    }
    Cartesian3.subtract(pC, pB, _scratchCB);
    Cartesian3.subtract(pA, pB, _scratchAB);
    Cartesian3.cross(_scratchCB, _scratchAB, result);
    var magnitude = Cartesian3.magnitude(result);
    if (magnitude != 0 && normalized != false) Cartesian3.normalize(result, result);
    return result;
}
GeometryUtils.computeNormal = computeNormal

/**
*
*@param {Cesium.Geometry}geometry
*/
GeometryUtils.computeVertexNormals = function (geometry) {
    initConstants$GeometryUtils()

    // const _Cesium = Cesium;
    var indices = geometry.indices;
    var attributes = geometry.attributes;

    if (attributes.position) {

        var positions = attributes.position.values;

        var il = indices ? indices.length : positions.length / 3;

        if (attributes.normal === undefined) {
            attributes.normal = new GeometryAttribute({
                componentDatatype: ComponentDatatype.FLOAT,
                componentsPerAttribute: 3,
                values: new Float32Array(positions.length)
            })

        } else {

            // reset existing normals to zero

            var array = attributes.normal.values;

            if (!indices) {
                for (var i = 0; i < il; i++) {

                    array[i] = 0;

                }
            } else {
                var pi;
                for (var i = 0; i < il; i++) {
                    pi = indices[i]
                    array[pi * 3] = 0;
                    array[pi * 3 + 1] = 0;
                    array[pi * 3 + 2] = 0;

                }
            }

        }

        var normals = attributes.normal.values;

        var vA, vB, vC;

        var pA = new Cartesian3(), pB = new Cartesian3(), pC = new Cartesian3();
        var cb = new Cartesian3(), ab = new Cartesian3();

        for (var i = 0; i < il; i += 3) {

            vA = indices ? indices[i + 0] * 3 : i * 3;
            vB = indices ? indices[i + 1] * 3 : (i + 1) * 3;
            vC = indices ? indices[i + 2] * 3 : (i + 2) * 3;

            Cartesian3.fromArray(positions, vA, pA);
            Cartesian3.fromArray(positions, vB, pB);
            Cartesian3.fromArray(positions, vC, pC);

            Cartesian3.subtract(pC, pB, cb);
            Cartesian3.subtract(pA, pB, ab);
            Cartesian3.cross(cb, ab, cb);

            normals[vA] += cb.x;
            normals[vA + 1] += cb.y;
            normals[vA + 2] += cb.z;

            normals[vB] += cb.x;
            normals[vB + 1] += cb.y;
            normals[vB + 2] += cb.z;

            normals[vC] += cb.x;
            normals[vC + 1] += cb.y;
            normals[vC + 2] += cb.z;

        }

        normalizeNormals(geometry);

        attributes.normal.needsUpdate = true;

    }

    return geometry;
}
function normalizeNormals(geometry) {

    var normals = geometry.attributes.normal.values;

    var x, y, z, n;

    for (var i = 0; i < normals.length; i += 3) {

        x = normals[i];
        y = normals[i + 1];
        z = normals[i + 2];

        n = 1.0 / Math.sqrt(x * x + y * y + z * z);

        normals[i] = x * n;
        normals[i + 1] = y * n;
        normals[i + 2] = z * n;
    }

}

/**
*合并两个或两个以上图形类型（primitiveType），属性数量、名称以及属性值的类型（GeometryAttribute的componentDatatype、componentsPerAttribute等）都一致的几何体
*@param {Array<Cesium.Geometry>}geometries 
*@return {Cesium.Geometry}
*/
GeometryUtils.mergeGeometries = function (geometries) {
    if (!geometries || !geometries.length) {
        throw new Error("缺少geometries参数");
    }

    if (geometries.length == 1) {
        return geometries[0];
    }
    var geometriesAttrs = [];

    var lengthChanged = false;
    var primitiveTypeChanged = false;
    var primitiveType = geometries[0].primitiveType;
    for (var i = 0; i < geometries.length; i++) {

        geometriesAttrs[i] = getAttrs(geometries[i]);
        if (i > 0) {
            if (primitiveType != geometries[i].primitiveType) {
                primitiveTypeChanged = true;
                break;
            }
            var lastGeoAttrs = geometriesAttrs[i - 1];
            lengthChanged = lastGeoAttrs.length != geometriesAttrs[i].length;
            if (!lengthChanged) {

                for (var j = 0; j < lastGeoAttrs.length; j++) {
                    if (lastGeoAttrs[j] != geometriesAttrs[i][j]) {
                        lengthChanged = true;
                        break;
                    }

                }
            }
        }
        primitiveType = geometries[i].primitiveType;
        if (lengthChanged || primitiveTypeChanged) {
            break;
        }
    }
    if (primitiveTypeChanged) {
        throw new Error("待合并的几何体中primitiveType属性不完全一致");
    }
    if (lengthChanged) {
        throw new Error("待合并的几何体中属性数量和和名称不完全一致");
    }
    return mergeGeometries(geometries);

}

function mergeGeometries(geometries) {
    if (geometries.length == 1) return geometries[0];
    var attrNames = [];
    var valueArrs = [];
    var valueTypes = [];
    var valueConstructors = [];
    var valueComponents = [];
    var valueNormalizes = [];
    var valueOffsets = [];
    var indices = [];
    var primitiveType;
    var indexOffst = 0;

    var componentCounts = [];

    var geometry = geometries[0];
    primitiveType = geometry.primitiveType;
    for (const attrName in geometry.attributes) {
        if (geometry.attributes.hasOwnProperty(attrName) && geometry.attributes[attrName]) {
            const attr = geometry.attributes[attrName];
            attrNames.push(attrName);

            // valueArrs.push([]);

            valueComponents.push(attr.componentsPerAttribute);
            valueTypes.push(attr.componentDatatype);
            valueConstructors.push(attr.values.constructor);
            valueNormalizes.push(attr.normalize);

            componentCounts.push(0);
            valueOffsets.push(0);
        }
    }
    for (let i = 0; i < geometries.length; i++) {
        const geometry = geometries[i];
        for (let j = 0; j < attrNames.length; j++) {
            const attrName = attrNames[j];
            componentCounts[j] += geometry.attributes[attrName].values.length
        }
    }

    for (let j = 0; j < attrNames.length; j++) {
        valueArrs.push(new valueConstructors[j](componentCounts[j]));
    }

    if (!geometries[0].indices) {
        indices = null;
    }

    for (let i = 0; i < geometries.length; i++) {
        const geometry = geometries[i];
        for (let ai = 0; ai < attrNames.length; ai++) {
            var attrName = attrNames[ai];
            var valueArr = valueArrs[ai];
            var attrValues = geometry.attributes[attrName].values;
            valueArr.set(attrValues, valueOffsets[ai]);
            valueOffsets[ai] += attrValues.length;
        }

        if (geometry.indices) {
            for (let j = 0; j < geometry.indices.length; j++) {
                const index = geometry.indices[j];
                indices.push(index + indexOffst);
            }

            indexOffst += geometry.attributes.position.values.length / 3;
        }
    }

    var attributes = {};
    for (let i = 0; i < attrNames.length; i++) {
        const attrName = attrNames[i];
        attributes[attrName] = {
            values: valueArrs[i],
            componentsPerAttribute: valueComponents[i],
            componentDatatype: valueTypes[i],
            normalize: valueNormalizes[i]
        }
    }

    if (indices) {
        var vertexCount = valueArrs[0] / valueComponents[0];
        if (vertexCount < 65535) {
            indices = new Uint16Array(indices);
        } else {
            indices = new Uint32Array(indices);
        }
    }

    geometry = new Cesium.Geometry({
        attributes: attributes,
        indices: indices,
        primitiveType: primitiveType
    })
    return geometry;
}

/**
 * 
 * @param {Cesium.Geometry[]} geometries 
 * @returns {Cesium.Geometry}
 */
GeometryUtils.mergeGroupedGeometries = function (geometries) {
    const _Cesium = Cesium;

    let attributes = GeometryUtils.cloneGeometryAttributes(geometries[0].attributes);

    for (const name in attributes) {
        if (attributes.hasOwnProperty(name)) {
            const attribute = attributes[name];
            let componentsPerAttribute = attribute.componentsPerAttribute;
            let componentDatatype = attribute.componentDatatype;
            let values = [];

            geometries.forEach((geometry) => {
                let srcAttribute = geometry.attributes[name];
                let srcValues = srcAttribute.values;

                for (let i = 0; i < geometry.indices.length; i++) {
                    const vi = geometry.indices[i];
                    for (let j = 0; j < componentsPerAttribute; j++) {
                        values.push(srcValues[vi * componentsPerAttribute + j])
                    }
                }
            })

            attributes[name].values = _Cesium.ComponentDatatype.createTypedArray(
                componentDatatype, values
            );

        }

    }

    return new _Cesium.Geometry({
        attributes: attributes,
        primitiveType: geometries[0].primitiveType
    })
}

/**
 * 
 * @param {THREE.BufferGeometry[]} geometries 
 * @returns {THREE.BufferGeometry}
 */
function mergeGeometries3js(geometries) {
    const _THREE = THREE;
    var newGeometry = geometries[0].clone();
    var newAttributes = newGeometry.attributes;
    for (const name in newAttributes) {
        const newAttribute = newAttributes[name];
        var count = 0, aLength = 0;
        for (let i = 0; i < geometries.length; i++) {
            const geom = geometries[i];
            const att = geom.attributes[name]
            count += att.count
            aLength += att.array.length;
        }
        newAttribute.count = count;
        newAttribute.array = new newAttribute.array.constructor(aLength);
        var array = newAttribute.array, offset = 0;
        for (let i = 0; i < geometries.length; i++) {
            const geom = geometries[i];
            const att = geom.attributes[name], currArr = att.array;
            array.set(currArr, offset);
            offset += currArr.length;
        }
    }
    //
    var indexList = [], newIndexLen = 0;
    for (let i = 0; i < geometries.length; i++) {
        const geom = geometries[i];
        var indices = genGeometryIndices(geom, 0, true);
        indexList.push(indices);
        newIndexLen += indices.length;
    }
    var newIndices, vertCount = newAttributes.position.count, newIndexCtor;
    if (vertCount > 65535) {
        newIndices = new Uint32Array(newIndexLen)
        newIndexCtor = _THREE.Uint32BufferAttribute
    } else if (vertCount > 255) {
        newIndices = new Uint16Array(newIndexLen)
        newIndexCtor = _THREE.Uint16BufferAttribute
    } else {
        newIndices = new Uint8Array(newIndexLen)
        newIndexCtor = _THREE.Uint8BufferAttribute
    }
    var offset = 0, ptr = 0, removeIndex = true, prevIndex = -1;
    for (let i = 0; i < indexList.length; i++) {
        const index = indexList[i];
        for (let j = 0; j < index.length; j++) {
            var currIdx = index[j] + offset;
            newIndices[ptr++] = currIdx;
            if (currIdx - prevIndex != 1) {
                removeIndex = false
            }
            prevIndex = currIdx
        }
        offset += geometries[i].attributes.position.count;
    }
    if (removeIndex) {
        newGeometry.index = null;
    }
    else {
        newGeometry.setIndex(new newIndexCtor(newIndices, 1, false));
    }
    newGeometry.computeBoundingSphere();
    newGeometry.computeBoundingBox();
    return newGeometry;
}
GeometryUtils.mergeGeometries3js = mergeGeometries3js;

/**
*
*@param {Cesium.Geometry}geometry
*@param {Cesium.Cartesian3}offset
*/
GeometryUtils.translate = function (geometry, offset) {
    initConstants$GeometryUtils()
    if (Array.isArray(offset)) {
        scratchOffset.x = offset[0];
        scratchOffset.y = offset[1];
        scratchOffset.z = offset[2];
    } else {
        Cartesian3.clone(offset, scratchOffset);
    }

    for (var i = 0; i < geometry.attributes.position.values.length; i += 3) {
        geometry.attributes.position.values[i] += scratchOffset.x;
        geometry.attributes.position.values[i + 1] += scratchOffset.y;
        geometry.attributes.position.values[i + 2] += scratchOffset.z;
    }
    //if (geometry.attributes.normal) {
    //    Cesium.GeometryPipeline.computeNormal(geometry);
    //}
}

/**
*
*@param {TypeArray} array
*@return {Cesium.ComponentDatatype}  
*/
GeometryUtils.getAttributeComponentType = function (array) {
    const ComponentDatatype = Cesium.ComponentDatatype;
    var attributeComponentType = ComponentDatatype.SHORT;
    if (array instanceof Int8Array) {
        attributeComponentType = ComponentDatatype.BYTE;

    } else if (array instanceof Uint8Array || array instanceof Uint8ClampedArray) {
        attributeComponentType = ComponentDatatype.UNSIGNED_BYTE;

    } else if (array instanceof Int16Array) {
        attributeComponentType = ComponentDatatype.SHORT;

    } else if (array instanceof Uint16Array) {
        attributeComponentType = ComponentDatatype.UNSIGNED_SHORT;

    } else if (array instanceof Int32Array) {
        attributeComponentType = ComponentDatatype.INT;

    } else if (array instanceof Uint32Array) {
        attributeComponentType = ComponentDatatype.UNSIGNED_INT;

    } else if (array instanceof Float32Array) {
        attributeComponentType = ComponentDatatype.FLOAT;

    } else if (array instanceof Float64Array) {
        attributeComponentType = ComponentDatatype.DOUBLE;

    }

    return attributeComponentType;

}

/**
 * 
 * @param {{[key:string]:Cesium.GeometryAttribute}} srcAttributes 
 * @returns {{[key:string]:Cesium.GeometryAttribute}} newAttributes
 */
GeometryUtils.cloneGeometryAttributes = function (srcAttributes) {

    let attributes = {};
    for (const name in srcAttributes) {
        if (srcAttributes.hasOwnProperty(name) && srcAttributes[name]) {
            let srcAttribute = srcAttributes[name];

            attributes[name] = {
                componentDatatype: srcAttribute.componentDatatype,
                componentsPerAttribute: srcAttribute.componentsPerAttribute,
                normalize: srcAttribute.normalize,
                values: []
            }

        }
    }
    return attributes;
}

/**
 * 
 * @param {Cesium.Geometry} geometry 
 * @returns {Cesium.Geometry}
 */
GeometryUtils.cloneGeometry = function (geometry) {
    let attributes = this.cloneGeometryAttributes(geometry.attributes);
    for (const key in attributes) {
        if (attributes.hasOwnProperty(key)) {
            const attribute = attributes[key];
            const values = geometry.attributes[key].values;
            attribute.values = new values.constructor(values);
        }
    }

    let indices = geometry.indices ? new geometry.indices.constructor(geometry.indices) : undefined;
    let newGeometry = new Cesium.Geometry({
        attributes: attributes,
        indices: indices,
        primitiveType: geometry.primitiveType,
        boundingSphere: geometry.boundingSphere ? geometry.boundingSphere.clone() : undefined
    })
    return newGeometry;
}

/**
*
*@param {Object}geometry
*@return {Boolean}
*/
GeometryUtils.isGeometry3js = function (geometry) {
    return (typeof THREE !== 'undefined' && geometry.isBufferGeometry)
        || (geometry.attributes && geometry.attributes.position && geometry.index)
        || (geometry.vertices && geometry.faces);
}

/**
 *
 * @param {THREE.BufferGeometry}geometry 
 * @param {THREE.Mesh} object
 * @private
 */
GeometryUtils.parseBufferGeometry3js = function (geometry, object) {
    // var start = new Date();
    const { GeometryAttribute, PrimitiveType, Geometry } = Cesium;

    var attributes = {};
    if (!geometry.attributes.normal) {
        geometry.computeVertexNormals();
    }

    for (var attrName in geometry.attributes) {

        if (geometry.attributes.hasOwnProperty(attrName)) {
            var attr = geometry.getAttribute(attrName);
            if (attr && attr.array.length > 0) {

                attributes[attrName] = new GeometryAttribute({
                    componentDatatype: GeometryUtils.getAttributeComponentType(attr.array),
                    componentsPerAttribute: attr.itemSize,
                    values: attr.array,
                    normalize: attr.normalized
                });

            }

        }
    }
    var indices;
    var primitiveType = PrimitiveType.TRIANGLES;
    if (typeof geometry.GeometryMode != 'undefined') {
        primitiveType = geometry.GeometryMode;
    }
    if (!geometry.index) {

        var ptCount = attributes.position.values.length / 3

        if (geometry.groups && geometry.groups.length) {
            indices = [];
            geometry.groups.forEach(function (group) {
                if (group.start + group.count > ptCount) {
                    console.warn('group.count>ptCount');
                }
                for (var i = 0; i < group.count && i + group.start < ptCount; i++) {
                    indices.push(i + group.start);
                }
            })

        } else if (object.isLine) {

            if (object.isLineSegments) {
                primitiveType = PrimitiveType.LINES;
            }
            else if (object.isLineLoop) {
                primitiveType = PrimitiveType.LINE_LOOP;
            } else {
                primitiveType = PrimitiveType.LINE_STRIP;
            }

        } else if (object.isPoints) {
            primitiveType = PrimitiveType.POINTS;
        }

        if (indices) {
            if (ptCount > 65535) {
                indices = new Uint32Array(indices);
            } else {
                indices = new Uint16Array(indices);
            }
        }
    } else {
        indices = geometry.index.array;
    }
    var cesGeometry = new Geometry({
        attributes: attributes,
        indices: indices,
        primitiveType: primitiveType
    });
    if (geometry.boundingSphere) {
        cesGeometry.boundingSphere = BoundingSphere.clone(geometry.boundingSphere)
    }
    return cesGeometry;
}

/**
*
*@param {THREE.Geometry}geometry3js
*@return {Cesium.Geometry} 
*/
GeometryUtils.fromGeometry3js = function (geometry3js, object, useCesiumNormal) {

    if (geometry3js.attributes && (geometry3js.index || geometry3js.groups.length)) {

    } else {

        if (!geometry3js.isBufferGeometry) {
            geometry3js = new THREE.BufferGeometry().fromGeometry(geometry3js);
        }

        if (!geometry3js.attributes.normal && !useCesiumNormal && geometry3js.computeVertexNormals) {
            geometry3js.computeVertexNormals();
        }
    }

    var _Cesium = Cesium;
    var geometry = GeometryUtils.parseBufferGeometry3js(geometry3js, object);
    if (
        useCesiumNormal && !geometry.attributes.normal &&
        geometry.primitiveType == _Cesium.PrimitiveType.TRIANGLES) {
        _Cesium.GeometryPipeline.computeNormal(geometry);
    }
    return geometry;

}

/**
 * 
 * @param {Cesium.Geometry} geometry 
 * @param {THREE.BufferGeometry} [result]
 * @returns {THREE.BufferGeometry} result
 */
GeometryUtils.toBufferGeometry3js = function (geometry, result) {
    const { BufferGeometry, BufferAttribute, Sphere } = THREE;

    if (!result) result = new BufferGeometry();
    let attributes = geometry.attributes;

    for (const name in attributes) {
        if (attributes.hasOwnProperty(name) && attributes[name]) {
            const attribute = attributes[name];
            var array = attribute.values;
            if (array instanceof Float64Array) {
                array = new Float32Array(array);
            }
            let attribute3js = new BufferAttribute(
                array, attribute.componentsPerAttribute, attribute.normalize);
            result.setAttribute(name, attribute3js);
        }
    }

    if (attributes.st) {
        result.attributes.uv = result.attributes.st;
        result.deleteAttribute('st');
    }

    if (geometry.indices) {
        let attribute3js = new BufferAttribute(
            geometry.indices, 1, false);
        result.setIndex(attribute3js)
    }

    if (geometry.boundingSphere) {
        let bs = geometry.boundingSphere
        if (!result.boundingSphere) result.boundingSphere = new Sphere()
        result.boundingSphere.center.copy(bs.center)
        result.boundingSphere.radius = bs.radius;
    }

    return result;

}

/**
*
*@param {Cesium.Geometry}geometry
*@return {THREE.Geometry} 
*/
GeometryUtils.toGeometry3js = function (geometry) {
    if (typeof THREE === 'undefined') {
        throw new Error("THREE 未加载");
    }
    const { Geometry, Vector3, Face3 } = THREE;

    var positions = geometry.attributes.position.values;
    var positionIdx = 0;

    var geometry3js = new Geometry();

    for (var i = 0; i < positions.length; i += 3) {
        positionIdx = i * 3;
        geometry3js.vertices.push(
            new Vector3(positions[positionIdx], positions[positionIdx + 2], positions[positionIdx + 1])
        );
    }

    for (var i = 0; i < geometry.indices.length; i += 3) {
        var idx1 = geometry.indices[i];
        var idx2 = geometry.indices[i + 1];
        var idx3 = geometry.indices[i + 2];
        geometry3js.faces.push(new Face3(idx1, idx2, idx3));
    }

    return geometry3js;
}

/**
*@param {Cesium.Geometry|THREE.Geometry}geometry
*@param {Cesium.Cartesian3}[offset]
*@return {CSG}
*/
GeometryUtils.toCSG = function (geometry, offset) {
    if (!(typeof THREE === 'undefined')) {
        if (geometry.isBufferGeometry) {
            return GeometryUtils._toCSG3js(geometry, offset);
        }
    }
    const _Cesium = Cesium;

    if (!offset) {
        offset = { x: 0, y: 0, z: 0 };
    }
    if (!geometry.attributes.normal) {
        geometry = _Cesium.GeometryPipeline.computeNormal(geometry);
    }
    if (geometry.primitiveType !== _Cesium.PrimitiveType.TRIANGLES) {
        throw new Error("暂不支持此类几何体");
    }
    if (!CSG) {
        throw new Error('CSG 库未加载。请从 https://github.com/evanw/csg.js 获取');
    }
    var faceCount = geometry.indices.length / 3;
    var polygons = [], vertices = [];
    var positions = geometry.attributes.position.values;
    var normals = geometry.attributes.normal.values;
    var normalIdx = 0, positionIdx = 0;

    for (var i = 0; i < geometry.indices.length; i += 3) {
        vertices = [];

        var idx1 = geometry.indices[i];
        var idx2 = geometry.indices[i + 1];
        var idx3 = geometry.indices[i + 2];

        positionIdx = idx1 * 3;
        normalIdx = idx1 * 3;

        vertices.push(new CSG.Vertex(
            [positions[positionIdx++] + offset.x, positions[positionIdx++] + offset.y, positions[positionIdx++] + offset.z],
            [normals[normalIdx++], normals[normalIdx++], normals[normalIdx++]]
        ));

        positionIdx = idx2 * 3;
        normalIdx = idx2 * 3;
        vertices.push(new CSG.Vertex(
            [positions[positionIdx++] + offset.x, positions[positionIdx++] + offset.y, positions[positionIdx++] + offset.z],
            [normals[normalIdx++], normals[normalIdx++], normals[normalIdx++]]
        ));

        positionIdx = idx3 * 3;
        normalIdx = idx3 * 3;
        vertices.push(new CSG.Vertex(
            [positions[positionIdx++] + offset.x, positions[positionIdx++] + offset.y, positions[positionIdx++] + offset.z],
            [normals[normalIdx++], normals[normalIdx++], normals[normalIdx++]]
        ));
        polygons.push(new CSG.Polygon(vertices));
    }
    return CSG.fromPolygons(polygons);
}
/**
*@param {CSG}csg_model
*@param {Boolean}[toGeometry3js=false]
*@return {Cesium.Geometry|THREE.Geometry}
*/
GeometryUtils.fromCSG = function (csg_model, toGeometry3js) {
    if (!(typeof THREE === 'undefined') && toGeometry3js) {
        return GeometryUtils._fromCSG3js(csg_model);
    }

    var i, j, vertices,
        polygons = csg_model.toPolygons();

    if (!CSG) {
        throw new Error('CSG 库未加载。请从 https://github.com/evanw/csg.js 获取');
    }

    const { GeometryAttribute, PrimitiveType, Geometry } = Cesium;

    var positions = [];
    var normals = [];
    var indices = [];

    for (i = 0; i < polygons.length; i++) {

        // Vertices
        vertices = [];
        for (j = 0; j < polygons[i].vertices.length; j++) {
            vertices.push(getGeometryVertice(positions, normals, polygons[i].vertices[j].pos, polygons[i].plane.normal));
        }
        if (vertices[0] === vertices[vertices.length - 1]) {
            vertices.pop();
        }

        for (var j = 2; j < vertices.length; j++) {
            indices.push(vertices[0], vertices[j - 1], vertices[j]);
        }
    }

    positions = new Float32Array(positions);
    normals = new Float32Array(normals);

    indices = new Int32Array(indices);
    var attributes = {};
    attributes.position = new GeometryAttribute({
        componentDatatype: ComponentDatatype.FLOAT,
        componentsPerAttribute: 3,
        values: positions
    });
    attributes.normal = new GeometryAttribute({
        componentDatatype: ComponentDatatype.FLOAT,
        componentsPerAttribute: 3,
        values: normals
    });

    var cesGeometry = new Geometry({
        attributes: attributes,
        indices: indices,
        primitiveType: PrimitiveType.TRIANGLES
    });

    return cesGeometry;
}

GeometryUtils._toCSG3js = function (three_model, offset, rotation) {
    if (typeof THREE === 'undefined') {
        throw new Error("THREE 未加载");
    }

    var i, geometry, polygons, vertices, rotation_matrix;

    if (!CSG) {
        throw 'CSG library not loaded. Please get a copy from https://github.com/evanw/csg.js';
    }

    const { Mesh, Geometry, Euler, Vector3, Matrix4, Face3, Face4 } = THREE;
    const { Vertex, Polygon } = CSG.Vertex;

    if (three_model instanceof Mesh) {
        geometry = three_model.geometry;
        offset = offset || three_model.position;
        rotation = rotation || three_model.rotation;
    } else if (three_model instanceof Geometry) {
        geometry = three_model;
        offset = offset || new Vector3(0, 0, 0);
        rotation = rotation || new Euler(0, 0, 0);
    } else if (three_model.isBufferGeometry) {
        geometry = new Geometry().fromBufferGeometry(three_model);
        offset = offset || new Vector3(0, 0, 0);
        rotation = rotation || new Euler(0, 0, 0);
    } else {
        throw 'Model type not supported.';
    }
    rotation_matrix = new Matrix4().makeRotationFromEuler(rotation);

    var polygons = [];
    const faces = geometry.faces, srcVertices = geometry.vertices;
    for (i = 0; i < faces.length; i++) {

        const face = faces[i]
        const { a, b, c, d, normal } = face;
        const normalArr = [normal.x, normal.y, normal.z]
        if (face instanceof Face3) {


            vertices = [];
            vertices.push(new Vertex(srcVertices[a].clone().add(offset).applyMatrix4(rotation_matrix), normalArr));
            vertices.push(new Vertex(srcVertices[b].clone().add(offset).applyMatrix4(rotation_matrix), normalArr));
            vertices.push(new Vertex(srcVertices[c].clone().add(offset).applyMatrix4(rotation_matrix), normalArr));
            polygons.push(new Polygon(vertices));

        } else if (face instanceof Face4) {

            vertices = [];
            vertices.push(new Vertex(srcVertices[a].clone().add(offset).applyMatrix4(rotation_matrix), normalArr));
            vertices.push(new Vertex(srcVertices[b].clone().add(offset).applyMatrix4(rotation_matrix), normalArr));
            vertices.push(new Vertex(srcVertices[d].clone().add(offset).applyMatrix4(rotation_matrix), normalArr));
            polygons.push(new Polygon(vertices));

            vertices = [];
            vertices.push(new Vertex(srcVertices[b].clone().add(offset).applyMatrix4(rotation_matrix), normalArr));
            vertices.push(new Vertex(srcVertices[c].clone().add(offset).applyMatrix4(rotation_matrix), normalArr));
            vertices.push(new Vertex(srcVertices[d].clone().add(offset).applyMatrix4(rotation_matrix), normalArr));
            polygons.push(new Polygon(vertices));

        } else {
            throw 'Model contains unsupported face.';
        }
    }

    return CSG.fromPolygons(polygons);
}

GeometryUtils._fromCSG3js = function (csg_model) {
    if (typeof THREE === 'undefined') {
        throw new Error("THREE 未加载");
    }
    var i, j, vertices, face,
        three_geometry = new THREE.Geometry(),
        polygons = csg_model.toPolygons();

    if (!CSG) {
        throw 'CSG library not loaded. Please get a copy from https://github.com/evanw/csg.js';
    }

    const { Vector3, Vector2, Face3 } = THREE;

    for (i = 0; i < polygons.length; i++) {

        // Vertices
        vertices = [];
        for (j = 0; j < polygons[i].vertices.length; j++) {
            vertices.push(GeometryUtils._getGeometryVertice3js(three_geometry, polygons[i].vertices[j].pos));
        }
        if (vertices[0] === vertices[vertices.length - 1]) {
            vertices.pop();
        }

        for (var j = 2; j < vertices.length; j++) {
            face = new Face3(vertices[0], vertices[j - 1], vertices[j], new Vector3().copy(polygons[i].plane.normal));
            three_geometry.faces.push(face);
            three_geometry.faceVertexUvs[0].push(new Vector2());
        }
    }

    three_geometry.computeBoundingBox();

    return three_geometry;
}

GeometryUtils._getGeometryVertice3js = function (geometry, vertice_position) {
    var i;
    for (i = 0; i < geometry.vertices.length; i++) {
        if (geometry.vertices[i].x === vertice_position.x && geometry.vertices[i].y === vertice_position.y && geometry.vertices[i].z === vertice_position.z) {
            // Vertice already exists
            return i;
        }
    };

    geometry.vertices.push(new THREE.Vector3(vertice_position.x, vertice_position.y, vertice_position.z));
    return geometry.vertices.length - 1;
}

/**
*@param {Array<Number>}positions
*@param {Array<Number>}normals
*@param {Cesium.CSG.Vector}vertice_position
*@param {Cesium.CSG.Vector}plane_normal
*@return {Number}
*@private
*/
function getGeometryVertice(positions, normals, vertice_position, plane_normal) {
    var i, idx = 0;
    for (i = 0; i < positions.length; i += 3) {
        if (positions[i] === vertice_position.x
            && positions[i + 1] === vertice_position.y
            && positions[i + 2] === vertice_position.z) {
            // Vertice already exists
            return idx;
        }
        idx++;
    };

    positions.push(vertice_position.x, vertice_position.y, vertice_position.z);
    normals.push(plane_normal.x, plane_normal.y, plane_normal.z);
    return idx;
}

/**
 * 
 * @param {THREE.Vec2[]} contour 
 * @param {THREE.Vec2[][]} holes 
 * @param {THREE.Vec2[]} outVertices 
 * @param {number[]} outIndices 
 */
function triangulateShape(contour, holes, outVertices, outIndices) {
    const ShapeUtils = THREE.ShapeUtils;
    const indices = outIndices, vertices = outVertices;
    var i, l, shapeHole;

    var indexOffset = vertices.length;
    //var points = shape.extractPoints(curveSegments);

    var shapeVertices = contour.slice();
    var shapeHoles = holes.map(hole => {
        return hole.slice()
    });

    // check direction of vertices

    if (ShapeUtils.isClockWise(shapeVertices) === false) {

        shapeVertices = shapeVertices.reverse();

    }

    for (i = 0, l = shapeHoles.length; i < l; i++) {

        shapeHole = shapeHoles[i];

        if (ShapeUtils.isClockWise(shapeHole) === true) {

            shapeHoles[i] = shapeHole.reverse();

        }

    }

    var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);

    // join vertices of inner and outer paths to a single array

    for (i = 0, l = shapeHoles.length; i < l; i++) {

        shapeHole = shapeHoles[i];
        shapeVertices = shapeVertices.concat(shapeHole);

    }

    // vertices, normals, uvs

    for (i = 0, l = shapeVertices.length; i < l; i++) {

        var vertex = shapeVertices[i];

        vertices.push(vertex)//.x, vertex.y, 0);
        //normals.push(0, 0, 1);
        //uvs.push(vertex.x, vertex.y); // world uvs

    }

    // incides

    for (i = 0, l = faces.length; i < l; i++) {

        var face = faces[i];

        var a = face[0] + indexOffset;
        var b = face[1] + indexOffset;
        var c = face[2] + indexOffset;

        indices.push(a, b, c);
        //groupCount += 3;

    }
}
GeometryUtils.triangulateShape = triangulateShape

/**
 * 
 * @param {THREE.BufferGeometry} geometry 
 * @returns {number[]}
 */
function genGeometryIndicesAll(geometry) {
    var index = geometry.index
    var groups = geometry.groups;
    var indices;
    if (index) {
        indices = index.array;
    } else {
        if (groups && groups.length > 1) {
            indices = [];
            for (let i = 0; i < groups.length; i++) {
                var tempIndices = genGeometryIndices(geometry, i, false);
                for (let j = 0; j < tempIndices.length; j++) {
                    indices.push(tempIndices[j]);
                }
            }
        } else {
            indices = genGeometryIndices(geometry, 0, true);
        }
    }
    return indices;
}
GeometryUtils.genGeometryIndicesAll = genGeometryIndicesAll;

/**
 * 
 * @param {THREE.BufferGeometry} geometry3js 
 * @param {object}[options]
 * @param {object}[options.angleEpsilon=1] in degrees
 * @param {object}[options.removeCoplanar=true] 
 * @return {THREE.BufferGeometry} 
 */
function toOutlineGeometry3js(geometry3js, options = {}) {
    var _THREE = THREE
    const { Vector3, BufferGeometry, BufferAttribute, MathUtils } = _THREE;
    var angleEpsilon = options.angleEpsilon == undefined ? 1 : options.angleEpsilon;
    angleEpsilon = MathUtils.DEG2RAD * angleEpsilon;

    var removeCoplanar = options.removeCoplanar == undefined ? true : options.removeCoplanar;

    var geometry = geometry3js;
    var position = geometry.getAttribute('position');
    var indices = genGeometryIndicesAll(geometry);
    var A = new Vector3();
    var B = new Vector3();
    var C = new Vector3();

    var newVertices = [], newVertexMap = new Map();
    var edges = [], edgeMap = new Map();

    /**
     * 
     * @param {THREE.Vector3} v 
     */
    function addVertex(v) {
        var key = [v.x, v.y, v.z].join(',');
        var index = newVertexMap.get(key)
        if (index == undefined) {
            index = newVertices.length;
            newVertexMap.set(key, index);
            newVertices.push(v.clone());
        }
        return index;
    }

    function pushEdge(edge, triangle) {
        var edgeCopy = edge.slice()
        edgeCopy.sort((a, b) => {
            return a - b;
        })
        var key = edgeCopy.join(',');
        var edgeUnique = edgeMap.get(key);
        if (!edgeUnique) {
            edgeUnique = {
                edge: edgeCopy,
                triangles: []
            }
            edges.push(edgeUnique)
            edgeMap.set(key, edgeUnique)
        }
        edgeUnique.triangles.push(triangle);
    }

    /**
     *  
     * @param {THREE.Vector3} a 
     * @param {THREE.Vector3} b 
     * @param {THREE.Vector3} c 
     */
    function pushTriangle(a, b, c) {
        a = addVertex(a)
        b = addVertex(b)
        c = addVertex(c)
        var triangle = { a: a, b: b, c: c }
        pushEdge([a, b], triangle)
        pushEdge([b, c], triangle)
        pushEdge([c, a], triangle)
    }

    function getVertex(V, v) {
        V.fromBufferAttribute(position, v);
    }

    for (let i = 0; i < indices.length; i += 3) {
        var a = indices[i], b = indices[i + 1], c = indices[i + 2];
        getVertex(A, a)
        getVertex(B, b)
        getVertex(C, c)
        pushTriangle(A, B, C);
    }

    var polygon = [];
    var N = new Vector3()

    for (let i = 0; i < edges.length; i++) {
        const edgeUnique = edges[i];
        const triangles = edgeUnique.triangles;
        if (triangles.length > 1) {
            var isCoplanar = true;
            if (removeCoplanar) {
                triangles.forEach(triangle => {
                    if (triangle.normal) return;
                    var { a, b, c } = triangle;
                    a = newVertices[a]
                    b = newVertices[b]
                    c = newVertices[c]
                    computeNormal(a, b, c, N, false);
                    triangle.normal = N.clone()
                })
                var N0 = triangles[0].normal;
                for (let j = 1; j < triangles.length; j++) {
                    const triangle = triangles[j];
                    var angle = N0.angleTo(triangle.normal);
                    if (angle > angleEpsilon) {
                        isCoplanar = false
                        break;
                    }
                }
            }
            if (isCoplanar) {
                continue;
            }
        }
        polygon.push(edgeUnique.edge[0], edgeUnique.edge[1])
    }

    position = [];
    polygon.forEach(id => {
        var v = newVertices[id]
        position.push(v.x, v.y, v.z);
    });

    var geometry = new BufferGeometry();
    position = new BufferAttribute(new Float32Array(position), 3, false);
    geometry.setAttribute('position', position);

    edges.length = 0;
    edgeMap.clear()
    newVertices.length = 0
    newVertexMap.clear()
    polygon.length = 0;

    return geometry;
}
GeometryUtils.toOutlineGeometry3js = toOutlineGeometry3js;
export default GeometryUtils;

import IRenderable from './IRenderable.js';
import {
    AmbientLight,
    PerspectiveCamera,
    Scene,
    WebGLRenderer,
    EventDispatcher,
    Object3D,
    Color,
    Vector3,
    Texture,
    Sphere
} from '@mesh-3d/three'
import { OrbitControls, MapControls } from '@mesh-3d/three/examples/jsm/controls/OrbitControls.js';
import { EffectComposer } from '@mesh-3d/three/examples/jsm/postprocessing/EffectComposer';

/**
 * 基础3D显示器类，基于Three.js的WebGLRenderer、Scene、Camera、OrbitControls等常用的类封装3D场景渲染常用功能和基本的交互。
 * @example
 *  var viewer = new MeBaseViewer({
            autoRender: false,
            controlType: 'map'
        });

        viewer.init(document.getElementById('me-viewer'))

        var pLight = new PointLight('orange', 0.5)
        pLight.position.set(100, 100, 100)
        viewer.add(pLight)

        let axes = new AxesHelper(1000)
        viewer.add(new AxesHelper(1000))

        var gridTex = new TextureLoader().load('assets/textures/grid.png', (texture) => {
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping
            texture.repeat.set(100, 100, 100)
            // viewer.update()
        });

        let groud = new Mesh(new PlaneBufferGeometry(1000, 1000), new MeshLambertMaterial({
            color: 'gray',
            map: gridTex
        }))
        groud.rotation.x = -Math.PI / 2
        viewer.add(groud);

        var mesh = new Mesh(new BoxBufferGeometry(100, 100, 100, 18, 18, 18), new MeshPhongMaterial({
            color: 'gray',
            map: gridTex
        }))
        mesh.position.y = 50;
        viewer.add(mesh);

        //保存锁定目标之前的相机参数
        var camera1 = viewer.camera.clone()

        let lookTarget = mesh//new THREE.Vector3(0, 200, 0)
        var { radius, distance, target, eyePosition } = viewer.flyTo(lookTarget, {
            heading: 0,
            pitch: 40,
            range: 0,
            complete() {
            }
        })

        // var { radius, distance, target, eyePosition } = viewer.lookAt(lookTarget, {
        //     heading: 0,
        //     pitch: 40,
        //     range: 0
        // })

        //展示锁定目标计算使用的包围球
        var sp = new Mesh(new SphereBufferGeometry(radius, 64, 64), new MeshLambertMaterial({
            wireframe: true,
            color: 'yellow'
        }))
        sp.add(axes)
        sp.position.copy(target)
        viewer.add(sp)

        //展示锁定之前的相机
        camera1.far = distance
        var ch1 = new CameraHelper(camera1)
        viewer.add(ch1)

        //构建锁定之后的相机并展示
        var camera2 = viewer.camera.clone()
        camera2.far = distance
        camera2.position.copy(eyePosition)
        camera2.lookAt(target)
        camera2.updateMatrixWorld()
        var ch2 = new CameraHelper(camera2)
        viewer.add(ch2)

        //
        viewer.play()
 */
export default class MeBaseViewer extends EventDispatcher {

    /**
     * 基础3D显示器类，基于Three.js的WebGLRenderer、Scene、Camera、OrbitControls等常用的类封装3D场景渲染常用功能和基本的交互。
     * @param options 
     * @example
        var viewer = new MeBaseViewer({
            autoRender: false,
            controlType: 'map'
        });

        viewer.init(document.getElementById('me-viewer'))

        var pLight = new PointLight('orange', 0.5)
        pLight.position.set(100, 100, 100)
        viewer.add(pLight)

        let axes = new AxesHelper(1000)
        viewer.add(new AxesHelper(1000))

        var gridTex = new TextureLoader().load('assets/textures/grid.png', (texture) => {
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping
            texture.repeat.set(100, 100, 100)
            // viewer.update()
        });

        let groud = new Mesh(new PlaneBufferGeometry(1000, 1000), new MeshLambertMaterial({
            color: 'gray',
            map: gridTex
        }))
        groud.rotation.x = -Math.PI / 2
        viewer.add(groud);

        var mesh = new Mesh(new BoxBufferGeometry(100, 100, 100, 18, 18, 18), new MeshPhongMaterial({
            color: 'gray',
            map: gridTex
        }))
        mesh.position.y = 50;
        viewer.add(mesh);

        //保存锁定目标之前的相机参数
        var camera1 = viewer.camera.clone()

        let lookTarget = mesh//new THREE.Vector3(0, 200, 0)
        var { radius, distance, target, eyePosition } = viewer.flyTo(lookTarget, {
            heading: 0,
            pitch: 40,
            range: 0,
            complete() {
            }
        })

        // var { radius, distance, target, eyePosition } = viewer.lookAt(lookTarget, {
        //     heading: 0,
        //     pitch: 40,
        //     range: 0
        // })

        //展示锁定目标计算使用的包围球
        var sp = new Mesh(new SphereBufferGeometry(radius, 64, 64), new MeshLambertMaterial({
            wireframe: true,
            color: 'yellow'
        }))
        sp.add(axes)
        sp.position.copy(target)
        viewer.add(sp)

        //展示锁定之前的相机
        camera1.far = distance
        var ch1 = new CameraHelper(camera1)
        viewer.add(ch1)

        //构建锁定之后的相机并展示
        var camera2 = viewer.camera.clone()
        camera2.far = distance
        camera2.position.copy(eyePosition)
        camera2.lookAt(target)
        camera2.updateMatrixWorld()
        var ch2 = new CameraHelper(camera2)
        viewer.add(ch2)

        //
        viewer.play()
     */
    constructor(options?: {
        /**
         * 容器元素，将three.js渲染器关联的canvas添加到该元素内
         */
        container?: string
        /**
         * 设置默认的控制器类型。orbit——默认绕固定点旋转；map——默认可自由平移旋转。创建之后仍可以通过controlType属性进行切换，map模式下也可以通过lookAt进行锁定或者解除锁定指定点或者目标对象
         * @default "orbit"
         */
        controlType?: "orbit" | "map"
        /**
         * @default window.devicePixelRatio
         */
        pixelRatio?:number
        background?: null | Color | Texture
        stats?:boolean
        logarithmicDepthBuffer?:boolean
        /**
         * @default true
         */
        visible?: boolean
        /**
         * true则自动渲染。创建后仍可以通过play和pause方法控制是否自动渲染
         * @default true
         */
        autoRender?: boolean
    })

    //readonly

    readonly pixelRatio:number
    readonly ambient: AmbientLight
    readonly ready: boolean
    readonly container: HTMLElement
    readonly camera: PerspectiveCamera
    readonly scene: Scene
    readonly renderer: WebGLRenderer
    readonly controls: OrbitControls
    readonly size: {
        width: number
        height: number
    }
    readonly composer: EffectComposer

    //read&write

    controlType: "orbit" | "map"
    background: null | Color | Texture
    environment: null | Texture

    //methods

    /**
     * 初始化渲染器、场景、相机、控制器等基础对象
     * @param pContainer 
     */
    init(pContainer: HTMLElement): this

    /**
     * 根据容器元素重新调整画布大小
     */
    resize(): void

    /**
     * 
     * @param [deltaTime] 
     */
    render(deltaTime?: number): void

    /**
     * 单次执行更新相机并渲染场景
     */
    update(): void

    /**
     * 暂停，关闭自动渲染，可以手动调用update方法渲染
     */
    pause(): this

    /**
     * 播放，开启自动渲染
     */
    play(): this

    /**
     * 停止渲染，并渲染器、场景等释放资源
     */
    dispose(): void

    //事件
    addEventListener(eventType: string, callback: (e: { target: MeBaseViewer, type: string, [attachment: string]: any }) => void): void
    addEventListener(eventType: 'ready', callback: (e: { target: MeBaseViewer, type: string, [attachment: string]: any }) => void): void
    addEventListener(eventType: 'prerender', callback: (e: { target: MeBaseViewer, type: string, [attachment: string]: any }) => void): void
    addEventListener(eventType: 'postrender', callback: (e: { target: MeBaseViewer, type: string, [attachment: string]: any }) => void): void
    addEventListener(eventType: 'dispose', callback: (e: { target: MeBaseViewer, type: string, [attachment: string]: any }) => void): void

    //场景管理相关方法

    /**
     * 添加3D对象
     * @param object 
     */
    add(object: Object3D | IRenderable): this

    /**
     * 移除3D对象
     * @param object 
     * @param [dispose] 指定是否释放资源，true则移除后调用dispose或者触发dispose事件，通知系统释放资源。默认为false
     */
    remove(object: Object3D | IRenderable, dispose?: boolean): this
    removeAll(): this
    /**
     * 将视野锁定到目标对象（或者目标位置）。controlType初始值为'map'的情况下：如果目标对象为null或者undefined，则解锁，即切换为地图模式；否则此后的鼠标操作中，相机将会围绕对象中心旋转。
     * @param object 
     * @param options 
     */
    lookAt(object: Object3D | { boundingSphere: Sphere, [prop: string]: any } | Vector3 | null, options?: {
        /**
         * 偏航角度
         * @default 0
         */
        heading: number
        /**
         * 俯仰角度
         * @default 0
         */
        pitch: number
        /**
         * 观察距离
         * @default 0
         */
        range?: number
    }): {
        radius: number
        distance: number
        eyePosition: Vector3
        target: Vector3
    }

    /**
     * 从相机当前位置飞行到目标对象（或者目标位置）。
     * @param object 
     * @param options 
     */
    flyTo(object: Object3D | { boundingSphere: Sphere, [prop: string]: any } | Vector3, options?: {
        /**
         * 偏航角度
         * @default 0
         */
        heading: number
        /**
         * 俯仰角度
         * @default 0
         */
        pitch: number
        /**
         * 观察距离
         * @default 0
         */
        range?: number
        /**
         * 飞行时间，单位：毫秒/ms
         */
        duration?: number
        complete?: () => void
    }): {
        radius: number
        distance: number
        eyePosition: Vector3
        target: Vector3
    }
}